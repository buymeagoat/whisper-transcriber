{
  "api_endpoints": [
    {
      "auth_required": false,
      "description": "Health check and basic info - redirect to /health for detailed status",
      "file_path": "app/main.py",
      "function_name": "root",
      "line_number": 531,
      "method": "GET",
      "module": "app.main",
      "parameters": [],
      "path": "/",
      "response_model": null
    },
    {
      "auth_required": false,
      "description": "Secure login endpoint with validation and security logging",
      "file_path": "app/main.py",
      "function_name": "login",
      "line_number": 547,
      "method": "POST",
      "module": "app.main",
      "parameters": [
        "request",
        "form_data",
        "db"
      ],
      "path": "/token",
      "response_model": null
    },
    {
      "auth_required": false,
      "description": "Secure user registration with comprehensive validation",
      "file_path": "app/main.py",
      "function_name": "register",
      "line_number": 605,
      "method": "POST",
      "module": "app.main",
      "parameters": [
        "request",
        "registration_data",
        "db"
      ],
      "path": "/register",
      "response_model": null
    },
    {
      "auth_required": true,
      "description": "Secure password change with validation",
      "file_path": "app/main.py",
      "function_name": "change_password",
      "line_number": 668,
      "method": "POST",
      "module": "app.main",
      "parameters": [
        "request",
        "password_data",
        "current_user",
        "db"
      ],
      "path": "/change-password",
      "response_model": null
    },
    {
      "auth_required": false,
      "description": "Secure health check endpoint with validation",
      "file_path": "app/main.py",
      "function_name": "health_check",
      "line_number": 714,
      "method": "GET",
      "module": "app.main",
      "parameters": [
        "db"
      ],
      "path": "/health",
      "response_model": null
    },
    {
      "auth_required": true,
      "description": "Detailed system metrics for monitoring",
      "file_path": "app/main.py",
      "function_name": "get_metrics",
      "line_number": 731,
      "method": "GET",
      "module": "app.main",
      "parameters": [
        "current_user",
        "db"
      ],
      "path": "/metrics",
      "response_model": null
    },
    {
      "auth_required": true,
      "description": "User-accessible statistics",
      "file_path": "app/main.py",
      "function_name": "get_stats",
      "line_number": 788,
      "method": "GET",
      "module": "app.main",
      "parameters": [
        "current_user",
        "db"
      ],
      "path": "/stats",
      "response_model": null
    },
    {
      "auth_required": true,
      "description": "Simple monitoring dashboard (HTML)",
      "file_path": "app/main.py",
      "function_name": "monitoring_dashboard",
      "line_number": 812,
      "method": "GET",
      "module": "app.main",
      "parameters": [
        "current_user"
      ],
      "path": "/dashboard",
      "response_model": null
    },
    {
      "auth_required": true,
      "description": "Secure audio file upload and transcription with comprehensive validation",
      "file_path": "app/main.py",
      "function_name": "create_transcription",
      "line_number": 929,
      "method": "POST",
      "module": "app.main",
      "parameters": [
        "request",
        "file",
        "model",
        "language",
        "current_user",
        "db"
      ],
      "path": "/transcribe",
      "response_model": null
    },
    {
      "auth_required": true,
      "description": "Get job status and details",
      "file_path": "app/main.py",
      "function_name": "get_job",
      "line_number": 1063,
      "method": "GET",
      "module": "app.main",
      "parameters": [
        "job_id",
        "current_user",
        "db"
      ],
      "path": "/jobs/{job_id}",
      "response_model": null
    },
    {
      "auth_required": true,
      "description": "Download completed transcript",
      "file_path": "app/main.py",
      "function_name": "download_transcript",
      "line_number": 1083,
      "method": "GET",
      "module": "app.main",
      "parameters": [
        "job_id",
        "format",
        "current_user",
        "db"
      ],
      "path": "/jobs/{job_id}/download",
      "response_model": null
    },
    {
      "auth_required": true,
      "description": "List jobs with advanced pagination and filtering.\n\nSupports cursor-based pagination for efficient navigation through large datasets.\nIncludes comprehensive filtering options and optional total count.",
      "file_path": "app/main.py",
      "function_name": "list_jobs",
      "line_number": 1120,
      "method": "GET",
      "module": "app.main",
      "parameters": [
        "request",
        "page_size",
        "cursor",
        "sort_by",
        "sort_order",
        "include_total",
        "status",
        "model_used",
        "created_after",
        "created_before",
        "completed_after",
        "completed_before",
        "min_file_size",
        "max_file_size",
        "min_duration",
        "max_duration",
        "current_user",
        "db"
      ],
      "path": "/jobs",
      "response_model": null
    },
    {
      "auth_required": true,
      "description": "Admin endpoint: List all jobs with advanced pagination and filtering.\n\nProvides comprehensive access to all jobs in the system with detailed\nfiltering and pagination capabilities for administrative purposes.",
      "file_path": "app/main.py",
      "function_name": "admin_list_jobs",
      "line_number": 1227,
      "method": "GET",
      "module": "app.main",
      "parameters": [
        "request",
        "page_size",
        "cursor",
        "sort_by",
        "sort_order",
        "include_total",
        "status",
        "model_used",
        "created_after",
        "created_before",
        "completed_after",
        "completed_before",
        "min_file_size",
        "max_file_size",
        "min_duration",
        "max_duration",
        "current_user",
        "db"
      ],
      "path": "/admin/jobs",
      "response_model": null
    },
    {
      "auth_required": true,
      "description": "Securely delete a job and its files with validation",
      "file_path": "app/main.py",
      "function_name": "delete_job",
      "line_number": 1334,
      "method": "DELETE",
      "module": "app.main",
      "parameters": [
        "request",
        "job_id",
        "current_user",
        "db"
      ],
      "path": "/jobs/{job_id}",
      "response_model": null
    },
    {
      "auth_required": false,
      "description": "",
      "file_path": "api/main.py",
      "function_name": "health_check",
      "line_number": 170,
      "method": "GET",
      "module": "api.main",
      "parameters": [],
      "path": "/health",
      "response_model": null
    },
    {
      "auth_required": false,
      "description": "Return the application version from pyproject.toml.",
      "file_path": "api/main.py",
      "function_name": "version",
      "line_number": 181,
      "method": "GET",
      "module": "api.main",
      "parameters": [],
      "path": "/version",
      "response_model": null
    },
    {
      "auth_required": false,
      "description": "Get database performance summary",
      "file_path": "api/performance_middleware.py",
      "function_name": "get_performance_summary",
      "line_number": 185,
      "method": "GET",
      "module": "api.performance_middleware",
      "parameters": [
        "hours",
        "db"
      ],
      "path": "/admin/performance/summary",
      "response_model": null
    },
    {
      "auth_required": false,
      "description": "Get slow query analysis",
      "file_path": "api/performance_middleware.py",
      "function_name": "get_slow_queries",
      "line_number": 193,
      "method": "GET",
      "module": "api.performance_middleware",
      "parameters": [
        "limit",
        "min_duration_ms",
        "db"
      ],
      "path": "/admin/performance/queries",
      "response_model": null
    },
    {
      "auth_required": false,
      "description": "Get performance metrics",
      "file_path": "api/performance_middleware.py",
      "function_name": "get_performance_metrics",
      "line_number": 218,
      "method": "GET",
      "module": "api.performance_middleware",
      "parameters": [
        "hours",
        "metric_type",
        "db"
      ],
      "path": "/admin/performance/metrics",
      "response_model": null
    },
    {
      "auth_required": false,
      "description": "",
      "file_path": "api/router_setup.py",
      "function_name": "spa_index",
      "line_number": 62,
      "method": "GET",
      "module": "api.router_setup",
      "parameters": [],
      "path": "/",
      "response_model": null
    },
    {
      "auth_required": false,
      "description": "",
      "file_path": "api/router_setup.py",
      "function_name": "spa_fallback",
      "line_number": 66,
      "method": "GET",
      "module": "api.router_setup",
      "parameters": [
        "full_path"
      ],
      "path": "/{full_path:path}",
      "response_model": null
    }
  ],
  "background_jobs": [],
  "config_vars": {
    "ACCESS_TOKEN_EXPIRE_MINUTES": {
      "default_value": "30",
      "description": "",
      "name": "ACCESS_TOKEN_EXPIRE_MINUTES",
      "read_sites": [
        [
          ".env.example",
          65
        ]
      ]
    },
    "ALLOWED_ORIGINS": {
      "default_value": "",
      "description": "",
      "name": "ALLOWED_ORIGINS",
      "read_sites": [
        [
          ".env.example",
          29
        ]
      ]
    },
    "ALLOW_REGISTRATION": {
      "default_value": "true",
      "description": "",
      "name": "ALLOW_REGISTRATION",
      "read_sites": [
        [
          ".env.example",
          62
        ]
      ]
    },
    "AUTH_PASSWORD": {
      "default_value": "changeme",
      "description": "",
      "name": "AUTH_PASSWORD",
      "read_sites": [
        [
          ".env",
          23
        ]
      ]
    },
    "AUTH_USERNAME": {
      "default_value": "admin",
      "description": "",
      "name": "AUTH_USERNAME",
      "read_sites": [
        [
          ".env",
          22
        ]
      ]
    },
    "BROKER_CONNECT_ATTEMPTS": {
      "default_value": "20",
      "description": "",
      "name": "BROKER_CONNECT_ATTEMPTS",
      "read_sites": [
        [
          ".env",
          18
        ]
      ]
    },
    "CELERY_BACKEND_URL": {
      "default_value": "rpc://",
      "description": "",
      "name": "CELERY_BACKEND_URL",
      "read_sites": [
        [
          ".env",
          42
        ]
      ]
    },
    "CELERY_BROKER_URL": {
      "default_value": "amqp://guest:guest@broker:5672//",
      "description": "",
      "name": "CELERY_BROKER_URL",
      "read_sites": [
        [
          ".env",
          41
        ]
      ]
    },
    "CLEANUP_DAYS": {
      "default_value": "30",
      "description": "",
      "name": "CLEANUP_DAYS",
      "read_sites": [
        [
          ".env.example",
          74
        ]
      ]
    },
    "CLEANUP_ENABLED": {
      "default_value": "true",
      "description": "",
      "name": "CLEANUP_ENABLED",
      "read_sites": [
        [
          ".env.example",
          73
        ]
      ]
    },
    "CLEANUP_INTERVAL_SECONDS": {
      "default_value": "86400",
      "description": "",
      "name": "CLEANUP_INTERVAL_SECONDS",
      "read_sites": [
        [
          ".env.example",
          75
        ]
      ]
    },
    "CORS_ORIGINS": {
      "default_value": "*",
      "description": "",
      "name": "CORS_ORIGINS",
      "read_sites": [
        [
          ".env",
          54
        ]
      ]
    },
    "DB_CONNECT_ATTEMPTS": {
      "default_value": "10",
      "description": "",
      "name": "DB_CONNECT_ATTEMPTS",
      "read_sites": [
        [
          ".env",
          17
        ]
      ]
    },
    "DB_URL": {
      "default_value": "sqlite:///./whisper_dev.db",
      "description": "",
      "name": "DB_URL",
      "read_sites": [
        [
          ".env",
          2
        ]
      ]
    },
    "ENABLE_SERVER_CONTROL": {
      "default_value": "false",
      "description": "",
      "name": "ENABLE_SERVER_CONTROL",
      "read_sites": [
        [
          ".env",
          50
        ]
      ]
    },
    "ENVIRONMENT": {
      "default_value": "development",
      "description": "",
      "name": "ENVIRONMENT",
      "read_sites": [
        [
          ".env.example",
          23
        ]
      ]
    },
    "JOB_QUEUE_BACKEND": {
      "default_value": "thread",
      "description": "",
      "name": "JOB_QUEUE_BACKEND",
      "read_sites": [
        [
          ".env.example",
          35
        ]
      ]
    },
    "LOCAL_STORAGE_DIR": {
      "default_value": "uploads",
      "description": "",
      "name": "LOCAL_STORAGE_DIR",
      "read_sites": [
        [
          ".env.example",
          37
        ]
      ]
    },
    "LOG_BACKUP_COUNT": {
      "default_value": "3",
      "description": "",
      "name": "LOG_BACKUP_COUNT",
      "read_sites": [
        [
          ".env",
          10
        ]
      ]
    },
    "LOG_FORMAT": {
      "default_value": "standard",
      "description": "",
      "name": "LOG_FORMAT",
      "read_sites": [
        [
          ".env.example",
          48
        ]
      ]
    },
    "LOG_LEVEL": {
      "default_value": "INFO",
      "description": "",
      "name": "LOG_LEVEL",
      "read_sites": [
        [
          ".env.example",
          45
        ]
      ]
    },
    "LOG_MAX_BYTES": {
      "default_value": "10000000",
      "description": "",
      "name": "LOG_MAX_BYTES",
      "read_sites": [
        [
          ".env",
          9
        ]
      ]
    },
    "LOG_TO_STDOUT": {
      "default_value": "false",
      "description": "",
      "name": "LOG_TO_STDOUT",
      "read_sites": [
        [
          ".env.example",
          51
        ]
      ]
    },
    "MAX_CONCURRENT_JOBS": {
      "default_value": "2",
      "description": "",
      "name": "MAX_CONCURRENT_JOBS",
      "read_sites": [
        [
          ".env.example",
          72
        ]
      ]
    },
    "MAX_FILENAME_LENGTH": {
      "default_value": "255",
      "description": "",
      "name": "MAX_FILENAME_LENGTH",
      "read_sites": [
        [
          ".env.example",
          13
        ]
      ]
    },
    "MAX_FILE_SIZE": {
      "default_value": "104857600",
      "description": "",
      "name": "MAX_FILE_SIZE",
      "read_sites": [
        [
          ".env.example",
          10
        ]
      ]
    },
    "MAX_UPLOAD_SIZE": {
      "default_value": "2147483648",
      "description": "",
      "name": "MAX_UPLOAD_SIZE",
      "read_sites": [
        [
          ".env",
          13
        ]
      ]
    },
    "MODEL_DIR": {
      "default_value": "models",
      "description": "",
      "name": "MODEL_DIR",
      "read_sites": [
        [
          ".env.example",
          38
        ]
      ]
    },
    "OPENAI_MODEL": {
      "default_value": "gpt-3.5-turbo",
      "description": "",
      "name": "OPENAI_MODEL",
      "read_sites": [
        [
          ".env",
          58
        ]
      ]
    },
    "PORT": {
      "default_value": "8000",
      "description": "",
      "name": "PORT",
      "read_sites": [
        [
          ".env.example",
          2
        ]
      ]
    },
    "SECRET_KEY": {
      "default_value": "change_this_in_production_use_secrets_token_hex_32",
      "description": "",
      "name": "SECRET_KEY",
      "read_sites": [
        [
          ".env.example",
          59
        ]
      ]
    },
    "STORAGE_BACKEND": {
      "default_value": "local",
      "description": "",
      "name": "STORAGE_BACKEND",
      "read_sites": [
        [
          ".env.example",
          36
        ]
      ]
    },
    "TIMEZONE": {
      "default_value": "UTC",
      "description": "",
      "name": "TIMEZONE",
      "read_sites": [
        [
          ".env.example",
          76
        ]
      ]
    },
    "UPLOAD_TIMEOUT": {
      "default_value": "300",
      "description": "",
      "name": "UPLOAD_TIMEOUT",
      "read_sites": [
        [
          ".env.example",
          16
        ]
      ]
    },
    "VITE_API_HOST": {
      "default_value": "http://localhost:8000",
      "description": "",
      "name": "VITE_API_HOST",
      "read_sites": [
        [
          ".env.example",
          3
        ]
      ]
    },
    "WHISPER_BIN": {
      "default_value": "whisper",
      "description": "",
      "name": "WHISPER_BIN",
      "read_sites": [
        [
          ".env",
          33
        ]
      ]
    },
    "WHISPER_LANGUAGE": {
      "default_value": "en",
      "description": "",
      "name": "WHISPER_LANGUAGE",
      "read_sites": [
        [
          ".env.example",
          77
        ]
      ]
    },
    "WHISPER_TIMEOUT_SECONDS": {
      "default_value": "0",
      "description": "",
      "name": "WHISPER_TIMEOUT_SECONDS",
      "read_sites": [
        [
          ".env.example",
          78
        ]
      ]
    }
  },
  "data_stores": [
    {
      "access_points": [],
      "entities": [],
      "location": "app.db",
      "name": "app.db",
      "type": "sqlite"
    }
  ],
  "external_services": [],
  "functions": {
    "api.main.health_check": {
      "calls": [
        "SessionLocal",
        "db.execute",
        "app.get",
        "JSONResponse",
        "system_log.error",
        "text"
      ],
      "decorators": [
        "app.get"
      ],
      "docstring": null,
      "file_path": "api/main.py",
      "is_async": false,
      "is_endpoint": true,
      "line_end": 177,
      "line_start": 170,
      "module": "api.main",
      "name": "health_check",
      "signature": "def health_check():"
    },
    "api.main.lifespan": {
      "calls": [
        "validate_or_initialize_database",
        "stop_cleanup_thread",
        "system_log.warning",
        "start_backup_service_if_configured",
        "validate_models_dir",
        "start_cleanup_thread",
        "shutdown_backup_service",
        "system_log.error",
        "rehydrate_incomplete_jobs",
        "system_log.info",
        "initialize_backup_service",
        "ensure_default_admin"
      ],
      "decorators": [
        "asynccontextmanager"
      ],
      "docstring": "App lifespan events.",
      "file_path": "api/main.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 129,
      "line_start": 84,
      "module": "api.main",
      "name": "lifespan",
      "signature": "async def lifespan(app: FastAPI):"
    },
    "api.main.log_startup_settings": {
      "calls": [
        "system_log.info"
      ],
      "decorators": [],
      "docstring": "Log key configuration settings.",
      "file_path": "api/main.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 69,
      "line_start": 61,
      "module": "api.main",
      "name": "log_startup_settings",
      "signature": "def log_startup_settings() -> None:"
    },
    "api.main.rehydrate_incomplete_jobs": {
      "calls": [
        "SessionLocal",
        "backend_log.error",
        "storage.get_upload_path",
        "app_state.job_queue.enqueue",
        "Job.status.in_",
        "filter",
        "db.query",
        "all",
        "partial",
        "storage.get_transcript_dir",
        "backend_log.info"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "api/main.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 229,
      "line_start": 198,
      "module": "api.main",
      "name": "rehydrate_incomplete_jobs",
      "signature": "def rehydrate_incomplete_jobs():"
    },
    "api.main.version": {
      "calls": [
        "data.get",
        "get",
        "app.get",
        "str",
        "pyproject.read_text",
        "tomllib.loads"
      ],
      "decorators": [
        "app.get"
      ],
      "docstring": "Return the application version from pyproject.toml.",
      "file_path": "api/main.py",
      "is_async": false,
      "is_endpoint": true,
      "line_end": 195,
      "line_start": 181,
      "module": "api.main",
      "name": "version",
      "signature": "def version() -> dict:"
    },
    "api.migrations.versions.001_add_performance_indexes_and_metrics.downgrade": {
      "calls": [
        "batch_op.drop_column",
        "op.drop_index",
        "op.batch_alter_table",
        "op.drop_table",
        "batch_op.drop_constraint"
      ],
      "decorators": [],
      "docstring": "Remove performance optimizations and monitoring tables",
      "file_path": "api/migrations/versions/001_add_performance_indexes_and_metrics.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 254,
      "line_start": 164,
      "module": "api.migrations.versions.001_add_performance_indexes_and_metrics",
      "name": "downgrade",
      "signature": "def downgrade() -> None:"
    },
    "api.migrations.versions.001_add_performance_indexes_and_metrics.upgrade": {
      "calls": [
        "sa.String",
        "sa.Integer",
        "sa.Float",
        "batch_op.create_foreign_key",
        "sa.Boolean",
        "op.create_index",
        "sa.Text",
        "batch_op.add_column",
        "op.batch_alter_table",
        "sa.Column",
        "sa.text",
        "sa.PrimaryKeyConstraint",
        "op.create_table",
        "sa.DateTime"
      ],
      "decorators": [],
      "docstring": "Add performance optimizations and monitoring tables",
      "file_path": "api/migrations/versions/001_add_performance_indexes_and_metrics.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 161,
      "line_start": 20,
      "module": "api.migrations.versions.001_add_performance_indexes_and_metrics",
      "name": "upgrade",
      "signature": "def upgrade() -> None:"
    },
    "api.migrations.versions.schema_cleanup_006.downgrade": {
      "calls": [
        "sa.String",
        "op.execute",
        "op.add_column",
        "op.alter_column",
        "op.drop_index",
        "sa.Column"
      ],
      "decorators": [],
      "docstring": "Reverse schema cleanup changes.",
      "file_path": "api/migrations/versions/schema_cleanup_006.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 100,
      "line_start": 72,
      "module": "api.migrations.versions.schema_cleanup_006",
      "name": "downgrade",
      "signature": "def downgrade() -> None:"
    },
    "api.migrations.versions.schema_cleanup_006.upgrade": {
      "calls": [
        "op.alter_column",
        "op.drop_column",
        "op.create_index",
        "op.execute"
      ],
      "decorators": [],
      "docstring": "Schema cleanup improvements.",
      "file_path": "api/migrations/versions/schema_cleanup_006.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 66,
      "line_start": 19,
      "module": "api.migrations.versions.schema_cleanup_006",
      "name": "upgrade",
      "signature": "def upgrade() -> None:"
    },
    "api.models.AuditLog.__repr__": {
      "calls": [],
      "decorators": [],
      "docstring": null,
      "file_path": "api/models.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 175,
      "line_start": 174,
      "module": "api.models",
      "name": "AuditLog.__repr__",
      "signature": "def __repr__(self) -> str:  # pragma: no cover - trivial return f\"<AuditLog {self.id}:{self.event_type}@{self.timestamp}>\"   # \u2500\u2500\u2500 Performance Metrics Table for Database Monitoring \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 class PerformanceMetric(Base):"
    },
    "api.models.ConfigEntry.__repr__": {
      "calls": [],
      "decorators": [],
      "docstring": null,
      "file_path": "api/models.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 127,
      "line_start": 126,
      "module": "api.models",
      "name": "ConfigEntry.__repr__",
      "signature": "def __repr__(self) -> str:  # pragma: no cover - trivial return f\"<Config {self.key}={self.value}>\"   # \u2500\u2500\u2500 User Settings Table \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 class UserSetting(Base):"
    },
    "api.models.Job.__repr__": {
      "calls": [],
      "decorators": [],
      "docstring": null,
      "file_path": "api/models.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 87,
      "line_start": 86,
      "module": "api.models",
      "name": "Job.__repr__",
      "signature": "def __repr__(self):"
    },
    "api.models.PerformanceMetric.__repr__": {
      "calls": [],
      "decorators": [],
      "docstring": null,
      "file_path": "api/models.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 202,
      "line_start": 201,
      "module": "api.models",
      "name": "PerformanceMetric.__repr__",
      "signature": "def __repr__(self) -> str:"
    },
    "api.models.QueryPerformanceLog.__repr__": {
      "calls": [],
      "decorators": [],
      "docstring": null,
      "file_path": "api/models.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 232,
      "line_start": 231,
      "module": "api.models",
      "name": "QueryPerformanceLog.__repr__",
      "signature": "def __repr__(self) -> str:"
    },
    "api.models.TranscriptMetadata.__repr__": {
      "calls": [],
      "decorators": [],
      "docstring": null,
      "file_path": "api/models.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 114,
      "line_start": 113,
      "module": "api.models",
      "name": "TranscriptMetadata.__repr__",
      "signature": "def __repr__(self):"
    },
    "api.models.UserSetting.__repr__": {
      "calls": [],
      "decorators": [],
      "docstring": null,
      "file_path": "api/models.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 141,
      "line_start": 140,
      "module": "api.models",
      "name": "UserSetting.__repr__",
      "signature": "def __repr__(self) -> str:  # pragma: no cover - trivial return f\"<UserSetting {self.user_id}:{self.key}={self.value}>\"   # \u2500\u2500\u2500 Audit Logs Table \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 class AuditLog(Base):"
    },
    "api.models.__repr__": {
      "calls": [],
      "decorators": [],
      "docstring": null,
      "file_path": "api/models.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 232,
      "line_start": 231,
      "module": "api.models",
      "name": "__repr__",
      "signature": "def __repr__(self) -> str:"
    },
    "api.models_optimized.AuditLog.__repr__": {
      "calls": [],
      "decorators": [],
      "docstring": null,
      "file_path": "api/models_optimized.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 267,
      "line_start": 266,
      "module": "api.models_optimized",
      "name": "AuditLog.__repr__",
      "signature": "def __repr__(self) -> str:"
    },
    "api.models_optimized.ConfigEntry.__repr__": {
      "calls": [],
      "decorators": [],
      "docstring": null,
      "file_path": "api/models_optimized.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 191,
      "line_start": 190,
      "module": "api.models_optimized",
      "name": "ConfigEntry.__repr__",
      "signature": "def __repr__(self) -> str:"
    },
    "api.models_optimized.Job.__repr__": {
      "calls": [],
      "decorators": [],
      "docstring": null,
      "file_path": "api/models_optimized.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 130,
      "line_start": 129,
      "module": "api.models_optimized",
      "name": "Job.__repr__",
      "signature": "def __repr__(self):"
    },
    "api.models_optimized.PerformanceMetric.__repr__": {
      "calls": [],
      "decorators": [],
      "docstring": null,
      "file_path": "api/models_optimized.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 294,
      "line_start": 293,
      "module": "api.models_optimized",
      "name": "PerformanceMetric.__repr__",
      "signature": "def __repr__(self) -> str:"
    },
    "api.models_optimized.QueryPerformanceLog.__repr__": {
      "calls": [],
      "decorators": [],
      "docstring": null,
      "file_path": "api/models_optimized.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 324,
      "line_start": 323,
      "module": "api.models_optimized",
      "name": "QueryPerformanceLog.__repr__",
      "signature": "def __repr__(self) -> str:"
    },
    "api.models_optimized.TranscriptMetadata.__repr__": {
      "calls": [],
      "decorators": [],
      "docstring": null,
      "file_path": "api/models_optimized.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 171,
      "line_start": 170,
      "module": "api.models_optimized",
      "name": "TranscriptMetadata.__repr__",
      "signature": "def __repr__(self):"
    },
    "api.models_optimized.UserSetting.__repr__": {
      "calls": [],
      "decorators": [],
      "docstring": null,
      "file_path": "api/models_optimized.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 216,
      "line_start": 215,
      "module": "api.models_optimized",
      "name": "UserSetting.__repr__",
      "signature": "def __repr__(self) -> str:"
    },
    "api.models_optimized.__repr__": {
      "calls": [],
      "decorators": [],
      "docstring": null,
      "file_path": "api/models_optimized.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 324,
      "line_start": 323,
      "module": "api.models_optimized",
      "name": "__repr__",
      "signature": "def __repr__(self) -> str:"
    },
    "api.optimized_endpoints.get_admin_dashboard_optimized": {
      "calls": [
        "HTTPException",
        "OptimizedJobQueries.get_job_statistics",
        "job.updated_at.isoformat",
        "last_login.isoformat",
        "performance_tracked",
        "min",
        "event.timestamp.isoformat",
        "OptimizedMetadataQueries.get_metadata_analytics",
        "OptimizedJobQueries.get_recent_active_jobs",
        "datetime.utcnow",
        "max",
        "OptimizedAuditLogQueries.get_security_events",
        "job.created_at.isoformat",
        "OptimizedUserQueries.get_active_users_with_stats",
        "isoformat"
      ],
      "decorators": [
        "performance_tracked"
      ],
      "docstring": "Optimized admin dashboard with efficient aggregation queries\nReplaces multiple individual queries with optimized patterns",
      "file_path": "api/optimized_endpoints.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 257,
      "line_start": 183,
      "module": "api.optimized_endpoints",
      "name": "get_admin_dashboard_optimized",
      "signature": "def get_admin_dashboard_optimized( db: Session, current_user: User, hours: int = 24 ) -> Dict[str, Any]:"
    },
    "api.optimized_endpoints.get_job_detail_optimized": {
      "calls": [
        "HTTPException",
        "job.updated_at.isoformat",
        "performance_tracked",
        "job.finished_at.isoformat",
        "hasattr",
        "job.metadata.generated_at.isoformat",
        "OptimizedJobQueries.get_job_with_user_and_metadata",
        "job.started_at.isoformat",
        "job.created_at.isoformat"
      ],
      "decorators": [
        "performance_tracked"
      ],
      "docstring": "Optimized job detail retrieval with metadata in single query\nPrevents N+1 queries by eager loading related data",
      "file_path": "api/optimized_endpoints.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 144,
      "line_start": 90,
      "module": "api.optimized_endpoints",
      "name": "get_job_detail_optimized",
      "signature": "def get_job_detail_optimized( db: Session, job_id: str, current_user: User, include_metadata: bool = True ) -> Dict[str, Any]:"
    },
    "api.optimized_endpoints.get_job_statistics_optimized": {
      "calls": [
        "OptimizedJobQueries.get_job_statistics",
        "performance_tracked",
        "min",
        "datetime.utcnow",
        "stats.update",
        "max",
        "isoformat"
      ],
      "decorators": [
        "performance_tracked"
      ],
      "docstring": "Optimized job statistics using aggregation queries\nMuch more efficient than counting individual queries",
      "file_path": "api/optimized_endpoints.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 175,
      "line_start": 148,
      "module": "api.optimized_endpoints",
      "name": "get_job_statistics_optimized",
      "signature": "def get_job_statistics_optimized( db: Session, current_user: User, days: int = 30, user_id: Optional[int] = None ) -> Dict[str, Any]:"
    },
    "api.optimized_endpoints.get_user_activity_optimized": {
      "calls": [
        "HTTPException",
        "performance_tracked",
        "min",
        "OptimizedAuditLogQueries.get_user_activity_summary",
        "datetime.utcnow",
        "max",
        "isoformat"
      ],
      "decorators": [
        "performance_tracked"
      ],
      "docstring": "Optimized user activity summary with efficient queries",
      "file_path": "api/optimized_endpoints.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 294,
      "line_start": 265,
      "module": "api.optimized_endpoints",
      "name": "get_user_activity_optimized",
      "signature": "def get_user_activity_optimized( db: Session, current_user: User, user_id: Optional[int] = None, days: int = 7 ) -> Dict[str, Any]:"
    },
    "api.optimized_endpoints.list_jobs_optimized": {
      "calls": [
        "job.updated_at.isoformat",
        "OptimizedJobQueries.get_jobs_by_user_paginated",
        "performance_tracked",
        "min",
        "job.finished_at.isoformat",
        "max",
        "job.created_at.isoformat",
        "job.started_at.isoformat"
      ],
      "decorators": [
        "performance_tracked"
      ],
      "docstring": "Optimized job listing with pagination and efficient querying\nReplaces the N+1 query pattern in the original implementation",
      "file_path": "api/optimized_endpoints.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 86,
      "line_start": 27,
      "module": "api.optimized_endpoints",
      "name": "list_jobs_optimized",
      "signature": "def list_jobs_optimized( db: Session, current_user: User, page: int = 1, page_size: int = 20, status: Optional[str] = None, user_id: Optional[int] = None  # Admin can filter by user ) -> Dict[str, Any]:"
    },
    "api.optimized_endpoints.search_jobs_optimized": {
      "calls": [
        "or_",
        "limit",
        "date_from.isoformat",
        "Job.original_filename.ilike",
        "performance_tracked",
        "min",
        "filter",
        "search_query.order_by",
        "search_query.count",
        "db.query",
        "Job.id.ilike",
        "all",
        "Job.created_at.desc",
        "offset",
        "job.created_at.isoformat",
        "query.strip",
        "search_query.filter",
        "date_to.isoformat",
        "max"
      ],
      "decorators": [
        "performance_tracked"
      ],
      "docstring": "Optimized job search with efficient filtering and pagination",
      "file_path": "api/optimized_endpoints.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 381,
      "line_start": 302,
      "module": "api.optimized_endpoints",
      "name": "search_jobs_optimized",
      "signature": "def search_jobs_optimized( db: Session, current_user: User, query: str, page: int = 1, page_size: int = 20, status: Optional[str] = None, date_from: Optional[datetime] = None, date_to: Optional[datetime] = None ) -> Dict[str, Any]:"
    },
    "api.performance_middleware.DatabasePerformanceMiddleware.__init__": {
      "calls": [
        "super",
        "__init__"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "api/performance_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 34,
      "line_start": 23,
      "module": "api.performance_middleware",
      "name": "DatabasePerformanceMiddleware.__init__",
      "signature": "def __init__( self, app: ASGIApp, slow_request_threshold_ms: float = 1000.0, enable_detailed_logging: bool = True, enable_metrics_collection: bool = True ):"
    },
    "api.performance_middleware.DatabasePerformanceMiddleware._collect_performance_metrics": {
      "calls": [
        "str",
        "DatabasePerformanceCollector.record_metric",
        "getattr",
        "print"
      ],
      "decorators": [],
      "docstring": "Collect performance metrics to database",
      "file_path": "api/performance_middleware.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 131,
      "line_start": 87,
      "module": "api.performance_middleware",
      "name": "DatabasePerformanceMiddleware._collect_performance_metrics",
      "signature": "async def _collect_performance_metrics(self, db: Session, request: Request, total_time_ms: float, query_count: int, query_time_ms: float):"
    },
    "api.performance_middleware.DatabasePerformanceMiddleware._log_slow_request": {
      "calls": [
        "request.headers.get",
        "print"
      ],
      "decorators": [],
      "docstring": "Log details of slow requests",
      "file_path": "api/performance_middleware.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 85,
      "line_start": 77,
      "module": "api.performance_middleware",
      "name": "DatabasePerformanceMiddleware._log_slow_request",
      "signature": "async def _log_slow_request(self, request: Request, response: Response, total_time_ms: float, query_count: int, query_time_ms: float):"
    },
    "api.performance_middleware.DatabasePerformanceMiddleware.dispatch": {
      "calls": [
        "getattr",
        "call_next",
        "str",
        "time.time",
        "round",
        "int",
        "self._log_slow_request",
        "self._collect_performance_metrics"
      ],
      "decorators": [],
      "docstring": "Monitor database performance for each request",
      "file_path": "api/performance_middleware.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 75,
      "line_start": 36,
      "module": "api.performance_middleware",
      "name": "DatabasePerformanceMiddleware.dispatch",
      "signature": "async def dispatch(self, request: Request, call_next: Callable) -> Response:"
    },
    "api.performance_middleware.DatabaseQueryCounter.__enter__": {
      "calls": [
        "time.time"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "api/performance_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 143,
      "line_start": 141,
      "module": "api.performance_middleware",
      "name": "DatabaseQueryCounter.__enter__",
      "signature": "def __enter__(self):"
    },
    "api.performance_middleware.DatabaseQueryCounter.__exit__": {
      "calls": [
        "time.time",
        "getattr"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "api/performance_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 154,
      "line_start": 145,
      "module": "api.performance_middleware",
      "name": "DatabaseQueryCounter.__exit__",
      "signature": "def __exit__(self, exc_type, exc_val, exc_tb):"
    },
    "api.performance_middleware.DatabaseQueryCounter.__init__": {
      "calls": [],
      "decorators": [],
      "docstring": null,
      "file_path": "api/performance_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 139,
      "line_start": 137,
      "module": "api.performance_middleware",
      "name": "DatabaseQueryCounter.__init__",
      "signature": "def __init__(self, request: Request):"
    },
    "api.performance_middleware.PerformanceAwareSession.__init__": {
      "calls": [
        "super",
        "__init__"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "api/performance_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 260,
      "line_start": 256,
      "module": "api.performance_middleware",
      "name": "PerformanceAwareSession.__init__",
      "signature": "def __init__(self, *args, request: Optional[Request] = None, **kwargs):"
    },
    "api.performance_middleware.PerformanceAwareSession.execute": {
      "calls": [
        "super",
        "time.time",
        "getattr",
        "execute"
      ],
      "decorators": [],
      "docstring": "Override execute to track performance",
      "file_path": "api/performance_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 277,
      "line_start": 262,
      "module": "api.performance_middleware",
      "name": "PerformanceAwareSession.execute",
      "signature": "def execute(self, statement, parameters=None, execution_options=None, bind=None, _parent_execute_state=None, _add_event=None):"
    },
    "api.performance_middleware.PerformanceAwareSession.get_performance_stats": {
      "calls": [
        "max"
      ],
      "decorators": [],
      "docstring": "Get performance statistics for this session",
      "file_path": "api/performance_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 285,
      "line_start": 279,
      "module": "api.performance_middleware",
      "name": "PerformanceAwareSession.get_performance_stats",
      "signature": "def get_performance_stats(self) -> Dict[str, Any]:"
    },
    "api.performance_middleware.__enter__": {
      "calls": [
        "time.time"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "api/performance_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 143,
      "line_start": 141,
      "module": "api.performance_middleware",
      "name": "__enter__",
      "signature": "def __enter__(self):"
    },
    "api.performance_middleware.__exit__": {
      "calls": [
        "time.time",
        "getattr"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "api/performance_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 154,
      "line_start": 145,
      "module": "api.performance_middleware",
      "name": "__exit__",
      "signature": "def __exit__(self, exc_type, exc_val, exc_tb):"
    },
    "api.performance_middleware.__init__": {
      "calls": [
        "super",
        "__init__"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "api/performance_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 260,
      "line_start": 256,
      "module": "api.performance_middleware",
      "name": "__init__",
      "signature": "def __init__(self, *args, request: Optional[Request] = None, **kwargs):"
    },
    "api.performance_middleware._collect_performance_metrics": {
      "calls": [
        "str",
        "DatabasePerformanceCollector.record_metric",
        "getattr",
        "print"
      ],
      "decorators": [],
      "docstring": "Collect performance metrics to database",
      "file_path": "api/performance_middleware.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 131,
      "line_start": 87,
      "module": "api.performance_middleware",
      "name": "_collect_performance_metrics",
      "signature": "async def _collect_performance_metrics(self, db: Session, request: Request, total_time_ms: float, query_count: int, query_time_ms: float):"
    },
    "api.performance_middleware._log_slow_request": {
      "calls": [
        "request.headers.get",
        "print"
      ],
      "decorators": [],
      "docstring": "Log details of slow requests",
      "file_path": "api/performance_middleware.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 85,
      "line_start": 77,
      "module": "api.performance_middleware",
      "name": "_log_slow_request",
      "signature": "async def _log_slow_request(self, request: Request, response: Response, total_time_ms: float, query_count: int, query_time_ms: float):"
    },
    "api.performance_middleware.dispatch": {
      "calls": [
        "getattr",
        "call_next",
        "str",
        "time.time",
        "round",
        "int",
        "self._log_slow_request",
        "self._collect_performance_metrics"
      ],
      "decorators": [],
      "docstring": "Monitor database performance for each request",
      "file_path": "api/performance_middleware.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 75,
      "line_start": 36,
      "module": "api.performance_middleware",
      "name": "dispatch",
      "signature": "async def dispatch(self, request: Request, call_next: Callable) -> Response:"
    },
    "api.performance_middleware.execute": {
      "calls": [
        "super",
        "time.time",
        "getattr",
        "execute"
      ],
      "decorators": [],
      "docstring": "Override execute to track performance",
      "file_path": "api/performance_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 277,
      "line_start": 262,
      "module": "api.performance_middleware",
      "name": "execute",
      "signature": "def execute(self, statement, parameters=None, execution_options=None, bind=None, _parent_execute_state=None, _add_event=None):"
    },
    "api.performance_middleware.get_performance_metrics": {
      "calls": [
        "app.get",
        "query.filter",
        "limit",
        "filter",
        "timedelta",
        "db.query",
        "datetime.utcnow",
        "query.order_by",
        "all",
        "desc",
        "json.loads",
        "metric.timestamp.isoformat"
      ],
      "decorators": [
        "app.get"
      ],
      "docstring": "Get performance metrics",
      "file_path": "api/performance_middleware.py",
      "is_async": true,
      "is_endpoint": true,
      "line_end": 246,
      "line_start": 218,
      "module": "api.performance_middleware",
      "name": "get_performance_metrics",
      "signature": "async def get_performance_metrics(hours: int = 24, metric_type: Optional[str] = None, db: Session = None):"
    },
    "api.performance_middleware.get_performance_stats": {
      "calls": [
        "max"
      ],
      "decorators": [],
      "docstring": "Get performance statistics for this session",
      "file_path": "api/performance_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 285,
      "line_start": 279,
      "module": "api.performance_middleware",
      "name": "get_performance_stats",
      "signature": "def get_performance_stats(self) -> Dict[str, Any]:"
    },
    "api.performance_middleware.get_performance_summary": {
      "calls": [
        "DatabasePerformanceCollector.get_performance_summary",
        "app.get"
      ],
      "decorators": [
        "app.get"
      ],
      "docstring": "Get database performance summary",
      "file_path": "api/performance_middleware.py",
      "is_async": true,
      "is_endpoint": true,
      "line_end": 190,
      "line_start": 185,
      "module": "api.performance_middleware",
      "name": "get_performance_summary",
      "signature": "async def get_performance_summary(hours: int = 24, db: Session = None):"
    },
    "api.performance_middleware.get_slow_queries": {
      "calls": [
        "app.get",
        "len",
        "limit",
        "filter",
        "query.timestamp.isoformat",
        "order_by",
        "desc",
        "db.query",
        "all"
      ],
      "decorators": [
        "app.get"
      ],
      "docstring": "Get slow query analysis",
      "file_path": "api/performance_middleware.py",
      "is_async": true,
      "is_endpoint": true,
      "line_end": 215,
      "line_start": 193,
      "module": "api.performance_middleware",
      "name": "get_slow_queries",
      "signature": "async def get_slow_queries(limit: int = 50, min_duration_ms: float = 100.0, db: Session = None):"
    },
    "api.performance_middleware.setup_database_monitoring": {
      "calls": [
        "app.add_middleware",
        "app.get",
        "query.filter",
        "len",
        "json.loads",
        "limit",
        "filter",
        "timedelta",
        "query.timestamp.isoformat",
        "db.query",
        "DatabasePerformanceCollector.get_performance_summary",
        "datetime.utcnow",
        "all",
        "order_by",
        "query.order_by",
        "desc",
        "default_config.update",
        "metric.timestamp.isoformat"
      ],
      "decorators": [],
      "docstring": "Setup database performance monitoring for FastAPI app",
      "file_path": "api/performance_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 246,
      "line_start": 157,
      "module": "api.performance_middleware",
      "name": "setup_database_monitoring",
      "signature": "def setup_database_monitoring(app: FastAPI, config: Optional[Dict[str, Any]] = None):"
    },
    "api.query_optimizer.DatabasePerformanceCollector.get_performance_summary": {
      "calls": [
        "func.count",
        "float",
        "func.case",
        "func.avg",
        "group_by",
        "limit",
        "first",
        "timedelta",
        "filter",
        "db.query",
        "datetime.utcnow",
        "order_by",
        "all",
        "max",
        "label",
        "desc",
        "func.max"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Get performance summary for the last N hours",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 406,
      "line_start": 364,
      "module": "api.query_optimizer",
      "name": "DatabasePerformanceCollector.get_performance_summary",
      "signature": "def get_performance_summary(db: Session, hours: int = 24) -> Dict[str, Any]:"
    },
    "api.query_optimizer.DatabasePerformanceCollector.record_metric": {
      "calls": [
        "db.add",
        "print",
        "datetime.utcnow",
        "db.commit",
        "PerformanceMetric",
        "json.dumps"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Record a performance metric",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 361,
      "line_start": 340,
      "module": "api.query_optimizer",
      "name": "DatabasePerformanceCollector.record_metric",
      "signature": "def record_metric(db: Session, metric_type: str, metric_name: str, value: float, unit: Optional[str] = None, tags: Optional[Dict[str, str]] = None):"
    },
    "api.query_optimizer.OptimizedAuditLogQueries.get_security_events": {
      "calls": [
        "query.filter",
        "performance_tracked",
        "limit",
        "filter",
        "timedelta",
        "db.query",
        "datetime.utcnow",
        "query.order_by",
        "all",
        "desc"
      ],
      "decorators": [
        "staticmethod",
        "performance_tracked"
      ],
      "docstring": "Get recent security events efficiently",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 307,
      "line_start": 297,
      "module": "api.query_optimizer",
      "name": "OptimizedAuditLogQueries.get_security_events",
      "signature": "def get_security_events(db: Session, hours: int = 24, severity: Optional[str] = None, limit: int = 100) -> List[AuditLog]:"
    },
    "api.query_optimizer.OptimizedAuditLogQueries.get_user_activity_summary": {
      "calls": [
        "func.count",
        "performance_tracked",
        "filter",
        "first",
        "timedelta",
        "db.query",
        "datetime.utcnow",
        "func.max",
        "label",
        "and_",
        "func.distinct"
      ],
      "decorators": [
        "staticmethod",
        "performance_tracked"
      ],
      "docstring": "Get user activity summary efficiently",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 329,
      "line_start": 311,
      "module": "api.query_optimizer",
      "name": "OptimizedAuditLogQueries.get_user_activity_summary",
      "signature": "def get_user_activity_summary(db: Session, user_id: int, days: int = 7) -> Dict[str, Any]:"
    },
    "api.query_optimizer.OptimizedJobQueries.get_job_statistics": {
      "calls": [
        "func.count",
        "float",
        "stats.first",
        "func.case",
        "func.avg",
        "stats.filter",
        "func.sum",
        "performance_tracked",
        "filter",
        "timedelta",
        "db.query",
        "datetime.utcnow",
        "max",
        "label",
        "base_query.filter",
        "int"
      ],
      "decorators": [
        "staticmethod",
        "performance_tracked"
      ],
      "docstring": "Get job statistics efficiently with single query",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 199,
      "line_start": 162,
      "module": "api.query_optimizer",
      "name": "OptimizedJobQueries.get_job_statistics",
      "signature": "def get_job_statistics(db: Session, user_id: Optional[int] = None, days: int = 30) -> Dict[str, Any]:"
    },
    "api.query_optimizer.OptimizedJobQueries.get_job_with_user_and_metadata": {
      "calls": [
        "joinedload",
        "options",
        "performance_tracked",
        "filter",
        "first",
        "db.query"
      ],
      "decorators": [
        "staticmethod",
        "performance_tracked"
      ],
      "docstring": "Get single job with user and metadata in one query",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 139,
      "line_start": 134,
      "module": "api.query_optimizer",
      "name": "OptimizedJobQueries.get_job_with_user_and_metadata",
      "signature": "def get_job_with_user_and_metadata(db: Session, job_id: str) -> Optional[Job]:"
    },
    "api.query_optimizer.OptimizedJobQueries.get_jobs_by_user_paginated": {
      "calls": [
        "base_query.count",
        "base_query.order_by",
        "performance_tracked",
        "limit",
        "filter",
        "db.query",
        "offset",
        "desc",
        "all",
        "base_query.filter"
      ],
      "decorators": [
        "staticmethod",
        "performance_tracked"
      ],
      "docstring": "Get user's jobs with pagination and total count",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 158,
      "line_start": 143,
      "module": "api.query_optimizer",
      "name": "OptimizedJobQueries.get_jobs_by_user_paginated",
      "signature": "def get_jobs_by_user_paginated(db: Session, user_id: int, page: int = 1, page_size: int = 20, status: Optional[str] = None) -> Tuple[List[Job], int]:"
    },
    "api.query_optimizer.OptimizedJobQueries.get_jobs_with_metadata": {
      "calls": [
        "options",
        "query.filter",
        "performance_tracked",
        "limit",
        "desc",
        "db.query",
        "query.order_by",
        "all",
        "selectinload",
        "query.offset"
      ],
      "decorators": [
        "staticmethod",
        "performance_tracked"
      ],
      "docstring": "Get jobs with metadata in a single query using eager loading",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 130,
      "line_start": 112,
      "module": "api.query_optimizer",
      "name": "OptimizedJobQueries.get_jobs_with_metadata",
      "signature": "def get_jobs_with_metadata(db: Session, user_id: Optional[int] = None, status: Optional[str] = None, limit: int = 20, offset: int = 0) -> List[Job]:"
    },
    "api.query_optimizer.OptimizedJobQueries.get_recent_active_jobs": {
      "calls": [
        "performance_tracked",
        "limit",
        "filter",
        "Job.status.in_",
        "order_by",
        "desc",
        "db.query",
        "all"
      ],
      "decorators": [
        "staticmethod",
        "performance_tracked"
      ],
      "docstring": "Get recently active jobs efficiently",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 207,
      "line_start": 203,
      "module": "api.query_optimizer",
      "name": "OptimizedJobQueries.get_recent_active_jobs",
      "signature": "def get_recent_active_jobs(db: Session, limit: int = 10) -> List[Job]:"
    },
    "api.query_optimizer.OptimizedMetadataQueries.get_metadata_analytics": {
      "calls": [
        "join",
        "float",
        "func.count",
        "func.avg",
        "group_by",
        "performance_tracked",
        "first",
        "timedelta",
        "filter",
        "db.query",
        "datetime.utcnow",
        "all",
        "label"
      ],
      "decorators": [
        "staticmethod",
        "performance_tracked"
      ],
      "docstring": "Get metadata analytics efficiently",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 289,
      "line_start": 262,
      "module": "api.query_optimizer",
      "name": "OptimizedMetadataQueries.get_metadata_analytics",
      "signature": "def get_metadata_analytics(db: Session, days: int = 30) -> Dict[str, Any]:"
    },
    "api.query_optimizer.OptimizedUserQueries.get_active_users_with_stats": {
      "calls": [
        "func.count",
        "outerjoin",
        "func.case",
        "group_by",
        "func.sum",
        "func.coalesce",
        "performance_tracked",
        "limit",
        "filter",
        "db.query",
        "order_by",
        "desc",
        "all",
        "max",
        "label",
        "func.max",
        "subquery"
      ],
      "decorators": [
        "staticmethod",
        "performance_tracked"
      ],
      "docstring": "Get active users with their job statistics",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 246,
      "line_start": 215,
      "module": "api.query_optimizer",
      "name": "OptimizedUserQueries.get_active_users_with_stats",
      "signature": "def get_active_users_with_stats(db: Session, limit: int = 50) -> List[Dict[str, Any]]:"
    },
    "api.query_optimizer.OptimizedUserQueries.get_user_by_username_optimized": {
      "calls": [
        "performance_tracked",
        "filter",
        "first",
        "db.query",
        "and_"
      ],
      "decorators": [
        "staticmethod",
        "performance_tracked"
      ],
      "docstring": "Get user by username with optimized query",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 254,
      "line_start": 250,
      "module": "api.query_optimizer",
      "name": "OptimizedUserQueries.get_user_by_username_optimized",
      "signature": "def get_user_by_username_optimized(db: Session, username: str) -> Optional[User]:"
    },
    "api.query_optimizer.QueryPerformanceMonitor.__init__": {
      "calls": [],
      "decorators": [],
      "docstring": null,
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 30,
      "line_start": 28,
      "module": "api.query_optimizer",
      "name": "QueryPerformanceMonitor.__init__",
      "signature": "def __init__(self, slow_query_threshold_ms: float = 100.0):"
    },
    "api.query_optimizer.QueryPerformanceMonitor.log_slow_query": {
      "calls": [
        "db.add",
        "print",
        "datetime.utcnow",
        "QueryPerformanceLog",
        "db.commit"
      ],
      "decorators": [],
      "docstring": "Log slow queries for analysis",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 55,
      "line_start": 32,
      "module": "api.query_optimizer",
      "name": "QueryPerformanceMonitor.log_slow_query",
      "signature": "def log_slow_query(self, db: Session, query_type: str, execution_time_ms: float, query_text: str, table_name: Optional[str] = None, user_id: Optional[int] = None, endpoint: Optional[str] = None, row_count: Optional[int] = None):"
    },
    "api.query_optimizer.QueryPerformanceMonitor.monitor_query": {
      "calls": [
        "time.time",
        "self.log_slow_query"
      ],
      "decorators": [
        "contextmanager"
      ],
      "docstring": "Context manager to monitor query execution time",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 78,
      "line_start": 58,
      "module": "api.query_optimizer",
      "name": "QueryPerformanceMonitor.monitor_query",
      "signature": "def monitor_query(self, db: Session, query_type: str, table_name: Optional[str] = None, user_id: Optional[int] = None, endpoint: Optional[str] = None):"
    },
    "api.query_optimizer.__init__": {
      "calls": [],
      "decorators": [],
      "docstring": null,
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 30,
      "line_start": 28,
      "module": "api.query_optimizer",
      "name": "__init__",
      "signature": "def __init__(self, slow_query_threshold_ms: float = 100.0):"
    },
    "api.query_optimizer.decorator": {
      "calls": [
        "query_monitor.monitor_query",
        "kwargs.get",
        "func",
        "hasattr",
        "wraps"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 99,
      "line_start": 87,
      "module": "api.query_optimizer",
      "name": "decorator",
      "signature": "def decorator(func: Callable) -> Callable:"
    },
    "api.query_optimizer.get_active_users_with_stats": {
      "calls": [
        "func.count",
        "outerjoin",
        "func.case",
        "group_by",
        "func.sum",
        "func.coalesce",
        "performance_tracked",
        "limit",
        "filter",
        "db.query",
        "order_by",
        "desc",
        "all",
        "max",
        "label",
        "func.max",
        "subquery"
      ],
      "decorators": [
        "staticmethod",
        "performance_tracked"
      ],
      "docstring": "Get active users with their job statistics",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 246,
      "line_start": 215,
      "module": "api.query_optimizer",
      "name": "get_active_users_with_stats",
      "signature": "def get_active_users_with_stats(db: Session, limit: int = 50) -> List[Dict[str, Any]]:"
    },
    "api.query_optimizer.get_connection_pool_status": {
      "calls": [
        "pool.overflow",
        "pool.checkedin",
        "pool.size",
        "pool.checkedout",
        "pool.invalid"
      ],
      "decorators": [],
      "docstring": "Get connection pool status for monitoring",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 445,
      "line_start": 435,
      "module": "api.query_optimizer",
      "name": "get_connection_pool_status",
      "signature": "def get_connection_pool_status(engine: Engine) -> Dict[str, Any]:"
    },
    "api.query_optimizer.get_job_statistics": {
      "calls": [
        "func.count",
        "float",
        "stats.first",
        "func.case",
        "func.avg",
        "stats.filter",
        "func.sum",
        "performance_tracked",
        "filter",
        "timedelta",
        "db.query",
        "datetime.utcnow",
        "max",
        "label",
        "base_query.filter",
        "int"
      ],
      "decorators": [
        "staticmethod",
        "performance_tracked"
      ],
      "docstring": "Get job statistics efficiently with single query",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 199,
      "line_start": 162,
      "module": "api.query_optimizer",
      "name": "get_job_statistics",
      "signature": "def get_job_statistics(db: Session, user_id: Optional[int] = None, days: int = 30) -> Dict[str, Any]:"
    },
    "api.query_optimizer.get_job_with_user_and_metadata": {
      "calls": [
        "joinedload",
        "options",
        "performance_tracked",
        "filter",
        "first",
        "db.query"
      ],
      "decorators": [
        "staticmethod",
        "performance_tracked"
      ],
      "docstring": "Get single job with user and metadata in one query",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 139,
      "line_start": 134,
      "module": "api.query_optimizer",
      "name": "get_job_with_user_and_metadata",
      "signature": "def get_job_with_user_and_metadata(db: Session, job_id: str) -> Optional[Job]:"
    },
    "api.query_optimizer.get_jobs_by_user_paginated": {
      "calls": [
        "base_query.count",
        "base_query.order_by",
        "performance_tracked",
        "limit",
        "filter",
        "db.query",
        "offset",
        "desc",
        "all",
        "base_query.filter"
      ],
      "decorators": [
        "staticmethod",
        "performance_tracked"
      ],
      "docstring": "Get user's jobs with pagination and total count",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 158,
      "line_start": 143,
      "module": "api.query_optimizer",
      "name": "get_jobs_by_user_paginated",
      "signature": "def get_jobs_by_user_paginated(db: Session, user_id: int, page: int = 1, page_size: int = 20, status: Optional[str] = None) -> Tuple[List[Job], int]:"
    },
    "api.query_optimizer.get_jobs_with_metadata": {
      "calls": [
        "options",
        "query.filter",
        "performance_tracked",
        "limit",
        "desc",
        "db.query",
        "query.order_by",
        "all",
        "selectinload",
        "query.offset"
      ],
      "decorators": [
        "staticmethod",
        "performance_tracked"
      ],
      "docstring": "Get jobs with metadata in a single query using eager loading",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 130,
      "line_start": 112,
      "module": "api.query_optimizer",
      "name": "get_jobs_with_metadata",
      "signature": "def get_jobs_with_metadata(db: Session, user_id: Optional[int] = None, status: Optional[str] = None, limit: int = 20, offset: int = 0) -> List[Job]:"
    },
    "api.query_optimizer.get_metadata_analytics": {
      "calls": [
        "join",
        "float",
        "func.count",
        "func.avg",
        "group_by",
        "performance_tracked",
        "first",
        "timedelta",
        "filter",
        "db.query",
        "datetime.utcnow",
        "all",
        "label"
      ],
      "decorators": [
        "staticmethod",
        "performance_tracked"
      ],
      "docstring": "Get metadata analytics efficiently",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 289,
      "line_start": 262,
      "module": "api.query_optimizer",
      "name": "get_metadata_analytics",
      "signature": "def get_metadata_analytics(db: Session, days: int = 30) -> Dict[str, Any]:"
    },
    "api.query_optimizer.get_performance_summary": {
      "calls": [
        "func.count",
        "float",
        "func.case",
        "func.avg",
        "group_by",
        "limit",
        "first",
        "timedelta",
        "filter",
        "db.query",
        "datetime.utcnow",
        "order_by",
        "all",
        "max",
        "label",
        "desc",
        "func.max"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Get performance summary for the last N hours",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 406,
      "line_start": 364,
      "module": "api.query_optimizer",
      "name": "get_performance_summary",
      "signature": "def get_performance_summary(db: Session, hours: int = 24) -> Dict[str, Any]:"
    },
    "api.query_optimizer.get_recent_active_jobs": {
      "calls": [
        "performance_tracked",
        "limit",
        "filter",
        "Job.status.in_",
        "order_by",
        "desc",
        "db.query",
        "all"
      ],
      "decorators": [
        "staticmethod",
        "performance_tracked"
      ],
      "docstring": "Get recently active jobs efficiently",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 207,
      "line_start": 203,
      "module": "api.query_optimizer",
      "name": "get_recent_active_jobs",
      "signature": "def get_recent_active_jobs(db: Session, limit: int = 10) -> List[Job]:"
    },
    "api.query_optimizer.get_security_events": {
      "calls": [
        "query.filter",
        "performance_tracked",
        "limit",
        "filter",
        "timedelta",
        "db.query",
        "datetime.utcnow",
        "query.order_by",
        "all",
        "desc"
      ],
      "decorators": [
        "staticmethod",
        "performance_tracked"
      ],
      "docstring": "Get recent security events efficiently",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 307,
      "line_start": 297,
      "module": "api.query_optimizer",
      "name": "get_security_events",
      "signature": "def get_security_events(db: Session, hours: int = 24, severity: Optional[str] = None, limit: int = 100) -> List[AuditLog]:"
    },
    "api.query_optimizer.get_user_activity_summary": {
      "calls": [
        "func.count",
        "performance_tracked",
        "filter",
        "first",
        "timedelta",
        "db.query",
        "datetime.utcnow",
        "func.max",
        "label",
        "and_",
        "func.distinct"
      ],
      "decorators": [
        "staticmethod",
        "performance_tracked"
      ],
      "docstring": "Get user activity summary efficiently",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 329,
      "line_start": 311,
      "module": "api.query_optimizer",
      "name": "get_user_activity_summary",
      "signature": "def get_user_activity_summary(db: Session, user_id: int, days: int = 7) -> Dict[str, Any]:"
    },
    "api.query_optimizer.get_user_by_username_optimized": {
      "calls": [
        "performance_tracked",
        "filter",
        "first",
        "db.query",
        "and_"
      ],
      "decorators": [
        "staticmethod",
        "performance_tracked"
      ],
      "docstring": "Get user by username with optimized query",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 254,
      "line_start": 250,
      "module": "api.query_optimizer",
      "name": "get_user_by_username_optimized",
      "signature": "def get_user_by_username_optimized(db: Session, username: str) -> Optional[User]:"
    },
    "api.query_optimizer.log_slow_query": {
      "calls": [
        "db.add",
        "print",
        "datetime.utcnow",
        "QueryPerformanceLog",
        "db.commit"
      ],
      "decorators": [],
      "docstring": "Log slow queries for analysis",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 55,
      "line_start": 32,
      "module": "api.query_optimizer",
      "name": "log_slow_query",
      "signature": "def log_slow_query(self, db: Session, query_type: str, execution_time_ms: float, query_text: str, table_name: Optional[str] = None, user_id: Optional[int] = None, endpoint: Optional[str] = None, row_count: Optional[int] = None):"
    },
    "api.query_optimizer.monitor_query": {
      "calls": [
        "time.time",
        "self.log_slow_query"
      ],
      "decorators": [
        "contextmanager"
      ],
      "docstring": "Context manager to monitor query execution time",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 78,
      "line_start": 58,
      "module": "api.query_optimizer",
      "name": "monitor_query",
      "signature": "def monitor_query(self, db: Session, query_type: str, table_name: Optional[str] = None, user_id: Optional[int] = None, endpoint: Optional[str] = None):"
    },
    "api.query_optimizer.performance_tracked": {
      "calls": [
        "query_monitor.monitor_query",
        "kwargs.get",
        "func",
        "hasattr",
        "wraps"
      ],
      "decorators": [],
      "docstring": "Decorator to track query performance",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 100,
      "line_start": 85,
      "module": "api.query_optimizer",
      "name": "performance_tracked",
      "signature": "def performance_tracked(query_type: str, table_name: Optional[str] = None):"
    },
    "api.query_optimizer.receive_after_cursor_execute": {
      "calls": [
        "event.listens_for",
        "hasattr",
        "print",
        "time.time"
      ],
      "decorators": [
        "event.listens_for"
      ],
      "docstring": "Record query execution time",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 428,
      "line_start": 420,
      "module": "api.query_optimizer",
      "name": "receive_after_cursor_execute",
      "signature": "def receive_after_cursor_execute(conn, cursor, statement, parameters, context, executemany):"
    },
    "api.query_optimizer.receive_before_cursor_execute": {
      "calls": [
        "event.listens_for",
        "time.time"
      ],
      "decorators": [
        "event.listens_for"
      ],
      "docstring": "Record query start time",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 416,
      "line_start": 414,
      "module": "api.query_optimizer",
      "name": "receive_before_cursor_execute",
      "signature": "def receive_before_cursor_execute(conn, cursor, statement, parameters, context, executemany):"
    },
    "api.query_optimizer.record_metric": {
      "calls": [
        "db.add",
        "print",
        "datetime.utcnow",
        "db.commit",
        "PerformanceMetric",
        "json.dumps"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Record a performance metric",
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 361,
      "line_start": 340,
      "module": "api.query_optimizer",
      "name": "record_metric",
      "signature": "def record_metric(db: Session, metric_type: str, metric_name: str, value: float, unit: Optional[str] = None, tags: Optional[Dict[str, str]] = None):"
    },
    "api.query_optimizer.wrapper": {
      "calls": [
        "query_monitor.monitor_query",
        "kwargs.get",
        "func",
        "hasattr",
        "wraps"
      ],
      "decorators": [
        "wraps"
      ],
      "docstring": null,
      "file_path": "api/query_optimizer.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 98,
      "line_start": 89,
      "module": "api.query_optimizer",
      "name": "wrapper",
      "signature": "def wrapper(*args, **kwargs):"
    },
    "api.router_setup.register_routes": {
      "calls": [
        "backend_log.isEnabledFor",
        "Path",
        "backend_log.debug",
        "HTTPException",
        "hasattr",
        "app.get",
        "getattr",
        "StaticFiles",
        "type",
        "app.include_router",
        "backend_log.warning",
        "app.mount",
        "cache.set_cache_middleware",
        "full_path.startswith",
        "FileResponse",
        "backend_log.info"
      ],
      "decorators": [],
      "docstring": "Attach all API routers and static paths.",
      "file_path": "api/router_setup.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 91,
      "line_start": 22,
      "module": "api.router_setup",
      "name": "register_routes",
      "signature": "def register_routes(app: FastAPI) -> None:"
    },
    "api.router_setup.spa_fallback": {
      "calls": [
        "HTTPException",
        "FileResponse",
        "full_path.startswith",
        "app.get"
      ],
      "decorators": [
        "app.get"
      ],
      "docstring": null,
      "file_path": "api/router_setup.py",
      "is_async": false,
      "is_endpoint": true,
      "line_end": 84,
      "line_start": 66,
      "module": "api.router_setup",
      "name": "spa_fallback",
      "signature": "def spa_fallback(full_path: str):"
    },
    "api.router_setup.spa_index": {
      "calls": [
        "FileResponse",
        "app.get"
      ],
      "decorators": [
        "app.get"
      ],
      "docstring": null,
      "file_path": "api/router_setup.py",
      "is_async": false,
      "is_endpoint": true,
      "line_end": 63,
      "line_start": 62,
      "module": "api.router_setup",
      "name": "spa_index",
      "signature": "def spa_index():"
    },
    "app.backup.compression.CompressionEngine.__init__": {
      "calls": [
        "zstd.ZstdDecompressor",
        "min",
        "logger.info",
        "zstd.ZstdCompressor",
        "RuntimeError"
      ],
      "decorators": [],
      "docstring": "Initialize compression engine.\n\nArgs:\n    compression_level: Compression level (1-22 for ZSTD, 1-9 for gzip)\n    use_zstd: Prefer ZSTD over gzip if available",
      "file_path": "app/backup/compression.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 64,
      "line_start": 43,
      "module": "app.backup.compression",
      "name": "CompressionEngine.__init__",
      "signature": "def __init__(self, compression_level: int = 3, use_zstd: bool = True):"
    },
    "app.backup.compression.CompressionEngine._calculate_checksum": {
      "calls": [
        "hasher.update",
        "open",
        "iter",
        "f.read",
        "hashlib.sha256",
        "hasher.hexdigest"
      ],
      "decorators": [],
      "docstring": "Calculate SHA-256 checksum of a file.",
      "file_path": "app/backup/compression.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 263,
      "line_start": 257,
      "module": "app.backup.compression",
      "name": "CompressionEngine._calculate_checksum",
      "signature": "def _calculate_checksum(self, file_path: Path) -> str:"
    },
    "app.backup.compression.CompressionEngine._compress_gzip": {
      "calls": [
        "open",
        "gzip.open",
        "output_file.write",
        "input_file.read"
      ],
      "decorators": [],
      "docstring": "Compress file using gzip.",
      "file_path": "app/backup/compression.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 248,
      "line_start": 243,
      "module": "app.backup.compression",
      "name": "CompressionEngine._compress_gzip",
      "signature": "def _compress_gzip(self, input_path: Path, output_path: Path):"
    },
    "app.backup.compression.CompressionEngine._compress_zstd": {
      "calls": [
        "open",
        "self.compressor.copy_stream"
      ],
      "decorators": [],
      "docstring": "Compress file using ZSTD.",
      "file_path": "app/backup/compression.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 235,
      "line_start": 231,
      "module": "app.backup.compression",
      "name": "CompressionEngine._compress_zstd",
      "signature": "def _compress_zstd(self, input_path: Path, output_path: Path):"
    },
    "app.backup.compression.CompressionEngine._decompress_gzip": {
      "calls": [
        "open",
        "gzip.open",
        "output_file.write",
        "input_file.read"
      ],
      "decorators": [],
      "docstring": "Decompress gzip file.",
      "file_path": "app/backup/compression.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 255,
      "line_start": 250,
      "module": "app.backup.compression",
      "name": "CompressionEngine._decompress_gzip",
      "signature": "def _decompress_gzip(self, input_path: Path, output_path: Path):"
    },
    "app.backup.compression.CompressionEngine._decompress_zstd": {
      "calls": [
        "open",
        "self.decompressor.copy_stream"
      ],
      "decorators": [],
      "docstring": "Decompress ZSTD file.",
      "file_path": "app/backup/compression.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 241,
      "line_start": 237,
      "module": "app.backup.compression",
      "name": "CompressionEngine._decompress_zstd",
      "signature": "def _decompress_zstd(self, input_path: Path, output_path: Path):"
    },
    "app.backup.compression.CompressionEngine.compress_data": {
      "calls": [
        "logger.error",
        "self.compressor.compress",
        "gzip.compress"
      ],
      "decorators": [],
      "docstring": "Compress data in memory.\n\nArgs:\n    data: Raw data to compress\n    \nReturns:\n    Compressed data",
      "file_path": "app/backup/compression.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 210,
      "line_start": 193,
      "module": "app.backup.compression",
      "name": "CompressionEngine.compress_data",
      "signature": "def compress_data(self, data: bytes) -> bytes:"
    },
    "app.backup.compression.CompressionEngine.compress_file": {
      "calls": [
        "input_path.with_suffix",
        "Path",
        "output_path.stat",
        "self._compress_gzip",
        "logger.info",
        "str",
        "FileNotFoundError",
        "logger.error",
        "input_path.exists",
        "logger.debug",
        "self._calculate_checksum",
        "input_path.stat",
        "self._compress_zstd"
      ],
      "decorators": [],
      "docstring": "Compress a file and return compression statistics.\n\nArgs:\n    input_path: Path to input file\n    output_path: Path to output file (auto-generated if None)\n    \nReturns:\n    Dict with compression statistics",
      "file_path": "app/backup/compression.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 130,
      "line_start": 66,
      "module": "app.backup.compression",
      "name": "CompressionEngine.compress_file",
      "signature": "def compress_file(self, input_path: Path, output_path: Optional[Path] = None) -> Dict:"
    },
    "app.backup.compression.CompressionEngine.decompress_data": {
      "calls": [
        "gzip.decompress",
        "logger.error",
        "self.decompressor.decompress"
      ],
      "decorators": [],
      "docstring": "Decompress data in memory.\n\nArgs:\n    compressed_data: Compressed data\n    \nReturns:\n    Decompressed data",
      "file_path": "app/backup/compression.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 229,
      "line_start": 212,
      "module": "app.backup.compression",
      "name": "CompressionEngine.decompress_data",
      "signature": "def decompress_data(self, compressed_data: bytes) -> bytes:"
    },
    "app.backup.compression.CompressionEngine.decompress_file": {
      "calls": [
        "input_path.with_suffix",
        "Path",
        "self._decompress_zstd",
        "output_path.stat",
        "logger.info",
        "str",
        "FileNotFoundError",
        "self._decompress_gzip",
        "logger.error",
        "input_path.exists",
        "ValueError",
        "logger.debug",
        "self._calculate_checksum",
        "input_path.stat"
      ],
      "decorators": [],
      "docstring": "Decompress a file and return decompression statistics.\n\nArgs:\n    input_path: Path to compressed file\n    output_path: Path to output file (auto-generated if None)\n    \nReturns:\n    Dict with decompression statistics",
      "file_path": "app/backup/compression.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 191,
      "line_start": 132,
      "module": "app.backup.compression",
      "name": "CompressionEngine.decompress_file",
      "signature": "def decompress_file(self, input_path: Path, output_path: Optional[Path] = None) -> Dict:"
    },
    "app.backup.compression.CompressionEngine.get_compression_info": {
      "calls": [],
      "decorators": [],
      "docstring": "Get compression engine information.\n\nReturns:\n    Dict with compression engine details",
      "file_path": "app/backup/compression.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 278,
      "line_start": 265,
      "module": "app.backup.compression",
      "name": "CompressionEngine.get_compression_info",
      "signature": "def get_compression_info(self) -> Dict:"
    },
    "app.backup.compression.__init__": {
      "calls": [
        "zstd.ZstdDecompressor",
        "min",
        "logger.info",
        "zstd.ZstdCompressor",
        "RuntimeError"
      ],
      "decorators": [],
      "docstring": "Initialize compression engine.\n\nArgs:\n    compression_level: Compression level (1-22 for ZSTD, 1-9 for gzip)\n    use_zstd: Prefer ZSTD over gzip if available",
      "file_path": "app/backup/compression.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 64,
      "line_start": 43,
      "module": "app.backup.compression",
      "name": "__init__",
      "signature": "def __init__(self, compression_level: int = 3, use_zstd: bool = True):"
    },
    "app.backup.compression._calculate_checksum": {
      "calls": [
        "hasher.update",
        "open",
        "iter",
        "f.read",
        "hashlib.sha256",
        "hasher.hexdigest"
      ],
      "decorators": [],
      "docstring": "Calculate SHA-256 checksum of a file.",
      "file_path": "app/backup/compression.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 263,
      "line_start": 257,
      "module": "app.backup.compression",
      "name": "_calculate_checksum",
      "signature": "def _calculate_checksum(self, file_path: Path) -> str:"
    },
    "app.backup.compression._compress_gzip": {
      "calls": [
        "open",
        "gzip.open",
        "output_file.write",
        "input_file.read"
      ],
      "decorators": [],
      "docstring": "Compress file using gzip.",
      "file_path": "app/backup/compression.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 248,
      "line_start": 243,
      "module": "app.backup.compression",
      "name": "_compress_gzip",
      "signature": "def _compress_gzip(self, input_path: Path, output_path: Path):"
    },
    "app.backup.compression._compress_zstd": {
      "calls": [
        "open",
        "self.compressor.copy_stream"
      ],
      "decorators": [],
      "docstring": "Compress file using ZSTD.",
      "file_path": "app/backup/compression.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 235,
      "line_start": 231,
      "module": "app.backup.compression",
      "name": "_compress_zstd",
      "signature": "def _compress_zstd(self, input_path: Path, output_path: Path):"
    },
    "app.backup.compression._decompress_gzip": {
      "calls": [
        "open",
        "gzip.open",
        "output_file.write",
        "input_file.read"
      ],
      "decorators": [],
      "docstring": "Decompress gzip file.",
      "file_path": "app/backup/compression.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 255,
      "line_start": 250,
      "module": "app.backup.compression",
      "name": "_decompress_gzip",
      "signature": "def _decompress_gzip(self, input_path: Path, output_path: Path):"
    },
    "app.backup.compression._decompress_zstd": {
      "calls": [
        "open",
        "self.decompressor.copy_stream"
      ],
      "decorators": [],
      "docstring": "Decompress ZSTD file.",
      "file_path": "app/backup/compression.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 241,
      "line_start": 237,
      "module": "app.backup.compression",
      "name": "_decompress_zstd",
      "signature": "def _decompress_zstd(self, input_path: Path, output_path: Path):"
    },
    "app.backup.compression.compress_data": {
      "calls": [
        "logger.error",
        "self.compressor.compress",
        "gzip.compress"
      ],
      "decorators": [],
      "docstring": "Compress data in memory.\n\nArgs:\n    data: Raw data to compress\n    \nReturns:\n    Compressed data",
      "file_path": "app/backup/compression.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 210,
      "line_start": 193,
      "module": "app.backup.compression",
      "name": "compress_data",
      "signature": "def compress_data(self, data: bytes) -> bytes:"
    },
    "app.backup.compression.compress_file": {
      "calls": [
        "input_path.with_suffix",
        "Path",
        "output_path.stat",
        "self._compress_gzip",
        "logger.info",
        "str",
        "FileNotFoundError",
        "logger.error",
        "input_path.exists",
        "logger.debug",
        "self._calculate_checksum",
        "input_path.stat",
        "self._compress_zstd"
      ],
      "decorators": [],
      "docstring": "Compress a file and return compression statistics.\n\nArgs:\n    input_path: Path to input file\n    output_path: Path to output file (auto-generated if None)\n    \nReturns:\n    Dict with compression statistics",
      "file_path": "app/backup/compression.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 130,
      "line_start": 66,
      "module": "app.backup.compression",
      "name": "compress_file",
      "signature": "def compress_file(self, input_path: Path, output_path: Optional[Path] = None) -> Dict:"
    },
    "app.backup.compression.decompress_data": {
      "calls": [
        "gzip.decompress",
        "logger.error",
        "self.decompressor.decompress"
      ],
      "decorators": [],
      "docstring": "Decompress data in memory.\n\nArgs:\n    compressed_data: Compressed data\n    \nReturns:\n    Decompressed data",
      "file_path": "app/backup/compression.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 229,
      "line_start": 212,
      "module": "app.backup.compression",
      "name": "decompress_data",
      "signature": "def decompress_data(self, compressed_data: bytes) -> bytes:"
    },
    "app.backup.compression.decompress_file": {
      "calls": [
        "input_path.with_suffix",
        "Path",
        "self._decompress_zstd",
        "output_path.stat",
        "logger.info",
        "str",
        "FileNotFoundError",
        "self._decompress_gzip",
        "logger.error",
        "input_path.exists",
        "ValueError",
        "logger.debug",
        "self._calculate_checksum",
        "input_path.stat"
      ],
      "decorators": [],
      "docstring": "Decompress a file and return decompression statistics.\n\nArgs:\n    input_path: Path to compressed file\n    output_path: Path to output file (auto-generated if None)\n    \nReturns:\n    Dict with decompression statistics",
      "file_path": "app/backup/compression.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 191,
      "line_start": 132,
      "module": "app.backup.compression",
      "name": "decompress_file",
      "signature": "def decompress_file(self, input_path: Path, output_path: Optional[Path] = None) -> Dict:"
    },
    "app.backup.compression.get_compression_info": {
      "calls": [],
      "decorators": [],
      "docstring": "Get compression engine information.\n\nReturns:\n    Dict with compression engine details",
      "file_path": "app/backup/compression.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 278,
      "line_start": 265,
      "module": "app.backup.compression",
      "name": "get_compression_info",
      "signature": "def get_compression_info(self) -> Dict:"
    },
    "app.backup.config.get_backup_config": {
      "calls": [
        "lower",
        "append",
        "all",
        "DEFAULT_BACKUP_CONFIG.copy",
        "int",
        "os.getenv"
      ],
      "decorators": [],
      "docstring": "Get backup configuration with environment variable overrides.\n\nReturns:\n    Dict: Complete backup configuration",
      "file_path": "app/backup/config.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 175,
      "line_start": 118,
      "module": "app.backup.config",
      "name": "get_backup_config",
      "signature": "def get_backup_config():"
    },
    "app.backup.config.validate_backup_config": {
      "calls": [
        "Path",
        "backend.get",
        "get",
        "len",
        "exists",
        "enumerate",
        "config.get",
        "errors.append"
      ],
      "decorators": [],
      "docstring": "Validate backup configuration.\n\nArgs:\n    config: Backup configuration dict\n    \nReturns:\n    Tuple[bool, List[str]]: (is_valid, error_messages)",
      "file_path": "app/backup/config.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 231,
      "line_start": 177,
      "module": "app.backup.config",
      "name": "validate_backup_config",
      "signature": "def validate_backup_config(config):"
    },
    "app.backup.database.DatabaseBackupEngine.__init__": {
      "calls": [
        "self.snapshot_dir.mkdir",
        "Path",
        "self.backup_dir.mkdir",
        "self.load_metadata",
        "self.wal_backup_dir.mkdir"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "app/backup/database.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 48,
      "line_start": 34,
      "module": "app.backup.database",
      "name": "DatabaseBackupEngine.__init__",
      "signature": "def __init__(self, database_path: str, backup_base_dir: str):"
    },
    "app.backup.database.DatabaseBackupEngine._calculate_file_checksum": {
      "calls": [
        "hasher.update",
        "open",
        "iter",
        "f.read",
        "hashlib.sha256",
        "hasher.hexdigest"
      ],
      "decorators": [],
      "docstring": "Calculate SHA-256 checksum of a file.",
      "file_path": "app/backup/database.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 381,
      "line_start": 375,
      "module": "app.backup.database",
      "name": "DatabaseBackupEngine._calculate_file_checksum",
      "signature": "def _calculate_file_checksum(self, file_path: Path) -> str:"
    },
    "app.backup.database.DatabaseBackupEngine._get_database_stats": {
      "calls": [
        "logger.error",
        "fetchone",
        "conn.execute"
      ],
      "decorators": [],
      "docstring": "Get database statistics for backup metadata.",
      "file_path": "app/backup/database.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 414,
      "line_start": 383,
      "module": "app.backup.database",
      "name": "DatabaseBackupEngine._get_database_stats",
      "signature": "def _get_database_stats(self, conn: sqlite3.Connection) -> Dict:"
    },
    "app.backup.database.DatabaseBackupEngine._is_wal_mode_enabled": {
      "calls": [
        "sqlite3.connect",
        "conn.execute",
        "upper",
        "str",
        "fetchone"
      ],
      "decorators": [],
      "docstring": "Check if WAL mode is enabled on the database.",
      "file_path": "app/backup/database.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 423,
      "line_start": 416,
      "module": "app.backup.database",
      "name": "DatabaseBackupEngine._is_wal_mode_enabled",
      "signature": "def _is_wal_mode_enabled(self) -> bool:"
    },
    "app.backup.database.DatabaseBackupEngine.backup_wal_files": {
      "calls": [
        "self._calculate_file_checksum",
        "wal_backup.stat",
        "self.save_metadata",
        "len",
        "datetime.utcnow",
        "timestamp.isoformat",
        "shm_backup.stat",
        "shm_file.exists",
        "wal_file.exists",
        "timedelta",
        "timestamp.strftime",
        "backed_up_files.append",
        "shutil.copy2",
        "str",
        "logger.error",
        "logger.debug",
        "self.database_path.with_suffix",
        "isoformat",
        "wal_backup_subdir.mkdir"
      ],
      "decorators": [],
      "docstring": "Backup WAL and SHM files for point-in-time recovery.\n\nReturns:\n    Dict with backup metadata or None if failed",
      "file_path": "app/backup/database.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 240,
      "line_start": 177,
      "module": "app.backup.database",
      "name": "DatabaseBackupEngine.backup_wal_files",
      "signature": "def backup_wal_files(self) -> Optional[Dict]:"
    },
    "app.backup.database.DatabaseBackupEngine.cleanup_expired_backups": {
      "calls": [
        "self.save_metadata",
        "Path",
        "backup_path.exists",
        "any",
        "len",
        "logger.info",
        "expired_backups.append",
        "remove",
        "wal_dir.iterdir",
        "logger.error",
        "datetime.utcnow",
        "wal_dir.rmdir",
        "datetime.fromisoformat",
        "backup_path.unlink",
        "wal_dir.exists"
      ],
      "decorators": [],
      "docstring": "Remove expired backups based on retention policies.",
      "file_path": "app/backup/database.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 327,
      "line_start": 287,
      "module": "app.backup.database",
      "name": "DatabaseBackupEngine.cleanup_expired_backups",
      "signature": "def cleanup_expired_backups(self):"
    },
    "app.backup.database.DatabaseBackupEngine.create_full_backup": {
      "calls": [
        "sqlite3.connect",
        "self._calculate_file_checksum",
        "backup_path.with_suffix",
        "backup_conn.close",
        "backup_path.stat",
        "self.save_metadata",
        "source_conn.backup",
        "datetime.utcnow",
        "timestamp.isoformat",
        "source_conn.close",
        "encryption_engine.encrypt_file",
        "compression_engine.compress_file",
        "logger.info",
        "timedelta",
        "self._get_database_stats",
        "timestamp.strftime",
        "backup_path.unlink",
        "str",
        "append",
        "logger.error",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Create a full database backup using SQLite's backup API.\n\nArgs:\n    compression_engine: Optional compression engine\n    encryption_engine: Optional encryption engine\n    \nReturns:\n    Dict with backup metadata or None if failed",
      "file_path": "app/backup/database.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 175,
      "line_start": 99,
      "module": "app.backup.database",
      "name": "DatabaseBackupEngine.create_full_backup",
      "signature": "def create_full_backup(self, compression_engine=None, encryption_engine=None) -> Optional[Dict]:"
    },
    "app.backup.database.DatabaseBackupEngine.enable_wal_mode": {
      "calls": [
        "sqlite3.connect",
        "conn.execute",
        "upper",
        "logger.info",
        "str",
        "fetchone",
        "logger.error"
      ],
      "decorators": [],
      "docstring": "Enable WAL mode on the database for zero-downtime backups.\n\nReturns:\n    bool: True if WAL mode was enabled successfully",
      "file_path": "app/backup/database.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 97,
      "line_start": 68,
      "module": "app.backup.database",
      "name": "DatabaseBackupEngine.enable_wal_mode",
      "signature": "def enable_wal_mode(self) -> bool:"
    },
    "app.backup.database.DatabaseBackupEngine.get_backup_status": {
      "calls": [
        "self._is_wal_mode_enabled",
        "Path",
        "backup_path.exists",
        "len",
        "self.database_path.exists",
        "str",
        "logger.error",
        "self.metadata.get",
        "backup_path.stat"
      ],
      "decorators": [],
      "docstring": "Get current backup status and statistics.\n\nReturns:\n    Dict with backup status information",
      "file_path": "app/backup/database.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 373,
      "line_start": 329,
      "module": "app.backup.database",
      "name": "DatabaseBackupEngine.get_backup_status",
      "signature": "def get_backup_status(self) -> Dict:"
    },
    "app.backup.database.DatabaseBackupEngine.load_metadata": {
      "calls": [
        "open",
        "json.load",
        "self.metadata_file.exists"
      ],
      "decorators": [],
      "docstring": "Load backup metadata from disk.",
      "file_path": "app/backup/database.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 61,
      "line_start": 50,
      "module": "app.backup.database",
      "name": "DatabaseBackupEngine.load_metadata",
      "signature": "def load_metadata(self):"
    },
    "app.backup.database.DatabaseBackupEngine.save_metadata": {
      "calls": [
        "open",
        "json.dump"
      ],
      "decorators": [],
      "docstring": "Save backup metadata to disk.",
      "file_path": "app/backup/database.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 66,
      "line_start": 63,
      "module": "app.backup.database",
      "name": "DatabaseBackupEngine.save_metadata",
      "signature": "def save_metadata(self):"
    },
    "app.backup.database.DatabaseBackupEngine.validate_backup": {
      "calls": [
        "Path",
        "backup_path.exists",
        "self._calculate_file_checksum",
        "logger.error",
        "logger.debug"
      ],
      "decorators": [],
      "docstring": "Validate backup integrity using checksums.\n\nArgs:\n    backup_metadata: Backup metadata dict\n    \nReturns:\n    bool: True if backup is valid",
      "file_path": "app/backup/database.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 285,
      "line_start": 242,
      "module": "app.backup.database",
      "name": "DatabaseBackupEngine.validate_backup",
      "signature": "def validate_backup(self, backup_metadata: Dict) -> bool:"
    },
    "app.backup.database.__init__": {
      "calls": [
        "self.snapshot_dir.mkdir",
        "Path",
        "self.backup_dir.mkdir",
        "self.load_metadata",
        "self.wal_backup_dir.mkdir"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "app/backup/database.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 48,
      "line_start": 34,
      "module": "app.backup.database",
      "name": "__init__",
      "signature": "def __init__(self, database_path: str, backup_base_dir: str):"
    },
    "app.backup.database._calculate_file_checksum": {
      "calls": [
        "hasher.update",
        "open",
        "iter",
        "f.read",
        "hashlib.sha256",
        "hasher.hexdigest"
      ],
      "decorators": [],
      "docstring": "Calculate SHA-256 checksum of a file.",
      "file_path": "app/backup/database.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 381,
      "line_start": 375,
      "module": "app.backup.database",
      "name": "_calculate_file_checksum",
      "signature": "def _calculate_file_checksum(self, file_path: Path) -> str:"
    },
    "app.backup.database._get_database_stats": {
      "calls": [
        "logger.error",
        "fetchone",
        "conn.execute"
      ],
      "decorators": [],
      "docstring": "Get database statistics for backup metadata.",
      "file_path": "app/backup/database.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 414,
      "line_start": 383,
      "module": "app.backup.database",
      "name": "_get_database_stats",
      "signature": "def _get_database_stats(self, conn: sqlite3.Connection) -> Dict:"
    },
    "app.backup.database._is_wal_mode_enabled": {
      "calls": [
        "sqlite3.connect",
        "conn.execute",
        "upper",
        "str",
        "fetchone"
      ],
      "decorators": [],
      "docstring": "Check if WAL mode is enabled on the database.",
      "file_path": "app/backup/database.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 423,
      "line_start": 416,
      "module": "app.backup.database",
      "name": "_is_wal_mode_enabled",
      "signature": "def _is_wal_mode_enabled(self) -> bool:"
    },
    "app.backup.database.backup_wal_files": {
      "calls": [
        "self._calculate_file_checksum",
        "wal_backup.stat",
        "self.save_metadata",
        "len",
        "datetime.utcnow",
        "timestamp.isoformat",
        "shm_backup.stat",
        "shm_file.exists",
        "wal_file.exists",
        "timedelta",
        "timestamp.strftime",
        "backed_up_files.append",
        "shutil.copy2",
        "str",
        "logger.error",
        "logger.debug",
        "self.database_path.with_suffix",
        "isoformat",
        "wal_backup_subdir.mkdir"
      ],
      "decorators": [],
      "docstring": "Backup WAL and SHM files for point-in-time recovery.\n\nReturns:\n    Dict with backup metadata or None if failed",
      "file_path": "app/backup/database.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 240,
      "line_start": 177,
      "module": "app.backup.database",
      "name": "backup_wal_files",
      "signature": "def backup_wal_files(self) -> Optional[Dict]:"
    },
    "app.backup.database.cleanup_expired_backups": {
      "calls": [
        "self.save_metadata",
        "Path",
        "backup_path.exists",
        "any",
        "len",
        "logger.info",
        "expired_backups.append",
        "remove",
        "wal_dir.iterdir",
        "logger.error",
        "datetime.utcnow",
        "wal_dir.rmdir",
        "datetime.fromisoformat",
        "backup_path.unlink",
        "wal_dir.exists"
      ],
      "decorators": [],
      "docstring": "Remove expired backups based on retention policies.",
      "file_path": "app/backup/database.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 327,
      "line_start": 287,
      "module": "app.backup.database",
      "name": "cleanup_expired_backups",
      "signature": "def cleanup_expired_backups(self):"
    },
    "app.backup.database.create_full_backup": {
      "calls": [
        "sqlite3.connect",
        "self._calculate_file_checksum",
        "backup_path.with_suffix",
        "backup_conn.close",
        "backup_path.stat",
        "self.save_metadata",
        "source_conn.backup",
        "datetime.utcnow",
        "timestamp.isoformat",
        "source_conn.close",
        "encryption_engine.encrypt_file",
        "compression_engine.compress_file",
        "logger.info",
        "timedelta",
        "self._get_database_stats",
        "timestamp.strftime",
        "backup_path.unlink",
        "str",
        "append",
        "logger.error",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Create a full database backup using SQLite's backup API.\n\nArgs:\n    compression_engine: Optional compression engine\n    encryption_engine: Optional encryption engine\n    \nReturns:\n    Dict with backup metadata or None if failed",
      "file_path": "app/backup/database.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 175,
      "line_start": 99,
      "module": "app.backup.database",
      "name": "create_full_backup",
      "signature": "def create_full_backup(self, compression_engine=None, encryption_engine=None) -> Optional[Dict]:"
    },
    "app.backup.database.enable_wal_mode": {
      "calls": [
        "sqlite3.connect",
        "conn.execute",
        "upper",
        "logger.info",
        "str",
        "fetchone",
        "logger.error"
      ],
      "decorators": [],
      "docstring": "Enable WAL mode on the database for zero-downtime backups.\n\nReturns:\n    bool: True if WAL mode was enabled successfully",
      "file_path": "app/backup/database.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 97,
      "line_start": 68,
      "module": "app.backup.database",
      "name": "enable_wal_mode",
      "signature": "def enable_wal_mode(self) -> bool:"
    },
    "app.backup.database.get_backup_status": {
      "calls": [
        "self._is_wal_mode_enabled",
        "Path",
        "backup_path.exists",
        "len",
        "self.database_path.exists",
        "str",
        "logger.error",
        "self.metadata.get",
        "backup_path.stat"
      ],
      "decorators": [],
      "docstring": "Get current backup status and statistics.\n\nReturns:\n    Dict with backup status information",
      "file_path": "app/backup/database.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 373,
      "line_start": 329,
      "module": "app.backup.database",
      "name": "get_backup_status",
      "signature": "def get_backup_status(self) -> Dict:"
    },
    "app.backup.database.load_metadata": {
      "calls": [
        "open",
        "json.load",
        "self.metadata_file.exists"
      ],
      "decorators": [],
      "docstring": "Load backup metadata from disk.",
      "file_path": "app/backup/database.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 61,
      "line_start": 50,
      "module": "app.backup.database",
      "name": "load_metadata",
      "signature": "def load_metadata(self):"
    },
    "app.backup.database.save_metadata": {
      "calls": [
        "open",
        "json.dump"
      ],
      "decorators": [],
      "docstring": "Save backup metadata to disk.",
      "file_path": "app/backup/database.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 66,
      "line_start": 63,
      "module": "app.backup.database",
      "name": "save_metadata",
      "signature": "def save_metadata(self):"
    },
    "app.backup.database.validate_backup": {
      "calls": [
        "Path",
        "backup_path.exists",
        "self._calculate_file_checksum",
        "logger.error",
        "logger.debug"
      ],
      "decorators": [],
      "docstring": "Validate backup integrity using checksums.\n\nArgs:\n    backup_metadata: Backup metadata dict\n    \nReturns:\n    bool: True if backup is valid",
      "file_path": "app/backup/database.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 285,
      "line_start": 242,
      "module": "app.backup.database",
      "name": "validate_backup",
      "signature": "def validate_backup(self, backup_metadata: Dict) -> bool:"
    },
    "app.backup.files.FileBackupEngine.__del__": {
      "calls": [
        "hasattr",
        "self.stop_monitoring"
      ],
      "decorators": [],
      "docstring": "Cleanup when object is destroyed.",
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 474,
      "line_start": 471,
      "module": "app.backup.files",
      "name": "FileBackupEngine.__del__",
      "signature": "def __del__(self):"
    },
    "app.backup.files.FileBackupEngine.__init__": {
      "calls": [
        "Path",
        "set",
        "self.backup_dir.mkdir",
        "mkdir",
        "self.load_indexes",
        "threading.Lock",
        "self.start_monitoring"
      ],
      "decorators": [],
      "docstring": "Initialize file backup engine.\n\nArgs:\n    watch_directories: List of directories to monitor\n    backup_base_dir: Base directory for backups\n    enable_realtime: Enable real-time file monitoring",
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 106,
      "line_start": 66,
      "module": "app.backup.files",
      "name": "FileBackupEngine.__init__",
      "signature": "def __init__(self, watch_directories: List[str], backup_base_dir: str, enable_realtime: bool = True):"
    },
    "app.backup.files.FileBackupEngine._calculate_file_hash": {
      "calls": [
        "hasher.update",
        "open",
        "iter",
        "f.read",
        "hashlib.sha256",
        "hasher.hexdigest"
      ],
      "decorators": [],
      "docstring": "Calculate SHA-256 hash of file content.",
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 454,
      "line_start": 448,
      "module": "app.backup.files",
      "name": "FileBackupEngine._calculate_file_hash",
      "signature": "def _calculate_file_hash(self, file_path: Path) -> str:"
    },
    "app.backup.files.FileBackupEngine._get_relative_backup_path": {
      "calls": [
        "file_path.resolve",
        "Path",
        "file_path.relative_to",
        "watch_dir.resolve"
      ],
      "decorators": [],
      "docstring": "Get relative backup path for a file.",
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 469,
      "line_start": 456,
      "module": "app.backup.files",
      "name": "FileBackupEngine._get_relative_backup_path",
      "signature": "def _get_relative_backup_path(self, file_path: Path) -> Path:"
    },
    "app.backup.files.FileBackupEngine.backup_directory": {
      "calls": [
        "Path",
        "logger.warning",
        "len",
        "logger.info",
        "directory.exists",
        "backups_completed.append",
        "self.backup_file",
        "os.walk"
      ],
      "decorators": [],
      "docstring": "Backup all files in a directory recursively.\n\nArgs:\n    directory: Directory to backup\n    compression_engine: Optional compression engine\n    \nReturns:\n    List of backup metadata for all files",
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 362,
      "line_start": 332,
      "module": "app.backup.files",
      "name": "FileBackupEngine.backup_directory",
      "signature": "def backup_directory(self, directory: Path, compression_engine=None) -> List[Dict]:"
    },
    "app.backup.files.FileBackupEngine.backup_file": {
      "calls": [
        "backup_metadata.get",
        "backup_path.with_suffix",
        "backup_path.stat",
        "traceback.format_exc",
        "datetime.utcnow",
        "timestamp.isoformat",
        "self._calculate_file_hash",
        "compression_engine.compress_file",
        "logger.info",
        "timedelta",
        "file_path.resolve",
        "self._get_relative_backup_path",
        "timestamp.strftime",
        "file_mtime.isoformat",
        "backup_path.unlink",
        "datetime.fromtimestamp",
        "self.should_backup_file",
        "file_path.stat",
        "shutil.copy2",
        "backup_subdir.mkdir",
        "self.save_indexes",
        "str",
        "logger.error",
        "last_backup.get",
        "datetime.fromisoformat",
        "logger.debug",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Backup a single file with deduplication.\n\nArgs:\n    file_path: Path to the file to backup\n    compression_engine: Optional compression engine\n    \nReturns:\n    Dict with backup metadata or None if skipped",
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 305,
      "line_start": 202,
      "module": "app.backup.files",
      "name": "FileBackupEngine.backup_file",
      "signature": "def backup_file(self, file_path: Path, compression_engine=None) -> Optional[Dict]:"
    },
    "app.backup.files.FileBackupEngine.cleanup_expired_backups": {
      "calls": [
        "Path",
        "backup_path.exists",
        "self.save_indexes",
        "len",
        "logger.info",
        "self.file_index.items",
        "expired_files.append",
        "hash_info.get",
        "logger.error",
        "datetime.utcnow",
        "datetime.fromisoformat",
        "backup_path.unlink"
      ],
      "decorators": [],
      "docstring": "Remove expired file backups based on retention policies.",
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 402,
      "line_start": 364,
      "module": "app.backup.files",
      "name": "FileBackupEngine.cleanup_expired_backups",
      "signature": "def cleanup_expired_backups(self):"
    },
    "app.backup.files.FileBackupEngine.get_backup_status": {
      "calls": [
        "self.file_index.values",
        "len",
        "str",
        "logger.error",
        "backup_info.get"
      ],
      "decorators": [],
      "docstring": "Get file backup status and statistics.\n\nReturns:\n    Dict with backup status information",
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 446,
      "line_start": 404,
      "module": "app.backup.files",
      "name": "FileBackupEngine.get_backup_status",
      "signature": "def get_backup_status(self) -> Dict:"
    },
    "app.backup.files.FileBackupEngine.load_indexes": {
      "calls": [
        "open",
        "self.content_hash_index_file.exists",
        "self.file_index_file.exists",
        "json.load"
      ],
      "decorators": [],
      "docstring": "Load file indexes from disk.",
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 122,
      "line_start": 108,
      "module": "app.backup.files",
      "name": "FileBackupEngine.load_indexes",
      "signature": "def load_indexes(self):"
    },
    "app.backup.files.FileBackupEngine.process_backup_queue": {
      "calls": [
        "self.backup_queue.clear",
        "len",
        "logger.info",
        "list",
        "backups_completed.append",
        "self.backup_file"
      ],
      "decorators": [],
      "docstring": "Process all files in the backup queue.\n\nArgs:\n    compression_engine: Optional compression engine\n    \nReturns:\n    List of backup metadata for processed files",
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 330,
      "line_start": 307,
      "module": "app.backup.files",
      "name": "FileBackupEngine.process_backup_queue",
      "signature": "def process_backup_queue(self, compression_engine=None) -> List[Dict]:"
    },
    "app.backup.files.FileBackupEngine.queue_file_for_backup": {
      "calls": [
        "self.should_backup_file",
        "self.backup_queue.add"
      ],
      "decorators": [],
      "docstring": "Add a file to the backup queue.",
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 167,
      "line_start": 163,
      "module": "app.backup.files",
      "name": "FileBackupEngine.queue_file_for_backup",
      "signature": "def queue_file_for_backup(self, file_path: Path):"
    },
    "app.backup.files.FileBackupEngine.save_indexes": {
      "calls": [
        "open",
        "json.dump"
      ],
      "decorators": [],
      "docstring": "Save file indexes to disk.",
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 130,
      "line_start": 124,
      "module": "app.backup.files",
      "name": "FileBackupEngine.save_indexes",
      "signature": "def save_indexes(self):"
    },
    "app.backup.files.FileBackupEngine.should_backup_file": {
      "calls": [
        "file_path.relative_to",
        "file_path.exists",
        "str",
        "file_path.suffix.lower",
        "file_path.is_file"
      ],
      "decorators": [],
      "docstring": "Determine if a file should be backed up.\n\nArgs:\n    file_path: Path to the file\n    \nReturns:\n    bool: True if file should be backed up",
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 200,
      "line_start": 169,
      "module": "app.backup.files",
      "name": "FileBackupEngine.should_backup_file",
      "signature": "def should_backup_file(self, file_path: Path) -> bool:"
    },
    "app.backup.files.FileBackupEngine.start_monitoring": {
      "calls": [
        "logger.warning",
        "self.observer.start",
        "logger.info",
        "str",
        "logger.error",
        "self.observer.schedule",
        "FileChangeHandler",
        "Observer",
        "watch_dir.exists"
      ],
      "decorators": [],
      "docstring": "Start real-time file monitoring.",
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 154,
      "line_start": 132,
      "module": "app.backup.files",
      "name": "FileBackupEngine.start_monitoring",
      "signature": "def start_monitoring(self):"
    },
    "app.backup.files.FileBackupEngine.stop_monitoring": {
      "calls": [
        "self.observer.stop",
        "logger.info",
        "self.observer.join"
      ],
      "decorators": [],
      "docstring": "Stop real-time file monitoring.",
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 161,
      "line_start": 156,
      "module": "app.backup.files",
      "name": "FileBackupEngine.stop_monitoring",
      "signature": "def stop_monitoring(self):"
    },
    "app.backup.files.FileChangeHandler.__init__": {
      "calls": [
        "logging.getLogger"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 35,
      "line_start": 33,
      "module": "app.backup.files",
      "name": "FileChangeHandler.__init__",
      "signature": "def __init__(self, backup_engine):"
    },
    "app.backup.files.FileChangeHandler.on_created": {
      "calls": [
        "Path",
        "self.logger.debug",
        "self.backup_engine.queue_file_for_backup"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 40,
      "line_start": 37,
      "module": "app.backup.files",
      "name": "FileChangeHandler.on_created",
      "signature": "def on_created(self, event):"
    },
    "app.backup.files.FileChangeHandler.on_modified": {
      "calls": [
        "Path",
        "self.logger.debug",
        "self.backup_engine.queue_file_for_backup"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 45,
      "line_start": 42,
      "module": "app.backup.files",
      "name": "FileChangeHandler.on_modified",
      "signature": "def on_modified(self, event):"
    },
    "app.backup.files.FileChangeHandler.on_moved": {
      "calls": [
        "Path",
        "self.logger.debug",
        "self.backup_engine.queue_file_for_backup"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 50,
      "line_start": 47,
      "module": "app.backup.files",
      "name": "FileChangeHandler.on_moved",
      "signature": "def on_moved(self, event):"
    },
    "app.backup.files.__del__": {
      "calls": [
        "hasattr",
        "self.stop_monitoring"
      ],
      "decorators": [],
      "docstring": "Cleanup when object is destroyed.",
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 474,
      "line_start": 471,
      "module": "app.backup.files",
      "name": "__del__",
      "signature": "def __del__(self):"
    },
    "app.backup.files.__init__": {
      "calls": [
        "Path",
        "set",
        "self.backup_dir.mkdir",
        "mkdir",
        "self.load_indexes",
        "threading.Lock",
        "self.start_monitoring"
      ],
      "decorators": [],
      "docstring": "Initialize file backup engine.\n\nArgs:\n    watch_directories: List of directories to monitor\n    backup_base_dir: Base directory for backups\n    enable_realtime: Enable real-time file monitoring",
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 106,
      "line_start": 66,
      "module": "app.backup.files",
      "name": "__init__",
      "signature": "def __init__(self, watch_directories: List[str], backup_base_dir: str, enable_realtime: bool = True):"
    },
    "app.backup.files._calculate_file_hash": {
      "calls": [
        "hasher.update",
        "open",
        "iter",
        "f.read",
        "hashlib.sha256",
        "hasher.hexdigest"
      ],
      "decorators": [],
      "docstring": "Calculate SHA-256 hash of file content.",
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 454,
      "line_start": 448,
      "module": "app.backup.files",
      "name": "_calculate_file_hash",
      "signature": "def _calculate_file_hash(self, file_path: Path) -> str:"
    },
    "app.backup.files._get_relative_backup_path": {
      "calls": [
        "file_path.resolve",
        "Path",
        "file_path.relative_to",
        "watch_dir.resolve"
      ],
      "decorators": [],
      "docstring": "Get relative backup path for a file.",
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 469,
      "line_start": 456,
      "module": "app.backup.files",
      "name": "_get_relative_backup_path",
      "signature": "def _get_relative_backup_path(self, file_path: Path) -> Path:"
    },
    "app.backup.files.backup_directory": {
      "calls": [
        "Path",
        "logger.warning",
        "len",
        "logger.info",
        "directory.exists",
        "backups_completed.append",
        "self.backup_file",
        "os.walk"
      ],
      "decorators": [],
      "docstring": "Backup all files in a directory recursively.\n\nArgs:\n    directory: Directory to backup\n    compression_engine: Optional compression engine\n    \nReturns:\n    List of backup metadata for all files",
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 362,
      "line_start": 332,
      "module": "app.backup.files",
      "name": "backup_directory",
      "signature": "def backup_directory(self, directory: Path, compression_engine=None) -> List[Dict]:"
    },
    "app.backup.files.backup_file": {
      "calls": [
        "backup_metadata.get",
        "backup_path.with_suffix",
        "backup_path.stat",
        "traceback.format_exc",
        "datetime.utcnow",
        "timestamp.isoformat",
        "self._calculate_file_hash",
        "compression_engine.compress_file",
        "logger.info",
        "timedelta",
        "file_path.resolve",
        "self._get_relative_backup_path",
        "timestamp.strftime",
        "file_mtime.isoformat",
        "backup_path.unlink",
        "datetime.fromtimestamp",
        "self.should_backup_file",
        "file_path.stat",
        "shutil.copy2",
        "backup_subdir.mkdir",
        "self.save_indexes",
        "str",
        "logger.error",
        "last_backup.get",
        "datetime.fromisoformat",
        "logger.debug",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Backup a single file with deduplication.\n\nArgs:\n    file_path: Path to the file to backup\n    compression_engine: Optional compression engine\n    \nReturns:\n    Dict with backup metadata or None if skipped",
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 305,
      "line_start": 202,
      "module": "app.backup.files",
      "name": "backup_file",
      "signature": "def backup_file(self, file_path: Path, compression_engine=None) -> Optional[Dict]:"
    },
    "app.backup.files.cleanup_expired_backups": {
      "calls": [
        "Path",
        "backup_path.exists",
        "self.save_indexes",
        "len",
        "logger.info",
        "self.file_index.items",
        "expired_files.append",
        "hash_info.get",
        "logger.error",
        "datetime.utcnow",
        "datetime.fromisoformat",
        "backup_path.unlink"
      ],
      "decorators": [],
      "docstring": "Remove expired file backups based on retention policies.",
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 402,
      "line_start": 364,
      "module": "app.backup.files",
      "name": "cleanup_expired_backups",
      "signature": "def cleanup_expired_backups(self):"
    },
    "app.backup.files.get_backup_status": {
      "calls": [
        "self.file_index.values",
        "len",
        "str",
        "logger.error",
        "backup_info.get"
      ],
      "decorators": [],
      "docstring": "Get file backup status and statistics.\n\nReturns:\n    Dict with backup status information",
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 446,
      "line_start": 404,
      "module": "app.backup.files",
      "name": "get_backup_status",
      "signature": "def get_backup_status(self) -> Dict:"
    },
    "app.backup.files.load_indexes": {
      "calls": [
        "open",
        "self.content_hash_index_file.exists",
        "self.file_index_file.exists",
        "json.load"
      ],
      "decorators": [],
      "docstring": "Load file indexes from disk.",
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 122,
      "line_start": 108,
      "module": "app.backup.files",
      "name": "load_indexes",
      "signature": "def load_indexes(self):"
    },
    "app.backup.files.on_created": {
      "calls": [
        "Path",
        "self.logger.debug",
        "self.backup_engine.queue_file_for_backup"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 40,
      "line_start": 37,
      "module": "app.backup.files",
      "name": "on_created",
      "signature": "def on_created(self, event):"
    },
    "app.backup.files.on_modified": {
      "calls": [
        "Path",
        "self.logger.debug",
        "self.backup_engine.queue_file_for_backup"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 45,
      "line_start": 42,
      "module": "app.backup.files",
      "name": "on_modified",
      "signature": "def on_modified(self, event):"
    },
    "app.backup.files.on_moved": {
      "calls": [
        "Path",
        "self.logger.debug",
        "self.backup_engine.queue_file_for_backup"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 50,
      "line_start": 47,
      "module": "app.backup.files",
      "name": "on_moved",
      "signature": "def on_moved(self, event):"
    },
    "app.backup.files.process_backup_queue": {
      "calls": [
        "self.backup_queue.clear",
        "len",
        "logger.info",
        "list",
        "backups_completed.append",
        "self.backup_file"
      ],
      "decorators": [],
      "docstring": "Process all files in the backup queue.\n\nArgs:\n    compression_engine: Optional compression engine\n    \nReturns:\n    List of backup metadata for processed files",
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 330,
      "line_start": 307,
      "module": "app.backup.files",
      "name": "process_backup_queue",
      "signature": "def process_backup_queue(self, compression_engine=None) -> List[Dict]:"
    },
    "app.backup.files.queue_file_for_backup": {
      "calls": [
        "self.should_backup_file",
        "self.backup_queue.add"
      ],
      "decorators": [],
      "docstring": "Add a file to the backup queue.",
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 167,
      "line_start": 163,
      "module": "app.backup.files",
      "name": "queue_file_for_backup",
      "signature": "def queue_file_for_backup(self, file_path: Path):"
    },
    "app.backup.files.save_indexes": {
      "calls": [
        "open",
        "json.dump"
      ],
      "decorators": [],
      "docstring": "Save file indexes to disk.",
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 130,
      "line_start": 124,
      "module": "app.backup.files",
      "name": "save_indexes",
      "signature": "def save_indexes(self):"
    },
    "app.backup.files.should_backup_file": {
      "calls": [
        "file_path.relative_to",
        "file_path.exists",
        "str",
        "file_path.suffix.lower",
        "file_path.is_file"
      ],
      "decorators": [],
      "docstring": "Determine if a file should be backed up.\n\nArgs:\n    file_path: Path to the file\n    \nReturns:\n    bool: True if file should be backed up",
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 200,
      "line_start": 169,
      "module": "app.backup.files",
      "name": "should_backup_file",
      "signature": "def should_backup_file(self, file_path: Path) -> bool:"
    },
    "app.backup.files.start_monitoring": {
      "calls": [
        "logger.warning",
        "self.observer.start",
        "logger.info",
        "str",
        "logger.error",
        "self.observer.schedule",
        "FileChangeHandler",
        "Observer",
        "watch_dir.exists"
      ],
      "decorators": [],
      "docstring": "Start real-time file monitoring.",
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 154,
      "line_start": 132,
      "module": "app.backup.files",
      "name": "start_monitoring",
      "signature": "def start_monitoring(self):"
    },
    "app.backup.files.stop_monitoring": {
      "calls": [
        "self.observer.stop",
        "logger.info",
        "self.observer.join"
      ],
      "decorators": [],
      "docstring": "Stop real-time file monitoring.",
      "file_path": "app/backup/files.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 161,
      "line_start": 156,
      "module": "app.backup.files",
      "name": "stop_monitoring",
      "signature": "def stop_monitoring(self):"
    },
    "app.backup.orchestrator.BackupOrchestrator.__init__": {
      "calls": [
        "Path",
        "self.backup_base_dir.mkdir",
        "logger.info",
        "self._initialize_components",
        "threading.Lock",
        "config.get",
        "self.load_state"
      ],
      "decorators": [],
      "docstring": "Initialize backup orchestrator.\n\nArgs:\n    config: Backup configuration dictionary",
      "file_path": "app/backup/orchestrator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 76,
      "line_start": 40,
      "module": "app.backup.orchestrator",
      "name": "BackupOrchestrator.__init__",
      "signature": "def __init__(self, config: Dict):"
    },
    "app.backup.orchestrator.BackupOrchestrator._create_storage_backend": {
      "calls": [
        "LocalStorageBackend",
        "S3StorageBackend",
        "str",
        "backend_config.get",
        "logger.error",
        "SFTPStorageBackend"
      ],
      "decorators": [],
      "docstring": "Create a storage backend from configuration.",
      "file_path": "app/backup/orchestrator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 189,
      "line_start": 150,
      "module": "app.backup.orchestrator",
      "name": "BackupOrchestrator._create_storage_backend",
      "signature": "def _create_storage_backend(self, backend_config: Dict) -> Optional[StorageBackend]:"
    },
    "app.backup.orchestrator.BackupOrchestrator._initialize_components": {
      "calls": [
        "self.save_state",
        "get",
        "db_config.get",
        "self.database_engine.enable_wal_mode",
        "LocalStorageBackend",
        "FileBackupEngine",
        "str",
        "file_config.get",
        "self.config.get",
        "logger.error",
        "DatabaseBackupEngine",
        "compression_config.get",
        "CompressionEngine",
        "self._create_storage_backend",
        "self.storage_backends.append"
      ],
      "decorators": [],
      "docstring": "Initialize backup components based on configuration.",
      "file_path": "app/backup/orchestrator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 148,
      "line_start": 97,
      "module": "app.backup.orchestrator",
      "name": "BackupOrchestrator._initialize_components",
      "signature": "def _initialize_components(self):"
    },
    "app.backup.orchestrator.BackupOrchestrator._update_operation_progress": {
      "calls": [
        "datetime.utcnow",
        "update",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Update operation progress and status.",
      "file_path": "app/backup/orchestrator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 597,
      "line_start": 589,
      "module": "app.backup.orchestrator",
      "name": "BackupOrchestrator._update_operation_progress",
      "signature": "def _update_operation_progress(self, operation_id: str, progress: int, status: str):"
    },
    "app.backup.orchestrator.BackupOrchestrator._upload_backups_to_storage": {
      "calls": [
        "len",
        "min",
        "ThreadPoolExecutor",
        "str",
        "upload_results.append",
        "logger.error",
        "executor.submit",
        "futures.append",
        "future.result"
      ],
      "decorators": [],
      "docstring": "Upload backup files to configured storage backends.",
      "file_path": "app/backup/orchestrator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 545,
      "line_start": 522,
      "module": "app.backup.orchestrator",
      "name": "BackupOrchestrator._upload_backups_to_storage",
      "signature": "def _upload_backups_to_storage(self, backup_results: Dict) -> List[Dict]:"
    },
    "app.backup.orchestrator.BackupOrchestrator._upload_to_backend": {
      "calls": [
        "Path",
        "backend.upload_file",
        "str",
        "backup_results.get",
        "logger.error",
        "local_path.relative_to",
        "file_backup.get",
        "local_path.stat"
      ],
      "decorators": [],
      "docstring": "Upload backup files to a specific storage backend.",
      "file_path": "app/backup/orchestrator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 587,
      "line_start": 547,
      "module": "app.backup.orchestrator",
      "name": "BackupOrchestrator._upload_to_backend",
      "signature": "def _upload_to_backend(self, backend: StorageBackend, backup_results: Dict) -> Dict:"
    },
    "app.backup.orchestrator.BackupOrchestrator.cleanup_expired_backups": {
      "calls": [
        "backend.get_backend_info",
        "self.database_engine.cleanup_expired_backups",
        "self.save_state",
        "get",
        "self.file_engine.cleanup_expired_backups",
        "logger.info",
        "str",
        "append",
        "logger.error",
        "datetime.utcnow",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Clean up expired backups across all components.\n\nReturns:\n    Dict with cleanup results",
      "file_path": "app/backup/orchestrator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 472,
      "line_start": 419,
      "module": "app.backup.orchestrator",
      "name": "BackupOrchestrator.cleanup_expired_backups",
      "signature": "def cleanup_expired_backups(self) -> Dict:"
    },
    "app.backup.orchestrator.BackupOrchestrator.create_full_backup": {
      "calls": [
        "self._upload_backups_to_storage",
        "self.save_state",
        "db_backup.get",
        "extend",
        "len",
        "logger.info",
        "strftime",
        "str",
        "self.file_engine.process_backup_queue",
        "self.file_engine.backup_directory",
        "append",
        "self.database_engine.create_full_backup",
        "logger.error",
        "datetime.utcnow",
        "file_backup.get",
        "self._update_operation_progress",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Create a complete system backup.\n\nArgs:\n    upload_to_storage: Whether to upload to configured storage backends\n    \nReturns:\n    Dict with backup operation results",
      "file_path": "app/backup/orchestrator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 317,
      "line_start": 191,
      "module": "app.backup.orchestrator",
      "name": "BackupOrchestrator.create_full_backup",
      "signature": "def create_full_backup(self, upload_to_storage: bool = True) -> Dict:"
    },
    "app.backup.orchestrator.BackupOrchestrator.create_incremental_backup": {
      "calls": [
        "file_info.get",
        "self.database_engine.backup_wal_files",
        "self._upload_backups_to_storage",
        "logger.info",
        "strftime",
        "str",
        "self.file_engine.process_backup_queue",
        "wal_backup.get",
        "logger.error",
        "datetime.utcnow",
        "file_backup.get",
        "self._update_operation_progress",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Create an incremental backup (WAL files and changed files only).\n\nArgs:\n    upload_to_storage: Whether to upload to configured storage backends\n    \nReturns:\n    Dict with backup operation results",
      "file_path": "app/backup/orchestrator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 417,
      "line_start": 319,
      "module": "app.backup.orchestrator",
      "name": "BackupOrchestrator.create_incremental_backup",
      "signature": "def create_incremental_backup(self, upload_to_storage: bool = True) -> Dict:"
    },
    "app.backup.orchestrator.BackupOrchestrator.get_backup_status": {
      "calls": [
        "self.file_engine.get_backup_status",
        "backend.get_backend_info",
        "self.stats.copy",
        "self.compression_engine.get_compression_info",
        "len",
        "str",
        "append",
        "logger.error",
        "self.current_operations.copy",
        "self.database_engine.get_backup_status",
        "self.state.get"
      ],
      "decorators": [],
      "docstring": "Get comprehensive backup system status.\n\nReturns:\n    Dict with complete backup system status",
      "file_path": "app/backup/orchestrator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 520,
      "line_start": 474,
      "module": "app.backup.orchestrator",
      "name": "BackupOrchestrator.get_backup_status",
      "signature": "def get_backup_status(self) -> Dict:"
    },
    "app.backup.orchestrator.BackupOrchestrator.load_state": {
      "calls": [
        "self.state_file.exists",
        "json.load",
        "open"
      ],
      "decorators": [],
      "docstring": "Load orchestrator state from disk.",
      "file_path": "app/backup/orchestrator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 89,
      "line_start": 78,
      "module": "app.backup.orchestrator",
      "name": "BackupOrchestrator.load_state",
      "signature": "def load_state(self):"
    },
    "app.backup.orchestrator.BackupOrchestrator.save_state": {
      "calls": [
        "open",
        "datetime.utcnow",
        "isoformat",
        "json.dump"
      ],
      "decorators": [],
      "docstring": "Save orchestrator state to disk.",
      "file_path": "app/backup/orchestrator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 95,
      "line_start": 91,
      "module": "app.backup.orchestrator",
      "name": "BackupOrchestrator.save_state",
      "signature": "def save_state(self):"
    },
    "app.backup.orchestrator.BackupOrchestrator.stop": {
      "calls": [
        "self.file_engine.stop_monitoring",
        "logger.info"
      ],
      "decorators": [],
      "docstring": "Stop the backup orchestrator and cleanup resources.",
      "file_path": "app/backup/orchestrator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 606,
      "line_start": 599,
      "module": "app.backup.orchestrator",
      "name": "BackupOrchestrator.stop",
      "signature": "def stop(self):"
    },
    "app.backup.orchestrator.__init__": {
      "calls": [
        "Path",
        "self.backup_base_dir.mkdir",
        "logger.info",
        "self._initialize_components",
        "threading.Lock",
        "config.get",
        "self.load_state"
      ],
      "decorators": [],
      "docstring": "Initialize backup orchestrator.\n\nArgs:\n    config: Backup configuration dictionary",
      "file_path": "app/backup/orchestrator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 76,
      "line_start": 40,
      "module": "app.backup.orchestrator",
      "name": "__init__",
      "signature": "def __init__(self, config: Dict):"
    },
    "app.backup.orchestrator._create_storage_backend": {
      "calls": [
        "LocalStorageBackend",
        "S3StorageBackend",
        "str",
        "backend_config.get",
        "logger.error",
        "SFTPStorageBackend"
      ],
      "decorators": [],
      "docstring": "Create a storage backend from configuration.",
      "file_path": "app/backup/orchestrator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 189,
      "line_start": 150,
      "module": "app.backup.orchestrator",
      "name": "_create_storage_backend",
      "signature": "def _create_storage_backend(self, backend_config: Dict) -> Optional[StorageBackend]:"
    },
    "app.backup.orchestrator._initialize_components": {
      "calls": [
        "self.save_state",
        "get",
        "db_config.get",
        "self.database_engine.enable_wal_mode",
        "LocalStorageBackend",
        "FileBackupEngine",
        "str",
        "file_config.get",
        "self.config.get",
        "logger.error",
        "DatabaseBackupEngine",
        "compression_config.get",
        "CompressionEngine",
        "self._create_storage_backend",
        "self.storage_backends.append"
      ],
      "decorators": [],
      "docstring": "Initialize backup components based on configuration.",
      "file_path": "app/backup/orchestrator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 148,
      "line_start": 97,
      "module": "app.backup.orchestrator",
      "name": "_initialize_components",
      "signature": "def _initialize_components(self):"
    },
    "app.backup.orchestrator._update_operation_progress": {
      "calls": [
        "datetime.utcnow",
        "update",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Update operation progress and status.",
      "file_path": "app/backup/orchestrator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 597,
      "line_start": 589,
      "module": "app.backup.orchestrator",
      "name": "_update_operation_progress",
      "signature": "def _update_operation_progress(self, operation_id: str, progress: int, status: str):"
    },
    "app.backup.orchestrator._upload_backups_to_storage": {
      "calls": [
        "len",
        "min",
        "ThreadPoolExecutor",
        "str",
        "upload_results.append",
        "logger.error",
        "executor.submit",
        "futures.append",
        "future.result"
      ],
      "decorators": [],
      "docstring": "Upload backup files to configured storage backends.",
      "file_path": "app/backup/orchestrator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 545,
      "line_start": 522,
      "module": "app.backup.orchestrator",
      "name": "_upload_backups_to_storage",
      "signature": "def _upload_backups_to_storage(self, backup_results: Dict) -> List[Dict]:"
    },
    "app.backup.orchestrator._upload_to_backend": {
      "calls": [
        "Path",
        "backend.upload_file",
        "str",
        "backup_results.get",
        "logger.error",
        "local_path.relative_to",
        "file_backup.get",
        "local_path.stat"
      ],
      "decorators": [],
      "docstring": "Upload backup files to a specific storage backend.",
      "file_path": "app/backup/orchestrator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 587,
      "line_start": 547,
      "module": "app.backup.orchestrator",
      "name": "_upload_to_backend",
      "signature": "def _upload_to_backend(self, backend: StorageBackend, backup_results: Dict) -> Dict:"
    },
    "app.backup.orchestrator.cleanup_expired_backups": {
      "calls": [
        "backend.get_backend_info",
        "self.database_engine.cleanup_expired_backups",
        "self.save_state",
        "get",
        "self.file_engine.cleanup_expired_backups",
        "logger.info",
        "str",
        "append",
        "logger.error",
        "datetime.utcnow",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Clean up expired backups across all components.\n\nReturns:\n    Dict with cleanup results",
      "file_path": "app/backup/orchestrator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 472,
      "line_start": 419,
      "module": "app.backup.orchestrator",
      "name": "cleanup_expired_backups",
      "signature": "def cleanup_expired_backups(self) -> Dict:"
    },
    "app.backup.orchestrator.create_full_backup": {
      "calls": [
        "self._upload_backups_to_storage",
        "self.save_state",
        "db_backup.get",
        "extend",
        "len",
        "logger.info",
        "strftime",
        "str",
        "self.file_engine.process_backup_queue",
        "self.file_engine.backup_directory",
        "append",
        "self.database_engine.create_full_backup",
        "logger.error",
        "datetime.utcnow",
        "file_backup.get",
        "self._update_operation_progress",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Create a complete system backup.\n\nArgs:\n    upload_to_storage: Whether to upload to configured storage backends\n    \nReturns:\n    Dict with backup operation results",
      "file_path": "app/backup/orchestrator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 317,
      "line_start": 191,
      "module": "app.backup.orchestrator",
      "name": "create_full_backup",
      "signature": "def create_full_backup(self, upload_to_storage: bool = True) -> Dict:"
    },
    "app.backup.orchestrator.create_incremental_backup": {
      "calls": [
        "file_info.get",
        "self.database_engine.backup_wal_files",
        "self._upload_backups_to_storage",
        "logger.info",
        "strftime",
        "str",
        "self.file_engine.process_backup_queue",
        "wal_backup.get",
        "logger.error",
        "datetime.utcnow",
        "file_backup.get",
        "self._update_operation_progress",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Create an incremental backup (WAL files and changed files only).\n\nArgs:\n    upload_to_storage: Whether to upload to configured storage backends\n    \nReturns:\n    Dict with backup operation results",
      "file_path": "app/backup/orchestrator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 417,
      "line_start": 319,
      "module": "app.backup.orchestrator",
      "name": "create_incremental_backup",
      "signature": "def create_incremental_backup(self, upload_to_storage: bool = True) -> Dict:"
    },
    "app.backup.orchestrator.get_backup_status": {
      "calls": [
        "self.file_engine.get_backup_status",
        "backend.get_backend_info",
        "self.stats.copy",
        "self.compression_engine.get_compression_info",
        "len",
        "str",
        "append",
        "logger.error",
        "self.current_operations.copy",
        "self.database_engine.get_backup_status",
        "self.state.get"
      ],
      "decorators": [],
      "docstring": "Get comprehensive backup system status.\n\nReturns:\n    Dict with complete backup system status",
      "file_path": "app/backup/orchestrator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 520,
      "line_start": 474,
      "module": "app.backup.orchestrator",
      "name": "get_backup_status",
      "signature": "def get_backup_status(self) -> Dict:"
    },
    "app.backup.orchestrator.load_state": {
      "calls": [
        "self.state_file.exists",
        "json.load",
        "open"
      ],
      "decorators": [],
      "docstring": "Load orchestrator state from disk.",
      "file_path": "app/backup/orchestrator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 89,
      "line_start": 78,
      "module": "app.backup.orchestrator",
      "name": "load_state",
      "signature": "def load_state(self):"
    },
    "app.backup.orchestrator.save_state": {
      "calls": [
        "open",
        "datetime.utcnow",
        "isoformat",
        "json.dump"
      ],
      "decorators": [],
      "docstring": "Save orchestrator state to disk.",
      "file_path": "app/backup/orchestrator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 95,
      "line_start": 91,
      "module": "app.backup.orchestrator",
      "name": "save_state",
      "signature": "def save_state(self):"
    },
    "app.backup.orchestrator.stop": {
      "calls": [
        "self.file_engine.stop_monitoring",
        "logger.info"
      ],
      "decorators": [],
      "docstring": "Stop the backup orchestrator and cleanup resources.",
      "file_path": "app/backup/orchestrator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 606,
      "line_start": 599,
      "module": "app.backup.orchestrator",
      "name": "stop",
      "signature": "def stop(self):"
    },
    "app.backup.recovery.RecoveryManager.__init__": {
      "calls": [
        "Path",
        "logger.info",
        "self.recovery_log_dir.mkdir"
      ],
      "decorators": [],
      "docstring": "Initialize recovery manager.\n\nArgs:\n    backup_base_dir: Directory containing backup files\n    target_system_dir: Target directory for system restoration",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 54,
      "line_start": 35,
      "module": "app.backup.recovery",
      "name": "RecoveryManager.__init__",
      "signature": "def __init__(self, backup_base_dir: str, target_system_dir: str):"
    },
    "app.backup.recovery.RecoveryManager._apply_wal_files_until": {
      "calls": [
        "db_path.with_suffix",
        "sqlite3.connect",
        "wal_dir.is_dir",
        "shutil.copy2",
        "target_wal.unlink",
        "wal_backup_dir.iterdir",
        "datetime.strptime",
        "conn.execute",
        "wal_file.exists",
        "target_wal.exists",
        "str",
        "applicable_wals.append",
        "logger.error",
        "wal_backup_dir.exists",
        "datetime.fromisoformat",
        "applicable_wals.sort"
      ],
      "decorators": [],
      "docstring": "Apply WAL files for point-in-time recovery.",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 623,
      "line_start": 581,
      "module": "app.backup.recovery",
      "name": "RecoveryManager._apply_wal_files_until",
      "signature": "def _apply_wal_files_until(self, db_path: Path, target_time: str):"
    },
    "app.backup.recovery.RecoveryManager._create_recovery_backup": {
      "calls": [
        "recovery_backup_dir.mkdir",
        "shutil.copy2",
        "logger.info"
      ],
      "decorators": [],
      "docstring": "Create a backup before recovery operation.",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 557,
      "line_start": 548,
      "module": "app.backup.recovery",
      "name": "RecoveryManager._create_recovery_backup",
      "signature": "def _create_recovery_backup(self, target_path: Path, recovery_id: str) -> Path:"
    },
    "app.backup.recovery.RecoveryManager._filter_files_for_restoration": {
      "calls": [
        "fnmatch.fnmatch",
        "backup_info.get",
        "v.get",
        "file_index.items"
      ],
      "decorators": [],
      "docstring": "Filter files for restoration based on patterns.",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 718,
      "line_start": 703,
      "module": "app.backup.recovery",
      "name": "RecoveryManager._filter_files_for_restoration",
      "signature": "def _filter_files_for_restoration(self, file_index: Dict, patterns: List[str] = None) -> Dict:"
    },
    "app.backup.recovery.RecoveryManager._get_backup_file_info": {
      "calls": [
        "str",
        "logger.error",
        "datetime.fromtimestamp",
        "backup_file.stat",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Get information about a backup file.",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 518,
      "line_start": 504,
      "module": "app.backup.recovery",
      "name": "RecoveryManager._get_backup_file_info",
      "signature": "def _get_backup_file_info(self, backup_file: Path) -> Optional[Dict]:"
    },
    "app.backup.recovery.RecoveryManager._get_database_backup_by_id": {
      "calls": [
        "self._get_backup_file_info",
        "db_backup_dir.glob"
      ],
      "decorators": [],
      "docstring": "Get database backup by specific ID.",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 546,
      "line_start": 539,
      "module": "app.backup.recovery",
      "name": "RecoveryManager._get_database_backup_by_id",
      "signature": "def _get_database_backup_by_id(self, backup_id: str) -> Optional[Dict]:"
    },
    "app.backup.recovery.RecoveryManager._get_latest_database_backup": {
      "calls": [
        "self._get_backup_file_info",
        "db_backup_dir.exists",
        "db_backup_dir.glob",
        "datetime.fromisoformat"
      ],
      "decorators": [],
      "docstring": "Get the latest database backup.",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 537,
      "line_start": 520,
      "module": "app.backup.recovery",
      "name": "RecoveryManager._get_latest_database_backup",
      "signature": "def _get_latest_database_backup(self) -> Optional[Dict]:"
    },
    "app.backup.recovery.RecoveryManager._log_recovery_operation": {
      "calls": [
        "open",
        "logger.error",
        "logger.info",
        "json.dump"
      ],
      "decorators": [],
      "docstring": "Log recovery operation to disk.",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 757,
      "line_start": 745,
      "module": "app.backup.recovery",
      "name": "RecoveryManager._log_recovery_operation",
      "signature": "def _log_recovery_operation(self, recovery_result: Dict):"
    },
    "app.backup.recovery.RecoveryManager._restore_database_file": {
      "calls": [
        "Path",
        "shutil.copy2",
        "target_path.parent.mkdir",
        "backup_info.get",
        "CompressionEngine",
        "NotImplementedError",
        "compression_engine.decompress_file"
      ],
      "decorators": [],
      "docstring": "Restore database file handling compression and encryption.",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 579,
      "line_start": 559,
      "module": "app.backup.recovery",
      "name": "RecoveryManager._restore_database_file",
      "signature": "def _restore_database_file(self, backup_info: Dict, target_path: Path) -> Path:"
    },
    "app.backup.recovery.RecoveryManager._restore_single_file": {
      "calls": [
        "Path",
        "backup_path.exists",
        "shutil.copy2",
        "target_path.parent.mkdir",
        "logger.error",
        "backup_info.get",
        "CompressionEngine",
        "compression_engine.decompress_file"
      ],
      "decorators": [],
      "docstring": "Restore a single file from backup.",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 743,
      "line_start": 720,
      "module": "app.backup.recovery",
      "name": "RecoveryManager._restore_single_file",
      "signature": "def _restore_single_file(self, backup_info: Dict, target_path: Path) -> bool:"
    },
    "app.backup.recovery.RecoveryManager._validate_database": {
      "calls": [
        "sqlite3.connect",
        "conn.execute",
        "len",
        "cursor.fetchone",
        "str",
        "db_path.exists",
        "logger.error",
        "db_path.stat",
        "cursor.fetchall"
      ],
      "decorators": [],
      "docstring": "Validate database integrity.",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 664,
      "line_start": 625,
      "module": "app.backup.recovery",
      "name": "RecoveryManager._validate_database",
      "signature": "def _validate_database(self, db_path: Path) -> Dict:"
    },
    "app.backup.recovery.RecoveryManager._validate_restored_files": {
      "calls": [],
      "decorators": [],
      "docstring": "Validate restored files.",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 674,
      "line_start": 666,
      "module": "app.backup.recovery",
      "name": "RecoveryManager._validate_restored_files",
      "signature": "def _validate_restored_files(self) -> Dict:"
    },
    "app.backup.recovery.RecoveryManager._validate_system_structure": {
      "calls": [
        "append",
        "full_path.exists",
        "len"
      ],
      "decorators": [],
      "docstring": "Validate system directory structure.",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 701,
      "line_start": 676,
      "module": "app.backup.recovery",
      "name": "RecoveryManager._validate_system_structure",
      "signature": "def _validate_system_structure(self) -> Dict:"
    },
    "app.backup.recovery.RecoveryManager.list_available_backups": {
      "calls": [
        "json.load",
        "wal_dir.is_dir",
        "wal_backup_dir.iterdir",
        "file_index.items",
        "open",
        "db_backup_dir.glob",
        "self._get_backup_file_info",
        "str",
        "append",
        "logger.error",
        "wal_backup_dir.exists",
        "backup_info.get",
        "x.get",
        "wal_dir.glob",
        "sort",
        "db_backup_dir.exists",
        "file_index_path.exists"
      ],
      "decorators": [],
      "docstring": "List all available backups for recovery.\n\nReturns:\n    Dict with categorized backup information",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 119,
      "line_start": 56,
      "module": "app.backup.recovery",
      "name": "RecoveryManager.list_available_backups",
      "signature": "def list_available_backups(self) -> Dict:"
    },
    "app.backup.recovery.RecoveryManager.perform_full_system_recovery": {
      "calls": [
        "db_recovery.get",
        "self.validate_system_recovery",
        "Exception",
        "self.restore_files",
        "logger.info",
        "strftime",
        "self._log_recovery_operation",
        "str",
        "logger.error",
        "datetime.utcnow",
        "file_recovery.get",
        "validation_result.get",
        "self.restore_database",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Perform complete system recovery from backups.\n\nArgs:\n    backup_timestamp: Specific backup timestamp (latest if None)\n    \nReturns:\n    Dict with complete recovery results",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 391,
      "line_start": 318,
      "module": "app.backup.recovery",
      "name": "RecoveryManager.perform_full_system_recovery",
      "signature": "def perform_full_system_recovery(self, backup_timestamp: Optional[str] = None) -> Dict:"
    },
    "app.backup.recovery.RecoveryManager.restore_database": {
      "calls": [
        "Exception",
        "self._get_database_backup_by_id",
        "ValueError",
        "strftime",
        "self._restore_database_file",
        "datetime.utcnow",
        "validation_result.get",
        "target_path.exists",
        "self._validate_database",
        "Path",
        "recovery_backup_path.exists",
        "logger.info",
        "self._apply_wal_files_until",
        "shutil.copy2",
        "self._get_latest_database_backup",
        "self._log_recovery_operation",
        "str",
        "logger.error",
        "self._create_recovery_backup",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Restore database from backup with optional point-in-time recovery.\n\nArgs:\n    backup_id: Specific backup ID to restore (latest if None)\n    point_in_time: ISO timestamp for point-in-time recovery\n    target_path: Target database path (default location if None)\n    \nReturns:\n    Dict with restoration results",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 219,
      "line_start": 121,
      "module": "app.backup.recovery",
      "name": "RecoveryManager.restore_database",
      "signature": "def restore_database(self, backup_id: Optional[str] = None, point_in_time: Optional[str] = None, target_path: Optional[str] = None) -> Dict:"
    },
    "app.backup.recovery.RecoveryManager.restore_files": {
      "calls": [
        "ValueError",
        "len",
        "open",
        "strftime",
        "datetime.utcnow",
        "self._restore_single_file",
        "file_index_path.exists",
        "Path",
        "self._filter_files_for_restoration",
        "files_to_restore.items",
        "logger.info",
        "relative_to",
        "backup_info.get",
        "json.load",
        "self._log_recovery_operation",
        "str",
        "append",
        "logger.error",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Restore files from backup.\n\nArgs:\n    file_patterns: List of file patterns to restore (all if None)\n    restore_to_original: Restore to original locations\n    target_directory: Alternative restore directory\n    \nReturns:\n    Dict with restoration results",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 316,
      "line_start": 221,
      "module": "app.backup.recovery",
      "name": "RecoveryManager.restore_files",
      "signature": "def restore_files(self, file_patterns: List[str] = None, restore_to_original: bool = True, target_directory: Optional[str] = None) -> Dict:"
    },
    "app.backup.recovery.RecoveryManager.test_recovery_procedures": {
      "calls": [
        "Path",
        "get",
        "self.validate_system_recovery",
        "self.restore_files",
        "logger.info",
        "str",
        "tempfile.TemporaryDirectory",
        "temp_target.mkdir",
        "logger.error",
        "datetime.utcnow",
        "all",
        "self.restore_database",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Test recovery procedures in a safe environment.\n\nReturns:\n    Dict with test results",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 502,
      "line_start": 437,
      "module": "app.backup.recovery",
      "name": "RecoveryManager.test_recovery_procedures",
      "signature": "def test_recovery_procedures(self) -> Dict:"
    },
    "app.backup.recovery.RecoveryManager.validate_system_recovery": {
      "calls": [
        "get",
        "str",
        "db_path.exists",
        "logger.error",
        "datetime.utcnow",
        "all",
        "self._validate_restored_files",
        "self._validate_system_structure",
        "self._validate_database",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Validate system state after recovery.\n\nReturns:\n    Dict with validation results",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 435,
      "line_start": 393,
      "module": "app.backup.recovery",
      "name": "RecoveryManager.validate_system_recovery",
      "signature": "def validate_system_recovery(self) -> Dict:"
    },
    "app.backup.recovery.__init__": {
      "calls": [
        "Path",
        "logger.info",
        "self.recovery_log_dir.mkdir"
      ],
      "decorators": [],
      "docstring": "Initialize recovery manager.\n\nArgs:\n    backup_base_dir: Directory containing backup files\n    target_system_dir: Target directory for system restoration",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 54,
      "line_start": 35,
      "module": "app.backup.recovery",
      "name": "__init__",
      "signature": "def __init__(self, backup_base_dir: str, target_system_dir: str):"
    },
    "app.backup.recovery._apply_wal_files_until": {
      "calls": [
        "db_path.with_suffix",
        "sqlite3.connect",
        "wal_dir.is_dir",
        "shutil.copy2",
        "target_wal.unlink",
        "wal_backup_dir.iterdir",
        "datetime.strptime",
        "conn.execute",
        "wal_file.exists",
        "target_wal.exists",
        "str",
        "applicable_wals.append",
        "logger.error",
        "wal_backup_dir.exists",
        "datetime.fromisoformat",
        "applicable_wals.sort"
      ],
      "decorators": [],
      "docstring": "Apply WAL files for point-in-time recovery.",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 623,
      "line_start": 581,
      "module": "app.backup.recovery",
      "name": "_apply_wal_files_until",
      "signature": "def _apply_wal_files_until(self, db_path: Path, target_time: str):"
    },
    "app.backup.recovery._create_recovery_backup": {
      "calls": [
        "recovery_backup_dir.mkdir",
        "shutil.copy2",
        "logger.info"
      ],
      "decorators": [],
      "docstring": "Create a backup before recovery operation.",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 557,
      "line_start": 548,
      "module": "app.backup.recovery",
      "name": "_create_recovery_backup",
      "signature": "def _create_recovery_backup(self, target_path: Path, recovery_id: str) -> Path:"
    },
    "app.backup.recovery._filter_files_for_restoration": {
      "calls": [
        "fnmatch.fnmatch",
        "backup_info.get",
        "v.get",
        "file_index.items"
      ],
      "decorators": [],
      "docstring": "Filter files for restoration based on patterns.",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 718,
      "line_start": 703,
      "module": "app.backup.recovery",
      "name": "_filter_files_for_restoration",
      "signature": "def _filter_files_for_restoration(self, file_index: Dict, patterns: List[str] = None) -> Dict:"
    },
    "app.backup.recovery._get_backup_file_info": {
      "calls": [
        "str",
        "logger.error",
        "datetime.fromtimestamp",
        "backup_file.stat",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Get information about a backup file.",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 518,
      "line_start": 504,
      "module": "app.backup.recovery",
      "name": "_get_backup_file_info",
      "signature": "def _get_backup_file_info(self, backup_file: Path) -> Optional[Dict]:"
    },
    "app.backup.recovery._get_database_backup_by_id": {
      "calls": [
        "self._get_backup_file_info",
        "db_backup_dir.glob"
      ],
      "decorators": [],
      "docstring": "Get database backup by specific ID.",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 546,
      "line_start": 539,
      "module": "app.backup.recovery",
      "name": "_get_database_backup_by_id",
      "signature": "def _get_database_backup_by_id(self, backup_id: str) -> Optional[Dict]:"
    },
    "app.backup.recovery._get_latest_database_backup": {
      "calls": [
        "self._get_backup_file_info",
        "db_backup_dir.exists",
        "db_backup_dir.glob",
        "datetime.fromisoformat"
      ],
      "decorators": [],
      "docstring": "Get the latest database backup.",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 537,
      "line_start": 520,
      "module": "app.backup.recovery",
      "name": "_get_latest_database_backup",
      "signature": "def _get_latest_database_backup(self) -> Optional[Dict]:"
    },
    "app.backup.recovery._log_recovery_operation": {
      "calls": [
        "open",
        "logger.error",
        "logger.info",
        "json.dump"
      ],
      "decorators": [],
      "docstring": "Log recovery operation to disk.",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 757,
      "line_start": 745,
      "module": "app.backup.recovery",
      "name": "_log_recovery_operation",
      "signature": "def _log_recovery_operation(self, recovery_result: Dict):"
    },
    "app.backup.recovery._restore_database_file": {
      "calls": [
        "Path",
        "shutil.copy2",
        "target_path.parent.mkdir",
        "backup_info.get",
        "CompressionEngine",
        "NotImplementedError",
        "compression_engine.decompress_file"
      ],
      "decorators": [],
      "docstring": "Restore database file handling compression and encryption.",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 579,
      "line_start": 559,
      "module": "app.backup.recovery",
      "name": "_restore_database_file",
      "signature": "def _restore_database_file(self, backup_info: Dict, target_path: Path) -> Path:"
    },
    "app.backup.recovery._restore_single_file": {
      "calls": [
        "Path",
        "backup_path.exists",
        "shutil.copy2",
        "target_path.parent.mkdir",
        "logger.error",
        "backup_info.get",
        "CompressionEngine",
        "compression_engine.decompress_file"
      ],
      "decorators": [],
      "docstring": "Restore a single file from backup.",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 743,
      "line_start": 720,
      "module": "app.backup.recovery",
      "name": "_restore_single_file",
      "signature": "def _restore_single_file(self, backup_info: Dict, target_path: Path) -> bool:"
    },
    "app.backup.recovery._validate_database": {
      "calls": [
        "sqlite3.connect",
        "conn.execute",
        "len",
        "cursor.fetchone",
        "str",
        "db_path.exists",
        "logger.error",
        "db_path.stat",
        "cursor.fetchall"
      ],
      "decorators": [],
      "docstring": "Validate database integrity.",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 664,
      "line_start": 625,
      "module": "app.backup.recovery",
      "name": "_validate_database",
      "signature": "def _validate_database(self, db_path: Path) -> Dict:"
    },
    "app.backup.recovery._validate_restored_files": {
      "calls": [],
      "decorators": [],
      "docstring": "Validate restored files.",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 674,
      "line_start": 666,
      "module": "app.backup.recovery",
      "name": "_validate_restored_files",
      "signature": "def _validate_restored_files(self) -> Dict:"
    },
    "app.backup.recovery._validate_system_structure": {
      "calls": [
        "append",
        "full_path.exists",
        "len"
      ],
      "decorators": [],
      "docstring": "Validate system directory structure.",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 701,
      "line_start": 676,
      "module": "app.backup.recovery",
      "name": "_validate_system_structure",
      "signature": "def _validate_system_structure(self) -> Dict:"
    },
    "app.backup.recovery.list_available_backups": {
      "calls": [
        "json.load",
        "wal_dir.is_dir",
        "wal_backup_dir.iterdir",
        "file_index.items",
        "open",
        "db_backup_dir.glob",
        "self._get_backup_file_info",
        "str",
        "append",
        "logger.error",
        "wal_backup_dir.exists",
        "backup_info.get",
        "x.get",
        "wal_dir.glob",
        "sort",
        "db_backup_dir.exists",
        "file_index_path.exists"
      ],
      "decorators": [],
      "docstring": "List all available backups for recovery.\n\nReturns:\n    Dict with categorized backup information",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 119,
      "line_start": 56,
      "module": "app.backup.recovery",
      "name": "list_available_backups",
      "signature": "def list_available_backups(self) -> Dict:"
    },
    "app.backup.recovery.perform_full_system_recovery": {
      "calls": [
        "db_recovery.get",
        "self.validate_system_recovery",
        "Exception",
        "self.restore_files",
        "logger.info",
        "strftime",
        "self._log_recovery_operation",
        "str",
        "logger.error",
        "datetime.utcnow",
        "file_recovery.get",
        "validation_result.get",
        "self.restore_database",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Perform complete system recovery from backups.\n\nArgs:\n    backup_timestamp: Specific backup timestamp (latest if None)\n    \nReturns:\n    Dict with complete recovery results",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 391,
      "line_start": 318,
      "module": "app.backup.recovery",
      "name": "perform_full_system_recovery",
      "signature": "def perform_full_system_recovery(self, backup_timestamp: Optional[str] = None) -> Dict:"
    },
    "app.backup.recovery.restore_database": {
      "calls": [
        "Exception",
        "self._get_database_backup_by_id",
        "ValueError",
        "strftime",
        "self._restore_database_file",
        "datetime.utcnow",
        "validation_result.get",
        "target_path.exists",
        "self._validate_database",
        "Path",
        "recovery_backup_path.exists",
        "logger.info",
        "self._apply_wal_files_until",
        "shutil.copy2",
        "self._get_latest_database_backup",
        "self._log_recovery_operation",
        "str",
        "logger.error",
        "self._create_recovery_backup",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Restore database from backup with optional point-in-time recovery.\n\nArgs:\n    backup_id: Specific backup ID to restore (latest if None)\n    point_in_time: ISO timestamp for point-in-time recovery\n    target_path: Target database path (default location if None)\n    \nReturns:\n    Dict with restoration results",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 219,
      "line_start": 121,
      "module": "app.backup.recovery",
      "name": "restore_database",
      "signature": "def restore_database(self, backup_id: Optional[str] = None, point_in_time: Optional[str] = None, target_path: Optional[str] = None) -> Dict:"
    },
    "app.backup.recovery.restore_files": {
      "calls": [
        "ValueError",
        "len",
        "open",
        "strftime",
        "datetime.utcnow",
        "self._restore_single_file",
        "file_index_path.exists",
        "Path",
        "self._filter_files_for_restoration",
        "files_to_restore.items",
        "logger.info",
        "relative_to",
        "backup_info.get",
        "json.load",
        "self._log_recovery_operation",
        "str",
        "append",
        "logger.error",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Restore files from backup.\n\nArgs:\n    file_patterns: List of file patterns to restore (all if None)\n    restore_to_original: Restore to original locations\n    target_directory: Alternative restore directory\n    \nReturns:\n    Dict with restoration results",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 316,
      "line_start": 221,
      "module": "app.backup.recovery",
      "name": "restore_files",
      "signature": "def restore_files(self, file_patterns: List[str] = None, restore_to_original: bool = True, target_directory: Optional[str] = None) -> Dict:"
    },
    "app.backup.recovery.test_recovery_procedures": {
      "calls": [
        "Path",
        "get",
        "self.validate_system_recovery",
        "self.restore_files",
        "logger.info",
        "str",
        "tempfile.TemporaryDirectory",
        "temp_target.mkdir",
        "logger.error",
        "datetime.utcnow",
        "all",
        "self.restore_database",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Test recovery procedures in a safe environment.\n\nReturns:\n    Dict with test results",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 502,
      "line_start": 437,
      "module": "app.backup.recovery",
      "name": "test_recovery_procedures",
      "signature": "def test_recovery_procedures(self) -> Dict:"
    },
    "app.backup.recovery.validate_system_recovery": {
      "calls": [
        "get",
        "str",
        "db_path.exists",
        "logger.error",
        "datetime.utcnow",
        "all",
        "self._validate_restored_files",
        "self._validate_system_structure",
        "self._validate_database",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Validate system state after recovery.\n\nReturns:\n    Dict with validation results",
      "file_path": "app/backup/recovery.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 435,
      "line_start": 393,
      "module": "app.backup.recovery",
      "name": "validate_system_recovery",
      "signature": "def validate_system_recovery(self) -> Dict:"
    },
    "app.backup.service.BackupService.__init__": {
      "calls": [
        "join",
        "RecoveryManager",
        "BackupOrchestrator",
        "self._setup_scheduling",
        "logger.info",
        "validate_backup_config",
        "str",
        "threading.Event",
        "self.config.get",
        "ValueError",
        "get_backup_config"
      ],
      "decorators": [],
      "docstring": "Initialize backup service.\n\nArgs:\n    config: Optional backup configuration (uses default if None)",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 76,
      "line_start": 36,
      "module": "app.backup.service",
      "name": "BackupService.__init__",
      "signature": "def __init__(self, config: Optional[Dict] = None):"
    },
    "app.backup.service.BackupService._run_scheduler": {
      "calls": [
        "schedule.run_pending",
        "logger.info",
        "self.shutdown_event.is_set",
        "logger.error",
        "time.sleep"
      ],
      "decorators": [],
      "docstring": "Run the backup scheduler in a separate thread.",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 380,
      "line_start": 368,
      "module": "app.backup.service",
      "name": "BackupService._run_scheduler",
      "signature": "def _run_scheduler(self):"
    },
    "app.backup.service.BackupService._scheduled_cleanup": {
      "calls": [
        "result.get",
        "logger.error",
        "logger.info",
        "self.cleanup_backups"
      ],
      "decorators": [],
      "docstring": "Perform scheduled backup cleanup.",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 410,
      "line_start": 402,
      "module": "app.backup.service",
      "name": "BackupService._scheduled_cleanup",
      "signature": "def _scheduled_cleanup(self):"
    },
    "app.backup.service.BackupService._scheduled_full_backup": {
      "calls": [
        "result.get",
        "self.create_manual_backup",
        "logger.info",
        "logger.error"
      ],
      "decorators": [],
      "docstring": "Perform scheduled full backup.",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 390,
      "line_start": 382,
      "module": "app.backup.service",
      "name": "BackupService._scheduled_full_backup",
      "signature": "def _scheduled_full_backup(self):"
    },
    "app.backup.service.BackupService._scheduled_incremental_backup": {
      "calls": [
        "logger.debug",
        "self.create_manual_backup",
        "logger.warning",
        "result.get"
      ],
      "decorators": [],
      "docstring": "Perform scheduled incremental backup.",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 400,
      "line_start": 392,
      "module": "app.backup.service",
      "name": "BackupService._scheduled_incremental_backup",
      "signature": "def _scheduled_incremental_backup(self):"
    },
    "app.backup.service.BackupService._setup_scheduling": {
      "calls": [
        "do",
        "logger.info",
        "self.config.get",
        "sunday.at",
        "scheduling_config.get",
        "minutes.do",
        "day.at",
        "schedule.every"
      ],
      "decorators": [],
      "docstring": "Setup backup scheduling based on configuration.",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 366,
      "line_start": 346,
      "module": "app.backup.service",
      "name": "BackupService._setup_scheduling",
      "signature": "def _setup_scheduling(self):"
    },
    "app.backup.service.BackupService._signal_handler": {
      "calls": [
        "self.stop",
        "logger.info",
        "sys.exit"
      ],
      "decorators": [],
      "docstring": "Handle shutdown signals gracefully.",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 416,
      "line_start": 412,
      "module": "app.backup.service",
      "name": "BackupService._signal_handler",
      "signature": "def _signal_handler(self, signum, frame):"
    },
    "app.backup.service.BackupService.cleanup_backups": {
      "calls": [
        "result.get",
        "logger.info",
        "str",
        "self.orchestrator.cleanup_expired_backups",
        "logger.error",
        "datetime.utcnow",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Perform backup cleanup operation.\n\nReturns:\n    Dict with cleanup results",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 236,
      "line_start": 205,
      "module": "app.backup.service",
      "name": "BackupService.cleanup_backups",
      "signature": "def cleanup_backups(self) -> Dict:"
    },
    "app.backup.service.BackupService.create_manual_backup": {
      "calls": [
        "result.get",
        "self.orchestrator.create_incremental_backup",
        "logger.info",
        "str",
        "logger.error",
        "datetime.utcnow",
        "ValueError",
        "self.orchestrator.create_full_backup",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Create a manual backup.\n\nArgs:\n    backup_type: Type of backup (\"full\" or \"incremental\")\n    upload_to_storage: Whether to upload to storage backends\n    \nReturns:\n    Dict with backup operation results",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 165,
      "line_start": 121,
      "module": "app.backup.service",
      "name": "BackupService.create_manual_backup",
      "signature": "def create_manual_backup(self, backup_type: str = \"full\", upload_to_storage: bool = True) -> Dict:"
    },
    "app.backup.service.BackupService.create_recovery": {
      "calls": [
        "result.get",
        "self.recovery_manager.restore_files",
        "logger.info",
        "str",
        "logger.error",
        "datetime.utcnow",
        "self.recovery_manager.restore_database",
        "self.recovery_manager.perform_full_system_recovery",
        "ValueError",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Perform recovery operation.\n\nArgs:\n    recovery_type: Type of recovery (\"database\", \"files\", or \"full\")\n    **kwargs: Additional recovery parameters\n    \nReturns:\n    Dict with recovery operation results",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 203,
      "line_start": 167,
      "module": "app.backup.service",
      "name": "BackupService.create_recovery",
      "signature": "def create_recovery(self, recovery_type: str = \"full\", **kwargs) -> Dict:"
    },
    "app.backup.service.BackupService.get_service_status": {
      "calls": [
        "self.orchestrator.get_backup_status",
        "int",
        "get",
        "len",
        "uptime.total_seconds",
        "self.recovery_manager.list_available_backups",
        "str",
        "self.config.get",
        "self.service_stats.copy",
        "logger.error",
        "datetime.utcnow",
        "datetime.fromisoformat",
        "self.service_stats.get"
      ],
      "decorators": [],
      "docstring": "Get comprehensive backup service status.\n\nReturns:\n    Dict with complete service status",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 274,
      "line_start": 238,
      "module": "app.backup.service",
      "name": "BackupService.get_service_status",
      "signature": "def get_service_status(self) -> Dict:"
    },
    "app.backup.service.BackupService.start": {
      "calls": [
        "get",
        "threading.Thread",
        "logger.warning",
        "logger.info",
        "self.config.get",
        "self.scheduler_thread.start",
        "datetime.utcnow",
        "signal.signal",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Start the backup service with scheduling.",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 99,
      "line_start": 78,
      "module": "app.backup.service",
      "name": "BackupService.start",
      "signature": "def start(self):"
    },
    "app.backup.service.BackupService.stop": {
      "calls": [
        "logger.warning",
        "self.shutdown_event.set",
        "logger.info",
        "self.scheduler_thread.is_alive",
        "self.orchestrator.stop",
        "self.scheduler_thread.join"
      ],
      "decorators": [],
      "docstring": "Stop the backup service gracefully.",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 119,
      "line_start": 101,
      "module": "app.backup.service",
      "name": "BackupService.stop",
      "signature": "def stop(self):"
    },
    "app.backup.service.BackupService.test_backup_system": {
      "calls": [
        "backend.get_backend_info",
        "storage_test_results.append",
        "get",
        "st.get",
        "logger.info",
        "str",
        "backend_info.get",
        "self.recovery_manager.test_recovery_procedures",
        "logger.error",
        "datetime.utcnow",
        "all",
        "backup_test.get",
        "self.create_manual_backup",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Test backup and recovery system functionality.\n\nReturns:\n    Dict with test results",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 344,
      "line_start": 276,
      "module": "app.backup.service",
      "name": "BackupService.test_backup_system",
      "signature": "def test_backup_system(self) -> Dict:"
    },
    "app.backup.service.__init__": {
      "calls": [
        "join",
        "RecoveryManager",
        "BackupOrchestrator",
        "self._setup_scheduling",
        "logger.info",
        "validate_backup_config",
        "str",
        "threading.Event",
        "self.config.get",
        "ValueError",
        "get_backup_config"
      ],
      "decorators": [],
      "docstring": "Initialize backup service.\n\nArgs:\n    config: Optional backup configuration (uses default if None)",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 76,
      "line_start": 36,
      "module": "app.backup.service",
      "name": "__init__",
      "signature": "def __init__(self, config: Optional[Dict] = None):"
    },
    "app.backup.service._run_scheduler": {
      "calls": [
        "schedule.run_pending",
        "logger.info",
        "self.shutdown_event.is_set",
        "logger.error",
        "time.sleep"
      ],
      "decorators": [],
      "docstring": "Run the backup scheduler in a separate thread.",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 380,
      "line_start": 368,
      "module": "app.backup.service",
      "name": "_run_scheduler",
      "signature": "def _run_scheduler(self):"
    },
    "app.backup.service._scheduled_cleanup": {
      "calls": [
        "result.get",
        "logger.error",
        "logger.info",
        "self.cleanup_backups"
      ],
      "decorators": [],
      "docstring": "Perform scheduled backup cleanup.",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 410,
      "line_start": 402,
      "module": "app.backup.service",
      "name": "_scheduled_cleanup",
      "signature": "def _scheduled_cleanup(self):"
    },
    "app.backup.service._scheduled_full_backup": {
      "calls": [
        "result.get",
        "self.create_manual_backup",
        "logger.info",
        "logger.error"
      ],
      "decorators": [],
      "docstring": "Perform scheduled full backup.",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 390,
      "line_start": 382,
      "module": "app.backup.service",
      "name": "_scheduled_full_backup",
      "signature": "def _scheduled_full_backup(self):"
    },
    "app.backup.service._scheduled_incremental_backup": {
      "calls": [
        "logger.debug",
        "self.create_manual_backup",
        "logger.warning",
        "result.get"
      ],
      "decorators": [],
      "docstring": "Perform scheduled incremental backup.",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 400,
      "line_start": 392,
      "module": "app.backup.service",
      "name": "_scheduled_incremental_backup",
      "signature": "def _scheduled_incremental_backup(self):"
    },
    "app.backup.service._setup_scheduling": {
      "calls": [
        "do",
        "logger.info",
        "self.config.get",
        "sunday.at",
        "scheduling_config.get",
        "minutes.do",
        "day.at",
        "schedule.every"
      ],
      "decorators": [],
      "docstring": "Setup backup scheduling based on configuration.",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 366,
      "line_start": 346,
      "module": "app.backup.service",
      "name": "_setup_scheduling",
      "signature": "def _setup_scheduling(self):"
    },
    "app.backup.service._signal_handler": {
      "calls": [
        "self.stop",
        "logger.info",
        "sys.exit"
      ],
      "decorators": [],
      "docstring": "Handle shutdown signals gracefully.",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 416,
      "line_start": 412,
      "module": "app.backup.service",
      "name": "_signal_handler",
      "signature": "def _signal_handler(self, signum, frame):"
    },
    "app.backup.service.cleanup_backups": {
      "calls": [
        "result.get",
        "logger.info",
        "str",
        "self.orchestrator.cleanup_expired_backups",
        "logger.error",
        "datetime.utcnow",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Perform backup cleanup operation.\n\nReturns:\n    Dict with cleanup results",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 236,
      "line_start": 205,
      "module": "app.backup.service",
      "name": "cleanup_backups",
      "signature": "def cleanup_backups(self) -> Dict:"
    },
    "app.backup.service.create_manual_backup": {
      "calls": [
        "result.get",
        "self.orchestrator.create_incremental_backup",
        "logger.info",
        "str",
        "logger.error",
        "datetime.utcnow",
        "ValueError",
        "self.orchestrator.create_full_backup",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Create a manual backup.\n\nArgs:\n    backup_type: Type of backup (\"full\" or \"incremental\")\n    upload_to_storage: Whether to upload to storage backends\n    \nReturns:\n    Dict with backup operation results",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 165,
      "line_start": 121,
      "module": "app.backup.service",
      "name": "create_manual_backup",
      "signature": "def create_manual_backup(self, backup_type: str = \"full\", upload_to_storage: bool = True) -> Dict:"
    },
    "app.backup.service.create_recovery": {
      "calls": [
        "result.get",
        "self.recovery_manager.restore_files",
        "logger.info",
        "str",
        "logger.error",
        "datetime.utcnow",
        "self.recovery_manager.restore_database",
        "self.recovery_manager.perform_full_system_recovery",
        "ValueError",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Perform recovery operation.\n\nArgs:\n    recovery_type: Type of recovery (\"database\", \"files\", or \"full\")\n    **kwargs: Additional recovery parameters\n    \nReturns:\n    Dict with recovery operation results",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 203,
      "line_start": 167,
      "module": "app.backup.service",
      "name": "create_recovery",
      "signature": "def create_recovery(self, recovery_type: str = \"full\", **kwargs) -> Dict:"
    },
    "app.backup.service.get_backup_service": {
      "calls": [
        "BackupService"
      ],
      "decorators": [],
      "docstring": "Get or create the global backup service instance.\n\nArgs:\n    config: Optional backup configuration\n    \nReturns:\n    BackupService instance",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 438,
      "line_start": 423,
      "module": "app.backup.service",
      "name": "get_backup_service",
      "signature": "def get_backup_service(config: Optional[Dict] = None) -> BackupService:"
    },
    "app.backup.service.get_service_status": {
      "calls": [
        "self.orchestrator.get_backup_status",
        "int",
        "get",
        "len",
        "uptime.total_seconds",
        "self.recovery_manager.list_available_backups",
        "str",
        "self.config.get",
        "self.service_stats.copy",
        "logger.error",
        "datetime.utcnow",
        "datetime.fromisoformat",
        "self.service_stats.get"
      ],
      "decorators": [],
      "docstring": "Get comprehensive backup service status.\n\nReturns:\n    Dict with complete service status",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 274,
      "line_start": 238,
      "module": "app.backup.service",
      "name": "get_service_status",
      "signature": "def get_service_status(self) -> Dict:"
    },
    "app.backup.service.start": {
      "calls": [
        "get",
        "threading.Thread",
        "logger.warning",
        "logger.info",
        "self.config.get",
        "self.scheduler_thread.start",
        "datetime.utcnow",
        "signal.signal",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Start the backup service with scheduling.",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 99,
      "line_start": 78,
      "module": "app.backup.service",
      "name": "start",
      "signature": "def start(self):"
    },
    "app.backup.service.start_backup_service": {
      "calls": [
        "get_backup_service",
        "service.start"
      ],
      "decorators": [],
      "docstring": "Start the backup service.\n\nArgs:\n    config: Optional backup configuration",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 449,
      "line_start": 441,
      "module": "app.backup.service",
      "name": "start_backup_service",
      "signature": "def start_backup_service(config: Optional[Dict] = None):"
    },
    "app.backup.service.stop": {
      "calls": [
        "logger.warning",
        "self.shutdown_event.set",
        "logger.info",
        "self.scheduler_thread.is_alive",
        "self.orchestrator.stop",
        "self.scheduler_thread.join"
      ],
      "decorators": [],
      "docstring": "Stop the backup service gracefully.",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 119,
      "line_start": 101,
      "module": "app.backup.service",
      "name": "stop",
      "signature": "def stop(self):"
    },
    "app.backup.service.stop_backup_service": {
      "calls": [
        "_backup_service.stop"
      ],
      "decorators": [],
      "docstring": "Stop the backup service.",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 457,
      "line_start": 452,
      "module": "app.backup.service",
      "name": "stop_backup_service",
      "signature": "def stop_backup_service():"
    },
    "app.backup.service.test_backup_system": {
      "calls": [
        "backend.get_backend_info",
        "storage_test_results.append",
        "get",
        "st.get",
        "logger.info",
        "str",
        "backend_info.get",
        "self.recovery_manager.test_recovery_procedures",
        "logger.error",
        "datetime.utcnow",
        "all",
        "backup_test.get",
        "self.create_manual_backup",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Test backup and recovery system functionality.\n\nReturns:\n    Dict with test results",
      "file_path": "app/backup/service.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 344,
      "line_start": 276,
      "module": "app.backup.service",
      "name": "test_backup_system",
      "signature": "def test_backup_system(self) -> Dict:"
    },
    "app.backup.storage.LocalStorageBackend.__init__": {
      "calls": [
        "Path",
        "logger.info",
        "resolve",
        "self.base_path.mkdir",
        "self.base_path.is_dir",
        "self.base_path.exists",
        "ValueError"
      ],
      "decorators": [],
      "docstring": "Initialize local storage backend.\n\nArgs:\n    base_path: Base directory for backup storage\n    create_directories: Automatically create directories as needed",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 91,
      "line_start": 71,
      "module": "app.backup.storage",
      "name": "LocalStorageBackend.__init__",
      "signature": "def __init__(self, base_path: str, create_directories: bool = True):"
    },
    "app.backup.storage.LocalStorageBackend.delete_file": {
      "calls": [
        "logger.warning",
        "logger.error",
        "target_path.unlink",
        "logger.debug",
        "target_path.exists"
      ],
      "decorators": [],
      "docstring": "Delete a file from local storage.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 144,
      "line_start": 129,
      "module": "app.backup.storage",
      "name": "LocalStorageBackend.delete_file",
      "signature": "def delete_file(self, remote_path: str) -> bool:"
    },
    "app.backup.storage.LocalStorageBackend.download_file": {
      "calls": [
        "Path",
        "shutil.copy2",
        "logger.error",
        "local_path.parent.mkdir",
        "source_path.exists",
        "logger.debug"
      ],
      "decorators": [],
      "docstring": "Download (copy) a file from local storage.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 127,
      "line_start": 110,
      "module": "app.backup.storage",
      "name": "LocalStorageBackend.download_file",
      "signature": "def download_file(self, remote_path: str, local_path: Path) -> bool:"
    },
    "app.backup.storage.LocalStorageBackend.file_exists": {
      "calls": [
        "target_path.exists",
        "target_path.is_file"
      ],
      "decorators": [],
      "docstring": "Check if a file exists in local storage.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 169,
      "line_start": 166,
      "module": "app.backup.storage",
      "name": "LocalStorageBackend.file_exists",
      "signature": "def file_exists(self, remote_path: str) -> bool:"
    },
    "app.backup.storage.LocalStorageBackend.get_backend_info": {
      "calls": [
        "file_path.stat",
        "self.base_path.rglob",
        "str",
        "shutil.disk_usage",
        "self.base_path.exists",
        "logger.error",
        "file_path.is_file"
      ],
      "decorators": [],
      "docstring": "Get local storage backend information.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 221,
      "line_start": 192,
      "module": "app.backup.storage",
      "name": "LocalStorageBackend.get_backend_info",
      "signature": "def get_backend_info(self) -> Dict:"
    },
    "app.backup.storage.LocalStorageBackend.get_file_info": {
      "calls": [
        "oct",
        "target_path.stat",
        "target_path.is_file",
        "logger.error",
        "target_path.exists"
      ],
      "decorators": [],
      "docstring": "Get file information from local storage.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 190,
      "line_start": 171,
      "module": "app.backup.storage",
      "name": "LocalStorageBackend.get_file_info",
      "signature": "def get_file_info(self, remote_path: str) -> Optional[Dict]:"
    },
    "app.backup.storage.LocalStorageBackend.list_files": {
      "calls": [
        "search_path.is_file",
        "file_path.relative_to",
        "search_path.rglob",
        "str",
        "sorted",
        "logger.error",
        "search_path.relative_to",
        "files.append",
        "file_path.is_file",
        "search_path.is_dir"
      ],
      "decorators": [],
      "docstring": "List files in local storage with optional prefix filter.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 164,
      "line_start": 146,
      "module": "app.backup.storage",
      "name": "LocalStorageBackend.list_files",
      "signature": "def list_files(self, prefix: str = \"\") -> List[str]:"
    },
    "app.backup.storage.LocalStorageBackend.upload_file": {
      "calls": [
        "Path",
        "shutil.copy2",
        "target_path.parent.mkdir",
        "logger.error",
        "logger.debug"
      ],
      "decorators": [],
      "docstring": "Upload (copy) a file to local storage.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 108,
      "line_start": 93,
      "module": "app.backup.storage",
      "name": "LocalStorageBackend.upload_file",
      "signature": "def upload_file(self, local_path: Path, remote_path: str) -> bool:"
    },
    "app.backup.storage.S3StorageBackend.__init__": {
      "calls": [
        "ImportError",
        "boto3.Session",
        "logger.info",
        "self.s3_client.head_bucket",
        "logger.error",
        "session.client"
      ],
      "decorators": [],
      "docstring": "Initialize S3 storage backend.\n\nArgs:\n    bucket_name: S3 bucket name\n    access_key: S3 access key ID\n    secret_key: S3 secret access key\n    endpoint_url: Custom S3 endpoint (for MinIO, etc.)\n    region: AWS region",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 272,
      "line_start": 232,
      "module": "app.backup.storage",
      "name": "S3StorageBackend.__init__",
      "signature": "def __init__(self, bucket_name: str, access_key: str, secret_key: str, endpoint_url: Optional[str] = None, region: str = \"us-east-1\"):"
    },
    "app.backup.storage.S3StorageBackend.delete_file": {
      "calls": [
        "logger.debug",
        "logger.error",
        "self.s3_client.delete_object"
      ],
      "decorators": [],
      "docstring": "Delete a file from S3 storage.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 324,
      "line_start": 311,
      "module": "app.backup.storage",
      "name": "S3StorageBackend.delete_file",
      "signature": "def delete_file(self, remote_path: str) -> bool:"
    },
    "app.backup.storage.S3StorageBackend.download_file": {
      "calls": [
        "Path",
        "self.s3_client.download_file",
        "str",
        "logger.error",
        "local_path.parent.mkdir",
        "logger.debug"
      ],
      "decorators": [],
      "docstring": "Download a file from S3 storage.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 309,
      "line_start": 292,
      "module": "app.backup.storage",
      "name": "S3StorageBackend.download_file",
      "signature": "def download_file(self, remote_path: str, local_path: Path) -> bool:"
    },
    "app.backup.storage.S3StorageBackend.file_exists": {
      "calls": [
        "logger.error",
        "self.s3_client.head_object"
      ],
      "decorators": [],
      "docstring": "Check if a file exists in S3 storage.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 352,
      "line_start": 343,
      "module": "app.backup.storage",
      "name": "S3StorageBackend.file_exists",
      "signature": "def file_exists(self, remote_path: str) -> bool:"
    },
    "app.backup.storage.S3StorageBackend.get_backend_info": {
      "calls": [
        "obj.get",
        "self.s3_client.get_paginator",
        "self.s3_client.head_bucket",
        "str",
        "logger.error",
        "paginator.paginate",
        "bucket_info.get"
      ],
      "decorators": [],
      "docstring": "Get S3 storage backend information.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 404,
      "line_start": 375,
      "module": "app.backup.storage",
      "name": "S3StorageBackend.get_backend_info",
      "signature": "def get_backend_info(self) -> Dict:"
    },
    "app.backup.storage.S3StorageBackend.get_file_info": {
      "calls": [
        "strip",
        "logger.error",
        "response.get",
        "self.s3_client.head_object"
      ],
      "decorators": [],
      "docstring": "Get file information from S3 storage.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 373,
      "line_start": 354,
      "module": "app.backup.storage",
      "name": "S3StorageBackend.get_file_info",
      "signature": "def get_file_info(self, remote_path: str) -> Optional[Dict]:"
    },
    "app.backup.storage.S3StorageBackend.list_files": {
      "calls": [
        "self.s3_client.get_paginator",
        "sorted",
        "logger.error",
        "paginator.paginate",
        "files.append"
      ],
      "decorators": [],
      "docstring": "List files in S3 storage with optional prefix filter.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 341,
      "line_start": 326,
      "module": "app.backup.storage",
      "name": "S3StorageBackend.list_files",
      "signature": "def list_files(self, prefix: str = \"\") -> List[str]:"
    },
    "app.backup.storage.S3StorageBackend.upload_file": {
      "calls": [
        "Path",
        "self.s3_client.upload_file",
        "str",
        "logger.error",
        "logger.debug"
      ],
      "decorators": [],
      "docstring": "Upload a file to S3 storage.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 290,
      "line_start": 274,
      "module": "app.backup.storage",
      "name": "S3StorageBackend.upload_file",
      "signature": "def upload_file(self, local_path: Path, remote_path: str) -> bool:"
    },
    "app.backup.storage.SFTPStorageBackend.__del__": {
      "calls": [
        "self.sftp_client.close",
        "self.ssh_client.close"
      ],
      "decorators": [],
      "docstring": "Cleanup SFTP connection.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 657,
      "line_start": 652,
      "module": "app.backup.storage",
      "name": "SFTPStorageBackend.__del__",
      "signature": "def __del__(self):"
    },
    "app.backup.storage.SFTPStorageBackend.__init__": {
      "calls": [
        "self._connect",
        "ImportError",
        "logger.info"
      ],
      "decorators": [],
      "docstring": "Initialize SFTP storage backend.\n\nArgs:\n    hostname: SFTP server hostname\n    username: SSH username\n    password: SSH password (if not using key authentication)\n    private_key_path: Path to SSH private key file\n    port: SSH port (default 22)\n    remote_base_path: Base directory on remote server",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 447,
      "line_start": 415,
      "module": "app.backup.storage",
      "name": "SFTPStorageBackend.__init__",
      "signature": "def __init__(self, hostname: str, username: str, password: Optional[str] = None, private_key_path: Optional[str] = None, port: int = 22, remote_base_path: str = \"/backups\"):"
    },
    "app.backup.storage.SFTPStorageBackend._connect": {
      "calls": [
        "self.ssh_client.open_sftp",
        "self.sftp_client.stat",
        "self.paramiko.SSHClient",
        "self.ssh_client.set_missing_host_key_policy",
        "logger.error",
        "self.ssh_client.connect",
        "self.sftp_client.mkdir",
        "self.paramiko.AutoAddPolicy",
        "self.paramiko.RSAKey.from_private_key_file"
      ],
      "decorators": [],
      "docstring": "Establish SSH/SFTP connection.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 482,
      "line_start": 449,
      "module": "app.backup.storage",
      "name": "SFTPStorageBackend._connect",
      "signature": "def _connect(self):"
    },
    "app.backup.storage.SFTPStorageBackend._ensure_connected": {
      "calls": [
        "self._connect"
      ],
      "decorators": [],
      "docstring": "Ensure SFTP connection is active.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 487,
      "line_start": 484,
      "module": "app.backup.storage",
      "name": "SFTPStorageBackend._ensure_connected",
      "signature": "def _ensure_connected(self):"
    },
    "app.backup.storage.SFTPStorageBackend._mkdir_p": {
      "calls": [
        "logger.error",
        "remote_path.split",
        "self.sftp_client.stat",
        "self.sftp_client.mkdir"
      ],
      "decorators": [],
      "docstring": "Create remote directory recursively.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 650,
      "line_start": 637,
      "module": "app.backup.storage",
      "name": "SFTPStorageBackend._mkdir_p",
      "signature": "def _mkdir_p(self, remote_path: str):"
    },
    "app.backup.storage.SFTPStorageBackend.delete_file": {
      "calls": [
        "logger.debug",
        "logger.error",
        "self._ensure_connected",
        "self.sftp_client.remove"
      ],
      "decorators": [],
      "docstring": "Delete a file from SFTP storage.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 536,
      "line_start": 524,
      "module": "app.backup.storage",
      "name": "SFTPStorageBackend.delete_file",
      "signature": "def delete_file(self, remote_path: str) -> bool:"
    },
    "app.backup.storage.SFTPStorageBackend.download_file": {
      "calls": [
        "Path",
        "self._ensure_connected",
        "self.sftp_client.get",
        "str",
        "logger.error",
        "local_path.parent.mkdir",
        "logger.debug"
      ],
      "decorators": [],
      "docstring": "Download a file from SFTP storage.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 522,
      "line_start": 508,
      "module": "app.backup.storage",
      "name": "SFTPStorageBackend.download_file",
      "signature": "def download_file(self, remote_path: str, local_path: Path) -> bool:"
    },
    "app.backup.storage.SFTPStorageBackend.file_exists": {
      "calls": [
        "logger.error",
        "self._ensure_connected",
        "self.sftp_client.stat",
        "self.paramiko.sftp_attr.S_ISDIR"
      ],
      "decorators": [],
      "docstring": "Check if a file exists in SFTP storage.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 577,
      "line_start": 565,
      "module": "app.backup.storage",
      "name": "SFTPStorageBackend.file_exists",
      "signature": "def file_exists(self, remote_path: str) -> bool:"
    },
    "app.backup.storage.SFTPStorageBackend.get_backend_info": {
      "calls": [
        "self._ensure_connected",
        "self.paramiko.sftp_attr.S_ISDIR",
        "str",
        "logger.error",
        "self.sftp_client.listdir_attr",
        "count_files"
      ],
      "decorators": [],
      "docstring": "Get SFTP storage backend information.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 635,
      "line_start": 598,
      "module": "app.backup.storage",
      "name": "SFTPStorageBackend.get_backend_info",
      "signature": "def get_backend_info(self) -> Dict:"
    },
    "app.backup.storage.SFTPStorageBackend.get_file_info": {
      "calls": [
        "self._ensure_connected",
        "self.paramiko.sftp_attr.S_ISDIR",
        "oct",
        "self.sftp_client.stat",
        "logger.error"
      ],
      "decorators": [],
      "docstring": "Get file information from SFTP storage.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 596,
      "line_start": 579,
      "module": "app.backup.storage",
      "name": "SFTPStorageBackend.get_file_info",
      "signature": "def get_file_info(self, remote_path: str) -> Optional[Dict]:"
    },
    "app.backup.storage.SFTPStorageBackend.list_files": {
      "calls": [
        "self._ensure_connected",
        "self.paramiko.sftp_attr.S_ISDIR",
        "relative_path.startswith",
        "len",
        "lstrip",
        "sorted",
        "logger.error",
        "self.sftp_client.listdir_attr",
        "files.append",
        "walk_remote_dir"
      ],
      "decorators": [],
      "docstring": "List files in SFTP storage with optional prefix filter.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 563,
      "line_start": 538,
      "module": "app.backup.storage",
      "name": "SFTPStorageBackend.list_files",
      "signature": "def list_files(self, prefix: str = \"\") -> List[str]:"
    },
    "app.backup.storage.SFTPStorageBackend.upload_file": {
      "calls": [
        "join",
        "Path",
        "self._ensure_connected",
        "self.sftp_client.put",
        "self._mkdir_p",
        "full_remote_path.split",
        "str",
        "logger.error",
        "logger.debug"
      ],
      "decorators": [],
      "docstring": "Upload a file to SFTP storage.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 506,
      "line_start": 489,
      "module": "app.backup.storage",
      "name": "SFTPStorageBackend.upload_file",
      "signature": "def upload_file(self, local_path: Path, remote_path: str) -> bool:"
    },
    "app.backup.storage.StorageBackend.delete_file": {
      "calls": [],
      "decorators": [
        "abstractmethod"
      ],
      "docstring": "Delete a file from the storage backend.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 40,
      "line_start": 38,
      "module": "app.backup.storage",
      "name": "StorageBackend.delete_file",
      "signature": "def delete_file(self, remote_path: str) -> bool:"
    },
    "app.backup.storage.StorageBackend.download_file": {
      "calls": [],
      "decorators": [
        "abstractmethod"
      ],
      "docstring": "Download a file from the storage backend.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 35,
      "line_start": 33,
      "module": "app.backup.storage",
      "name": "StorageBackend.download_file",
      "signature": "def download_file(self, remote_path: str, local_path: Path) -> bool:"
    },
    "app.backup.storage.StorageBackend.file_exists": {
      "calls": [],
      "decorators": [
        "abstractmethod"
      ],
      "docstring": "Check if a file exists in the storage backend.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 50,
      "line_start": 48,
      "module": "app.backup.storage",
      "name": "StorageBackend.file_exists",
      "signature": "def file_exists(self, remote_path: str) -> bool:"
    },
    "app.backup.storage.StorageBackend.get_backend_info": {
      "calls": [],
      "decorators": [
        "abstractmethod"
      ],
      "docstring": "Get storage backend information and status.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 60,
      "line_start": 58,
      "module": "app.backup.storage",
      "name": "StorageBackend.get_backend_info",
      "signature": "def get_backend_info(self) -> Dict:"
    },
    "app.backup.storage.StorageBackend.get_file_info": {
      "calls": [],
      "decorators": [
        "abstractmethod"
      ],
      "docstring": "Get file information (size, modified date, etc.).",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 55,
      "line_start": 53,
      "module": "app.backup.storage",
      "name": "StorageBackend.get_file_info",
      "signature": "def get_file_info(self, remote_path: str) -> Optional[Dict]:"
    },
    "app.backup.storage.StorageBackend.list_files": {
      "calls": [],
      "decorators": [
        "abstractmethod"
      ],
      "docstring": "List files in the storage backend with optional prefix filter.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 45,
      "line_start": 43,
      "module": "app.backup.storage",
      "name": "StorageBackend.list_files",
      "signature": "def list_files(self, prefix: str = \"\") -> List[str]:"
    },
    "app.backup.storage.StorageBackend.upload_file": {
      "calls": [],
      "decorators": [
        "abstractmethod"
      ],
      "docstring": "Upload a file to the storage backend.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 30,
      "line_start": 28,
      "module": "app.backup.storage",
      "name": "StorageBackend.upload_file",
      "signature": "def upload_file(self, local_path: Path, remote_path: str) -> bool:"
    },
    "app.backup.storage.__del__": {
      "calls": [
        "self.sftp_client.close",
        "self.ssh_client.close"
      ],
      "decorators": [],
      "docstring": "Cleanup SFTP connection.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 657,
      "line_start": 652,
      "module": "app.backup.storage",
      "name": "__del__",
      "signature": "def __del__(self):"
    },
    "app.backup.storage.__init__": {
      "calls": [
        "self._connect",
        "ImportError",
        "logger.info"
      ],
      "decorators": [],
      "docstring": "Initialize SFTP storage backend.\n\nArgs:\n    hostname: SFTP server hostname\n    username: SSH username\n    password: SSH password (if not using key authentication)\n    private_key_path: Path to SSH private key file\n    port: SSH port (default 22)\n    remote_base_path: Base directory on remote server",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 447,
      "line_start": 415,
      "module": "app.backup.storage",
      "name": "__init__",
      "signature": "def __init__(self, hostname: str, username: str, password: Optional[str] = None, private_key_path: Optional[str] = None, port: int = 22, remote_base_path: str = \"/backups\"):"
    },
    "app.backup.storage._connect": {
      "calls": [
        "self.ssh_client.open_sftp",
        "self.sftp_client.stat",
        "self.paramiko.SSHClient",
        "self.ssh_client.set_missing_host_key_policy",
        "logger.error",
        "self.ssh_client.connect",
        "self.sftp_client.mkdir",
        "self.paramiko.AutoAddPolicy",
        "self.paramiko.RSAKey.from_private_key_file"
      ],
      "decorators": [],
      "docstring": "Establish SSH/SFTP connection.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 482,
      "line_start": 449,
      "module": "app.backup.storage",
      "name": "_connect",
      "signature": "def _connect(self):"
    },
    "app.backup.storage._ensure_connected": {
      "calls": [
        "self._connect"
      ],
      "decorators": [],
      "docstring": "Ensure SFTP connection is active.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 487,
      "line_start": 484,
      "module": "app.backup.storage",
      "name": "_ensure_connected",
      "signature": "def _ensure_connected(self):"
    },
    "app.backup.storage._mkdir_p": {
      "calls": [
        "logger.error",
        "remote_path.split",
        "self.sftp_client.stat",
        "self.sftp_client.mkdir"
      ],
      "decorators": [],
      "docstring": "Create remote directory recursively.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 650,
      "line_start": 637,
      "module": "app.backup.storage",
      "name": "_mkdir_p",
      "signature": "def _mkdir_p(self, remote_path: str):"
    },
    "app.backup.storage.count_files": {
      "calls": [
        "logger.error",
        "self.sftp_client.listdir_attr",
        "count_files",
        "self.paramiko.sftp_attr.S_ISDIR"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 618,
      "line_start": 607,
      "module": "app.backup.storage",
      "name": "count_files",
      "signature": "def count_files(path):"
    },
    "app.backup.storage.delete_file": {
      "calls": [
        "logger.debug",
        "logger.error",
        "self._ensure_connected",
        "self.sftp_client.remove"
      ],
      "decorators": [],
      "docstring": "Delete a file from SFTP storage.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 536,
      "line_start": 524,
      "module": "app.backup.storage",
      "name": "delete_file",
      "signature": "def delete_file(self, remote_path: str) -> bool:"
    },
    "app.backup.storage.download_file": {
      "calls": [
        "Path",
        "self._ensure_connected",
        "self.sftp_client.get",
        "str",
        "logger.error",
        "local_path.parent.mkdir",
        "logger.debug"
      ],
      "decorators": [],
      "docstring": "Download a file from SFTP storage.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 522,
      "line_start": 508,
      "module": "app.backup.storage",
      "name": "download_file",
      "signature": "def download_file(self, remote_path: str, local_path: Path) -> bool:"
    },
    "app.backup.storage.file_exists": {
      "calls": [
        "logger.error",
        "self._ensure_connected",
        "self.sftp_client.stat",
        "self.paramiko.sftp_attr.S_ISDIR"
      ],
      "decorators": [],
      "docstring": "Check if a file exists in SFTP storage.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 577,
      "line_start": 565,
      "module": "app.backup.storage",
      "name": "file_exists",
      "signature": "def file_exists(self, remote_path: str) -> bool:"
    },
    "app.backup.storage.get_backend_info": {
      "calls": [
        "self._ensure_connected",
        "self.paramiko.sftp_attr.S_ISDIR",
        "str",
        "logger.error",
        "self.sftp_client.listdir_attr",
        "count_files"
      ],
      "decorators": [],
      "docstring": "Get SFTP storage backend information.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 635,
      "line_start": 598,
      "module": "app.backup.storage",
      "name": "get_backend_info",
      "signature": "def get_backend_info(self) -> Dict:"
    },
    "app.backup.storage.get_file_info": {
      "calls": [
        "self._ensure_connected",
        "self.paramiko.sftp_attr.S_ISDIR",
        "oct",
        "self.sftp_client.stat",
        "logger.error"
      ],
      "decorators": [],
      "docstring": "Get file information from SFTP storage.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 596,
      "line_start": 579,
      "module": "app.backup.storage",
      "name": "get_file_info",
      "signature": "def get_file_info(self, remote_path: str) -> Optional[Dict]:"
    },
    "app.backup.storage.list_files": {
      "calls": [
        "self._ensure_connected",
        "self.paramiko.sftp_attr.S_ISDIR",
        "relative_path.startswith",
        "len",
        "lstrip",
        "sorted",
        "logger.error",
        "self.sftp_client.listdir_attr",
        "files.append",
        "walk_remote_dir"
      ],
      "decorators": [],
      "docstring": "List files in SFTP storage with optional prefix filter.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 563,
      "line_start": 538,
      "module": "app.backup.storage",
      "name": "list_files",
      "signature": "def list_files(self, prefix: str = \"\") -> List[str]:"
    },
    "app.backup.storage.upload_file": {
      "calls": [
        "join",
        "Path",
        "self._ensure_connected",
        "self.sftp_client.put",
        "self._mkdir_p",
        "full_remote_path.split",
        "str",
        "logger.error",
        "logger.debug"
      ],
      "decorators": [],
      "docstring": "Upload a file to SFTP storage.",
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 506,
      "line_start": 489,
      "module": "app.backup.storage",
      "name": "upload_file",
      "signature": "def upload_file(self, local_path: Path, remote_path: str) -> bool:"
    },
    "app.backup.storage.walk_remote_dir": {
      "calls": [
        "self.paramiko.sftp_attr.S_ISDIR",
        "relative_path.startswith",
        "len",
        "lstrip",
        "logger.error",
        "self.sftp_client.listdir_attr",
        "files.append",
        "walk_remote_dir"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "app/backup/storage.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 556,
      "line_start": 545,
      "module": "app.backup.storage",
      "name": "walk_remote_dir",
      "signature": "def walk_remote_dir(path):"
    },
    "app.backup_api.backup_health_check": {
      "calls": [
        "status.get",
        "get",
        "get_backup_service_instance",
        "len",
        "str",
        "logger.error",
        "datetime.utcnow",
        "backup_service.get_service_status",
        "isoformat",
        "backup_router.get"
      ],
      "decorators": [
        "backup_router.get"
      ],
      "docstring": "Simple health check for backup system.\n\nReturns basic health status and connectivity information\nfor monitoring and alerting systems.",
      "file_path": "app/backup_api.py",
      "is_async": true,
      "is_endpoint": true,
      "line_end": 373,
      "line_start": 342,
      "module": "app.backup_api",
      "name": "backup_health_check",
      "signature": "async def backup_health_check():"
    },
    "app.backup_api.cleanup_backups": {
      "calls": [
        "backup_service.cleanup_backups",
        "HTTPException",
        "get_backup_service_instance",
        "str",
        "logger.error",
        "datetime.utcnow",
        "backup_router.post",
        "isoformat"
      ],
      "decorators": [
        "backup_router.post"
      ],
      "docstring": "Clean up expired backups.\n\nRemoves backups that have exceeded their retention period\nacross all backup types and storage backends.",
      "file_path": "app/backup_api.py",
      "is_async": true,
      "is_endpoint": true,
      "line_end": 288,
      "line_start": 267,
      "module": "app.backup_api",
      "name": "cleanup_backups",
      "signature": "async def cleanup_backups():"
    },
    "app.backup_api.create_backup": {
      "calls": [
        "result.get",
        "HTTPException",
        "isoformat",
        "get_backup_service_instance",
        "str",
        "BackupOperationResponse",
        "logger.error",
        "datetime.utcnow",
        "backup_router.post",
        "run_backup",
        "backup_service.create_manual_backup"
      ],
      "decorators": [
        "backup_router.post"
      ],
      "docstring": "Create a manual backup.\n\nSupports both full and incremental backups with optional\nupload to configured storage backends.",
      "file_path": "app/backup_api.py",
      "is_async": true,
      "is_endpoint": true,
      "line_end": 180,
      "line_start": 133,
      "module": "app.backup_api",
      "name": "create_backup",
      "signature": "async def create_backup( request: BackupRequest, background_tasks: BackgroundTasks ):"
    },
    "app.backup_api.create_recovery": {
      "calls": [
        "result.get",
        "HTTPException",
        "get_backup_service_instance",
        "backup_service.create_recovery",
        "str",
        "RecoveryOperationResponse",
        "logger.error",
        "datetime.utcnow",
        "backup_router.post",
        "isoformat"
      ],
      "decorators": [
        "backup_router.post"
      ],
      "docstring": "Perform system recovery from backups.\n\nSupports database recovery, file recovery, and full system recovery\nwith various configuration options.",
      "file_path": "app/backup_api.py",
      "is_async": true,
      "is_endpoint": true,
      "line_end": 238,
      "line_start": 184,
      "module": "app.backup_api",
      "name": "create_recovery",
      "signature": "async def create_recovery(request: RecoveryRequest):"
    },
    "app.backup_api.get_backup_service_instance": {
      "calls": [
        "HTTPException",
        "get_backup_service",
        "str",
        "logger.error"
      ],
      "decorators": [],
      "docstring": "Get backup service instance with error handling.",
      "file_path": "app/backup_api.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 99,
      "line_start": 90,
      "module": "app.backup_api",
      "name": "get_backup_service_instance",
      "signature": "def get_backup_service_instance() -> BackupService:"
    },
    "app.backup_api.get_backup_status": {
      "calls": [
        "HTTPException",
        "status.get",
        "get",
        "get_backup_service_instance",
        "str",
        "logger.error",
        "datetime.utcnow",
        "backup_service.get_service_status",
        "BackupStatusResponse",
        "isoformat",
        "backup_router.get"
      ],
      "decorators": [
        "backup_router.get"
      ],
      "docstring": "Get comprehensive backup system status.\n\nReturns current status of backup service, recent operations,\nconfiguration details, and system statistics.",
      "file_path": "app/backup_api.py",
      "is_async": true,
      "is_endpoint": true,
      "line_end": 129,
      "line_start": 105,
      "module": "app.backup_api",
      "name": "get_backup_status",
      "signature": "async def get_backup_status():"
    },
    "app.backup_api.initialize_backup_service": {
      "calls": [
        "get_backup_service",
        "logger.info",
        "logger.error"
      ],
      "decorators": [],
      "docstring": "Initialize backup service with default configuration.\nCall this during application startup.",
      "file_path": "app/backup_api.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 390,
      "line_start": 378,
      "module": "app.backup_api",
      "name": "initialize_backup_service",
      "signature": "def initialize_backup_service():"
    },
    "app.backup_api.list_available_backups": {
      "calls": [
        "HTTPException",
        "get_backup_service_instance",
        "str",
        "logger.error",
        "datetime.utcnow",
        "backup_service.recovery_manager.list_available_backups",
        "isoformat",
        "backup_router.get"
      ],
      "decorators": [
        "backup_router.get"
      ],
      "docstring": "List all available backups for recovery.\n\nReturns categorized list of database backups, WAL backups,\nfile backups, and full system backups.",
      "file_path": "app/backup_api.py",
      "is_async": true,
      "is_endpoint": true,
      "line_end": 263,
      "line_start": 242,
      "module": "app.backup_api",
      "name": "list_available_backups",
      "signature": "async def list_available_backups():"
    },
    "app.backup_api.run_backup": {
      "calls": [
        "backup_service.create_manual_backup"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "app/backup_api.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 151,
      "line_start": 147,
      "module": "app.backup_api",
      "name": "run_backup",
      "signature": "def run_backup():"
    },
    "app.backup_api.shutdown_backup_service": {
      "calls": [
        "get_backup_service",
        "backup_service.stop",
        "logger.error",
        "logger.info"
      ],
      "decorators": [],
      "docstring": "Gracefully shutdown backup service.\nCall this during application shutdown.",
      "file_path": "app/backup_api.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 425,
      "line_start": 415,
      "module": "app.backup_api",
      "name": "shutdown_backup_service",
      "signature": "def shutdown_backup_service():"
    },
    "app.backup_api.start_backup_service_if_configured": {
      "calls": [
        "get",
        "backup_service.start",
        "get_backup_service",
        "logger.info",
        "logger.error",
        "backup_service.get_service_status",
        "status.get"
      ],
      "decorators": [],
      "docstring": "Start backup service if properly configured.\nCall this during application startup if auto-start is desired.",
      "file_path": "app/backup_api.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 412,
      "line_start": 393,
      "module": "app.backup_api",
      "name": "start_backup_service_if_configured",
      "signature": "def start_backup_service_if_configured():"
    },
    "app.backup_api.test_backup_system": {
      "calls": [
        "HTTPException",
        "get_backup_service_instance",
        "backup_service.test_backup_system",
        "str",
        "logger.error",
        "datetime.utcnow",
        "backup_router.post",
        "isoformat"
      ],
      "decorators": [
        "backup_router.post"
      ],
      "docstring": "Test backup and recovery system functionality.\n\nPerforms comprehensive testing of backup creation, recovery procedures,\nand storage backend connectivity without affecting production data.",
      "file_path": "app/backup_api.py",
      "is_async": true,
      "is_endpoint": true,
      "line_end": 313,
      "line_start": 292,
      "module": "app.backup_api",
      "name": "test_backup_system",
      "signature": "async def test_backup_system():"
    },
    "app.backup_api.validate_system_recovery": {
      "calls": [
        "HTTPException",
        "get_backup_service_instance",
        "backup_service.recovery_manager.validate_system_recovery",
        "str",
        "logger.error",
        "datetime.utcnow",
        "backup_router.post",
        "isoformat"
      ],
      "decorators": [
        "backup_router.post"
      ],
      "docstring": "Validate system state after recovery operations.\n\nChecks database integrity, file consistency, and overall\nsystem health to ensure recovery was successful.",
      "file_path": "app/backup_api.py",
      "is_async": true,
      "is_endpoint": true,
      "line_end": 338,
      "line_start": 317,
      "module": "app.backup_api",
      "name": "validate_system_recovery",
      "signature": "async def validate_system_recovery():"
    },
    "app.main.ConnectionManager.__init__": {
      "calls": [],
      "decorators": [],
      "docstring": null,
      "file_path": "app/main.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 348,
      "line_start": 347,
      "module": "app.main",
      "name": "ConnectionManager.__init__",
      "signature": "def __init__(self):"
    },
    "app.main.ConnectionManager.connect": {
      "calls": [
        "append",
        "websocket.accept"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "app/main.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 354,
      "line_start": 350,
      "module": "app.main",
      "name": "ConnectionManager.connect",
      "signature": "async def connect(self, websocket: WebSocket, job_id: str):"
    },
    "app.main.ConnectionManager.disconnect": {
      "calls": [
        "remove"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "app/main.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 360,
      "line_start": 356,
      "module": "app.main",
      "name": "ConnectionManager.disconnect",
      "signature": "def disconnect(self, websocket: WebSocket, job_id: str):"
    },
    "app.main.ConnectionManager.send_progress": {
      "calls": [
        "connection.send_json",
        "remove"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "app/main.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 368,
      "line_start": 362,
      "module": "app.main",
      "name": "ConnectionManager.send_progress",
      "signature": "async def send_progress(self, job_id: str, data: dict):"
    },
    "app.main.__init__": {
      "calls": [],
      "decorators": [],
      "docstring": null,
      "file_path": "app/main.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 348,
      "line_start": 347,
      "module": "app.main",
      "name": "__init__",
      "signature": "def __init__(self):"
    },
    "app.main.admin_list_jobs": {
      "calls": [
        "create_validation_error_response",
        "HTTPException",
        "filters.apply_filters",
        "app.get",
        "JobPaginator",
        "security_logger.log_attack_attempt",
        "JobQueryFilters",
        "paginator.paginate_jobs",
        "str",
        "request.headers.get",
        "db.query",
        "PaginatedJobsResponseSchema",
        "JobResponseSchema",
        "dict",
        "Depends",
        "PaginationRequest"
      ],
      "decorators": [
        "app.get"
      ],
      "docstring": "Admin endpoint: List all jobs with advanced pagination and filtering.\n\nProvides comprehensive access to all jobs in the system with detailed\nfiltering and pagination capabilities for administrative purposes.",
      "file_path": "app/main.py",
      "is_async": true,
      "is_endpoint": true,
      "line_end": 1331,
      "line_start": 1227,
      "module": "app.main",
      "name": "admin_list_jobs",
      "signature": "async def admin_list_jobs("
    },
    "app.main.change_password": {
      "calls": [
        "create_validation_error_response",
        "HTTPException",
        "security_logger.log_attack_attempt",
        "logger.info",
        "request.headers.get",
        "security_logger.log_authentication_failure",
        "app.post",
        "db.commit",
        "get_password_hash",
        "Depends",
        "verify_password"
      ],
      "decorators": [
        "app.post"
      ],
      "docstring": "Secure password change with validation",
      "file_path": "app/main.py",
      "is_async": true,
      "is_endpoint": true,
      "line_end": 710,
      "line_start": 668,
      "module": "app.main",
      "name": "change_password",
      "signature": "async def change_password( request: Request, password_data: PasswordChangeSchema, current_user: User = Depends(get_current_user), db: Session = Depends(get_db) ):"
    },
    "app.main.connect": {
      "calls": [
        "append",
        "websocket.accept"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "app/main.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 354,
      "line_start": 350,
      "module": "app.main",
      "name": "connect",
      "signature": "async def connect(self, websocket: WebSocket, job_id: str):"
    },
    "app.main.create_access_token": {
      "calls": [
        "timedelta",
        "datetime.utcnow",
        "to_encode.update",
        "jwt.encode",
        "data.copy"
      ],
      "decorators": [],
      "docstring": "Create a JWT access token.",
      "file_path": "app/main.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 398,
      "line_start": 389,
      "module": "app.main",
      "name": "create_access_token",
      "signature": "def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:"
    },
    "app.main.create_transcription": {
      "calls": [
        "validate_uploaded_file",
        "sanitize_filename",
        "File",
        "uuid.uuid4",
        "JobResponseSchema",
        "create_validation_error_response",
        "logger.warning",
        "len",
        "open",
        "f.write",
        "request.headers.get",
        "validate_request_size",
        "int",
        "HTTPException",
        "Job",
        "logger.info",
        "time.time",
        "hasattr",
        "Depends",
        "security_logger.log_attack_attempt",
        "db.add",
        "str",
        "logger.error",
        "app.post",
        "db.commit",
        "transcribe_audio.delay",
        "FileUploadSchema"
      ],
      "decorators": [
        "app.post"
      ],
      "docstring": "Secure audio file upload and transcription with comprehensive validation",
      "file_path": "app/main.py",
      "is_async": true,
      "is_endpoint": true,
      "line_end": 1060,
      "line_start": 929,
      "module": "app.main",
      "name": "create_transcription",
      "signature": "async def create_transcription( request: Request, file: UploadFile = File(...), model: str = \"small\", language: Optional[str] = None, current_user: User = Depends(get_current_user), db: Session = Depends(get_db) ):"
    },
    "app.main.create_user": {
      "calls": [
        "db.refresh",
        "db.add",
        "User",
        "db.commit",
        "get_password_hash"
      ],
      "decorators": [],
      "docstring": "Create a new user.",
      "file_path": "app/main.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 416,
      "line_start": 404,
      "module": "app.main",
      "name": "create_user",
      "signature": "def create_user(db: Session, username: str, password: str, role: str = \"user\", must_change_password: bool = False) -> User:"
    },
    "app.main.delete_job": {
      "calls": [
        "create_validation_error_response",
        "HTTPException",
        "upload_path.unlink",
        "security_logger.log_attack_attempt",
        "logger.info",
        "first",
        "filter",
        "app.delete",
        "request.headers.get",
        "db.query",
        "transcript_path.exists",
        "db.delete",
        "JobIdSchema",
        "transcript_path.unlink",
        "db.commit",
        "upload_path.exists",
        "Depends"
      ],
      "decorators": [
        "app.delete"
      ],
      "docstring": "Securely delete a job and its files with validation",
      "file_path": "app/main.py",
      "is_async": true,
      "is_endpoint": true,
      "line_end": 1379,
      "line_start": 1334,
      "module": "app.main",
      "name": "delete_job",
      "signature": "async def delete_job( request: Request, job_id: str, current_user: User = Depends(get_current_user), db: Session = Depends(get_db) ):"
    },
    "app.main.disconnect": {
      "calls": [
        "remove"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "app/main.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 360,
      "line_start": 356,
      "module": "app.main",
      "name": "disconnect",
      "signature": "def disconnect(self, websocket: WebSocket, job_id: str):"
    },
    "app.main.download_transcript": {
      "calls": [
        "HTTPException",
        "app.get",
        "open",
        "job.original_filename.rsplit",
        "first",
        "f.write",
        "FileResponse",
        "filter",
        "db.query",
        "Depends",
        "json.dumps"
      ],
      "decorators": [
        "app.get"
      ],
      "docstring": "Download completed transcript",
      "file_path": "app/main.py",
      "is_async": true,
      "is_endpoint": true,
      "line_end": 1117,
      "line_start": 1083,
      "module": "app.main",
      "name": "download_transcript",
      "signature": "async def download_transcript(job_id: str, format: str = \"txt\", current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):"
    },
    "app.main.get_cors_origins": {
      "calls": [
        "origin.strip",
        "dev_origins.extend"
      ],
      "decorators": [],
      "docstring": "Get CORS origins based on environment and configuration.",
      "file_path": "app/main.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 103,
      "line_start": 85,
      "module": "app.main",
      "name": "get_cors_origins",
      "signature": "def get_cors_origins():"
    },
    "app.main.get_current_user": {
      "calls": [
        "HTTPException",
        "get_user_by_username",
        "payload.get",
        "Depends",
        "jwt.decode"
      ],
      "decorators": [],
      "docstring": "Get current user from JWT token.",
      "file_path": "app/main.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 463,
      "line_start": 443,
      "module": "app.main",
      "name": "get_current_user",
      "signature": "async def get_current_user(token: str = Depends(get_token), db: Session = Depends(get_db)) -> User:"
    },
    "app.main.get_db": {
      "calls": [
        "SessionLocal",
        "db.close"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "app/main.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 378,
      "line_start": 373,
      "module": "app.main",
      "name": "get_db",
      "signature": "def get_db():"
    },
    "app.main.get_job": {
      "calls": [
        "HTTPException",
        "app.get",
        "bool",
        "first",
        "filter",
        "db.query",
        "Depends",
        "job.created_at.isoformat",
        "job.completed_at.isoformat"
      ],
      "decorators": [
        "app.get"
      ],
      "docstring": "Get job status and details",
      "file_path": "app/main.py",
      "is_async": true,
      "is_endpoint": true,
      "line_end": 1080,
      "line_start": 1063,
      "module": "app.main",
      "name": "get_job",
      "signature": "async def get_job(job_id: str, current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):"
    },
    "app.main.get_metrics": {
      "calls": [
        "HTTPException",
        "count",
        "app.get",
        "psutil.disk_usage",
        "filter",
        "str",
        "psutil.cpu_percent",
        "logger.error",
        "db.query",
        "datetime.utcnow",
        "Depends",
        "psutil.virtual_memory",
        "isoformat"
      ],
      "decorators": [
        "app.get"
      ],
      "docstring": "Detailed system metrics for monitoring",
      "file_path": "app/main.py",
      "is_async": true,
      "is_endpoint": true,
      "line_end": 785,
      "line_start": 731,
      "module": "app.main",
      "name": "get_metrics",
      "signature": "async def get_metrics(current_user: User = Depends(require_admin), db: Session = Depends(get_db)):"
    },
    "app.main.get_password_hash": {
      "calls": [
        "pwd_context.hash"
      ],
      "decorators": [],
      "docstring": "Hash a password.",
      "file_path": "app/main.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 387,
      "line_start": 385,
      "module": "app.main",
      "name": "get_password_hash",
      "signature": "def get_password_hash(password: str) -> str:"
    },
    "app.main.get_stats": {
      "calls": [
        "HTTPException",
        "count",
        "app.get",
        "filter",
        "str",
        "logger.error",
        "db.query",
        "datetime.utcnow",
        "Depends",
        "isoformat"
      ],
      "decorators": [
        "app.get"
      ],
      "docstring": "User-accessible statistics",
      "file_path": "app/main.py",
      "is_async": true,
      "is_endpoint": true,
      "line_end": 809,
      "line_start": 788,
      "module": "app.main",
      "name": "get_stats",
      "signature": "async def get_stats(current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):"
    },
    "app.main.get_token": {
      "calls": [
        "HTTPException",
        "get_authorization_scheme_param",
        "websocket.query_params.get",
        "scheme.lower",
        "request.headers.get",
        "websocket.headers.get"
      ],
      "decorators": [],
      "docstring": "Get JWT token from request or websocket.",
      "file_path": "app/main.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 441,
      "line_start": 418,
      "module": "app.main",
      "name": "get_token",
      "signature": "async def get_token(request: Request = None, websocket: WebSocket = None) -> str:"
    },
    "app.main.get_user_by_username": {
      "calls": [
        "db.query",
        "filter",
        "first"
      ],
      "decorators": [],
      "docstring": "Get user by username.",
      "file_path": "app/main.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 402,
      "line_start": 400,
      "module": "app.main",
      "name": "get_user_by_username",
      "signature": "def get_user_by_username(db: Session, username: str) -> Optional[User]:"
    },
    "app.main.health_check": {
      "calls": [
        "HTTPException",
        "HealthResponseSchema",
        "db.execute",
        "app.get",
        "str",
        "logger.error",
        "datetime.utcnow",
        "Depends",
        "text"
      ],
      "decorators": [
        "app.get"
      ],
      "docstring": "Secure health check endpoint with validation",
      "file_path": "app/main.py",
      "is_async": true,
      "is_endpoint": true,
      "line_end": 728,
      "line_start": 714,
      "module": "app.main",
      "name": "health_check",
      "signature": "async def health_check(db: Session = Depends(get_db)):"
    },
    "app.main.lifespan": {
      "calls": [
        "Base.metadata.create_all",
        "logging.info"
      ],
      "decorators": [
        "asynccontextmanager"
      ],
      "docstring": null,
      "file_path": "app/main.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 482,
      "line_start": 476,
      "module": "app.main",
      "name": "lifespan",
      "signature": "async def lifespan(app: FastAPI):"
    },
    "app.main.list_jobs": {
      "calls": [
        "create_validation_error_response",
        "HTTPException",
        "filters.apply_filters",
        "app.get",
        "JobPaginator",
        "security_logger.log_attack_attempt",
        "JobQueryFilters",
        "paginator.paginate_jobs",
        "str",
        "request.headers.get",
        "db.query",
        "PaginatedJobsResponseSchema",
        "JobResponseSchema",
        "dict",
        "Depends",
        "PaginationRequest"
      ],
      "decorators": [
        "app.get"
      ],
      "docstring": "List jobs with advanced pagination and filtering.\n\nSupports cursor-based pagination for efficient navigation through large datasets.\nIncludes comprehensive filtering options and optional total count.",
      "file_path": "app/main.py",
      "is_async": true,
      "is_endpoint": true,
      "line_end": 1224,
      "line_start": 1120,
      "module": "app.main",
      "name": "list_jobs",
      "signature": "async def list_jobs("
    },
    "app.main.login": {
      "calls": [
        "create_validation_error_response",
        "HTTPException",
        "security_logger.log_attack_attempt",
        "get_user_by_username",
        "TokenResponseSchema",
        "logger.info",
        "UserLoginSchema",
        "str",
        "request.headers.get",
        "security_logger.log_authentication_failure",
        "app.post",
        "Depends",
        "create_access_token",
        "verify_password"
      ],
      "decorators": [
        "app.post"
      ],
      "docstring": "Secure login endpoint with validation and security logging",
      "file_path": "app/main.py",
      "is_async": true,
      "is_endpoint": true,
      "line_end": 602,
      "line_start": 547,
      "module": "app.main",
      "name": "login",
      "signature": "async def login( request: Request, form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db) ):"
    },
    "app.main.monitoring_dashboard": {
      "calls": [
        "Depends",
        "HTMLResponse",
        "app.get"
      ],
      "decorators": [
        "app.get"
      ],
      "docstring": "Simple monitoring dashboard (HTML)",
      "file_path": "app/main.py",
      "is_async": true,
      "is_endpoint": true,
      "line_end": 926,
      "line_start": 812,
      "module": "app.main",
      "name": "monitoring_dashboard",
      "signature": "async def monitoring_dashboard(current_user: User = Depends(require_admin)):"
    },
    "app.main.process_transcription": {
      "calls": [
        "SessionLocal",
        "db.close",
        "asyncio.sleep",
        "first",
        "str",
        "manager.send_progress",
        "filter",
        "db.query",
        "datetime.utcnow",
        "db.commit"
      ],
      "decorators": [],
      "docstring": "Process transcription job",
      "file_path": "app/main.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 1459,
      "line_start": 1405,
      "module": "app.main",
      "name": "process_transcription",
      "signature": "async def process_transcription(job_id: str):"
    },
    "app.main.register": {
      "calls": [
        "create_validation_error_response",
        "HTTPException",
        "security_logger.log_suspicious_activity",
        "hasattr",
        "registration_data.dict",
        "security_logger.log_attack_attempt",
        "get_user_by_username",
        "TokenResponseSchema",
        "logger.info",
        "str",
        "request.headers.get",
        "create_user",
        "app.post",
        "Depends",
        "create_access_token"
      ],
      "decorators": [
        "app.post"
      ],
      "docstring": "Secure user registration with comprehensive validation",
      "file_path": "app/main.py",
      "is_async": true,
      "is_endpoint": true,
      "line_end": 665,
      "line_start": 605,
      "module": "app.main",
      "name": "register",
      "signature": "async def register( request: Request, registration_data: UserRegistrationSchema, db: Session = Depends(get_db) ):"
    },
    "app.main.require_admin": {
      "calls": [
        "HTTPException",
        "Depends"
      ],
      "decorators": [],
      "docstring": "Require admin role.",
      "file_path": "app/main.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 472,
      "line_start": 465,
      "module": "app.main",
      "name": "require_admin",
      "signature": "def require_admin(user: User = Depends(get_current_user)) -> User:"
    },
    "app.main.root": {
      "calls": [
        "app.get"
      ],
      "decorators": [
        "app.get"
      ],
      "docstring": "Health check and basic info - redirect to /health for detailed status",
      "file_path": "app/main.py",
      "is_async": true,
      "is_endpoint": true,
      "line_end": 543,
      "line_start": 531,
      "module": "app.main",
      "name": "root",
      "signature": "async def root():"
    },
    "app.main.sanitize_filename": {
      "calls": [
        "Path",
        "join",
        "replace",
        "len",
        "safe_name.replace",
        "safe_name.rsplit",
        "c.isalnum"
      ],
      "decorators": [],
      "docstring": "Create a safe filename for storage.",
      "file_path": "app/main.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 292,
      "line_start": 269,
      "module": "app.main",
      "name": "sanitize_filename",
      "signature": "def sanitize_filename(filename: str) -> str:"
    },
    "app.main.send_progress": {
      "calls": [
        "connection.send_json",
        "remove"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "app/main.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 368,
      "line_start": 362,
      "module": "app.main",
      "name": "send_progress",
      "signature": "async def send_progress(self, job_id: str, data: dict):"
    },
    "app.main.setup_logging": {
      "calls": [
        "logging.getLogger",
        "LOG_FORMAT.lower",
        "logging.config.dictConfig"
      ],
      "decorators": [],
      "docstring": "Configure structured logging based on environment.",
      "file_path": "app/main.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 178,
      "line_start": 121,
      "module": "app.main",
      "name": "setup_logging",
      "signature": "def setup_logging():"
    },
    "app.main.validate_uploaded_file": {
      "calls": [
        "hexdigest",
        "join",
        "any",
        "file.content_type.startswith",
        "hashlib.sha256",
        "Path",
        "suffix.lower",
        "len",
        "str",
        "sorted",
        "file.read",
        "magic.from_buffer",
        "isinstance",
        "logging.info",
        "content_start.startswith",
        "FileValidationError",
        "file.seek"
      ],
      "decorators": [],
      "docstring": "Comprehensive file validation for security.\n\nValidates:\n- File size limits\n- Filename safety\n- MIME type verification\n- Magic number validation\n- File extension allowlist\n\nReturns:\n    bytes: File content if validation passes\n    \nRaises:\n    FileValidationError: If validation fails",
      "file_path": "app/main.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 267,
      "line_start": 187,
      "module": "app.main",
      "name": "validate_uploaded_file",
      "signature": "async def validate_uploaded_file(file: UploadFile) -> bytes:"
    },
    "app.main.verify_password": {
      "calls": [
        "pwd_context.verify"
      ],
      "decorators": [],
      "docstring": "Verify a plain password against a hashed password.",
      "file_path": "app/main.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 383,
      "line_start": 381,
      "module": "app.main",
      "name": "verify_password",
      "signature": "def verify_password(plain_password: str, hashed_password: str) -> bool:"
    },
    "app.main.websocket_job_progress": {
      "calls": [
        "get_token",
        "app.websocket",
        "websocket.receive_text",
        "manager.disconnect",
        "websocket.close",
        "manager.connect"
      ],
      "decorators": [
        "app.websocket"
      ],
      "docstring": "Real-time job progress updates",
      "file_path": "app/main.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 1402,
      "line_start": 1382,
      "module": "app.main",
      "name": "websocket_job_progress",
      "signature": "async def websocket_job_progress(websocket: WebSocket, job_id: str):"
    },
    "app.pagination.CursorGenerator.generate_cursor": {
      "calls": [
        "base64.b64encode",
        "json.dumps",
        "decode",
        "str",
        "datetime.utcnow",
        "cursor_json.encode",
        "isoformat"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Generate a cursor for pagination.",
      "file_path": "app/pagination.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 160,
      "line_start": 142,
      "module": "app.pagination",
      "name": "CursorGenerator.generate_cursor",
      "signature": "def generate_cursor( item_id: str, sort_field_value: Any, sort_by: str, sort_order: str ) -> str:"
    },
    "app.pagination.CursorGenerator.parse_cursor": {
      "calls": [
        "json.loads",
        "decode",
        "ValueError",
        "base64.b64decode"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Parse a pagination cursor.",
      "file_path": "app/pagination.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 169,
      "line_start": 163,
      "module": "app.pagination",
      "name": "CursorGenerator.parse_cursor",
      "signature": "def parse_cursor(cursor: str) -> Dict[str, Any]:"
    },
    "app.pagination.JobPaginator.__init__": {
      "calls": [],
      "decorators": [],
      "docstring": null,
      "file_path": "app/pagination.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 176,
      "line_start": 175,
      "module": "app.pagination",
      "name": "JobPaginator.__init__",
      "signature": "def __init__(self, db: Session):"
    },
    "app.pagination.JobPaginator.paginate_jobs": {
      "calls": [
        "asc",
        "getattr",
        "cursor_data.get",
        "base_query.order_by",
        "base_query.count",
        "len",
        "base_query.limit",
        "CursorGenerator.generate_cursor",
        "or_",
        "and_",
        "PaginationMetadata",
        "desc",
        "all",
        "base_query.filter",
        "CursorGenerator.parse_cursor"
      ],
      "decorators": [],
      "docstring": "Paginate job results with cursor-based navigation.\n\nArgs:\n    base_query: Base SQLAlchemy query to paginate\n    pagination: Pagination parameters\n    user_id: Optional user ID for filtering (not implemented in current schema)\n\nReturns:\n    PaginatedResponse with jobs and pagination metadata",
      "file_path": "app/pagination.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 282,
      "line_start": 178,
      "module": "app.pagination",
      "name": "JobPaginator.paginate_jobs",
      "signature": "def paginate_jobs( self, base_query: Query, pagination: PaginationRequest, user_id: Optional[str] = None ) -> PaginatedResponse:"
    },
    "app.pagination.JobQueryFilters.apply_filters": {
      "calls": [
        "query.filter"
      ],
      "decorators": [],
      "docstring": "Apply filters to a SQLAlchemy query.",
      "file_path": "app/pagination.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 397,
      "line_start": 363,
      "module": "app.pagination",
      "name": "JobQueryFilters.apply_filters",
      "signature": "def apply_filters(self, query: Query) -> Query:"
    },
    "app.pagination.JobQueryFilters.validate_model_used": {
      "calls": [
        "field_validator",
        "join",
        "ValueError",
        "sanitize_string"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": "Validate Whisper model name.",
      "file_path": "app/pagination.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 361,
      "line_start": 351,
      "module": "app.pagination",
      "name": "JobQueryFilters.validate_model_used",
      "signature": "def validate_model_used(cls, v: Optional[str]) -> Optional[str]:"
    },
    "app.pagination.JobQueryFilters.validate_status": {
      "calls": [
        "field_validator",
        "join",
        "ValueError",
        "sanitize_string"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": "Validate job status.",
      "file_path": "app/pagination.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 347,
      "line_start": 337,
      "module": "app.pagination",
      "name": "JobQueryFilters.validate_status",
      "signature": "def validate_status(cls, v: Optional[str]) -> Optional[str]:"
    },
    "app.pagination.PaginationRequest.validate_cursor": {
      "calls": [
        "base64.b64decode",
        "field_validator",
        "total_seconds",
        "decode",
        "datetime.utcnow",
        "datetime.fromisoformat",
        "all",
        "ValueError",
        "sanitize_string",
        "json.loads"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": "Validate and decode pagination cursor.",
      "file_path": "app/pagination.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 87,
      "line_start": 61,
      "module": "app.pagination",
      "name": "PaginationRequest.validate_cursor",
      "signature": "def validate_cursor(cls, v: Optional[str]) -> Optional[str]:"
    },
    "app.pagination.PaginationRequest.validate_sort_by": {
      "calls": [
        "field_validator",
        "join",
        "ValueError",
        "sanitize_string"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": "Validate sort field.",
      "file_path": "app/pagination.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 104,
      "line_start": 91,
      "module": "app.pagination",
      "name": "PaginationRequest.validate_sort_by",
      "signature": "def validate_sort_by(cls, v: str) -> str:"
    },
    "app.pagination.PaginationRequest.validate_sort_order": {
      "calls": [
        "field_validator",
        "lower",
        "ValueError",
        "sanitize_string"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": "Validate sort order.",
      "file_path": "app/pagination.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 115,
      "line_start": 108,
      "module": "app.pagination",
      "name": "PaginationRequest.validate_sort_order",
      "signature": "def validate_sort_order(cls, v: str) -> str:"
    },
    "app.pagination.__init__": {
      "calls": [],
      "decorators": [],
      "docstring": null,
      "file_path": "app/pagination.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 176,
      "line_start": 175,
      "module": "app.pagination",
      "name": "__init__",
      "signature": "def __init__(self, db: Session):"
    },
    "app.pagination.apply_filters": {
      "calls": [
        "query.filter"
      ],
      "decorators": [],
      "docstring": "Apply filters to a SQLAlchemy query.",
      "file_path": "app/pagination.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 397,
      "line_start": 363,
      "module": "app.pagination",
      "name": "apply_filters",
      "signature": "def apply_filters(self, query: Query) -> Query:"
    },
    "app.pagination.generate_cursor": {
      "calls": [
        "base64.b64encode",
        "json.dumps",
        "decode",
        "str",
        "datetime.utcnow",
        "cursor_json.encode",
        "isoformat"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Generate a cursor for pagination.",
      "file_path": "app/pagination.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 160,
      "line_start": 142,
      "module": "app.pagination",
      "name": "generate_cursor",
      "signature": "def generate_cursor( item_id: str, sort_field_value: Any, sort_by: str, sort_order: str ) -> str:"
    },
    "app.pagination.paginate_jobs": {
      "calls": [
        "asc",
        "getattr",
        "cursor_data.get",
        "base_query.order_by",
        "base_query.count",
        "len",
        "base_query.limit",
        "CursorGenerator.generate_cursor",
        "or_",
        "and_",
        "PaginationMetadata",
        "desc",
        "all",
        "base_query.filter",
        "CursorGenerator.parse_cursor"
      ],
      "decorators": [],
      "docstring": "Paginate job results with cursor-based navigation.\n\nArgs:\n    base_query: Base SQLAlchemy query to paginate\n    pagination: Pagination parameters\n    user_id: Optional user ID for filtering (not implemented in current schema)\n\nReturns:\n    PaginatedResponse with jobs and pagination metadata",
      "file_path": "app/pagination.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 282,
      "line_start": 178,
      "module": "app.pagination",
      "name": "paginate_jobs",
      "signature": "def paginate_jobs( self, base_query: Query, pagination: PaginationRequest, user_id: Optional[str] = None ) -> PaginatedResponse:"
    },
    "app.pagination.parse_cursor": {
      "calls": [
        "json.loads",
        "decode",
        "ValueError",
        "base64.b64decode"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Parse a pagination cursor.",
      "file_path": "app/pagination.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 169,
      "line_start": 163,
      "module": "app.pagination",
      "name": "parse_cursor",
      "signature": "def parse_cursor(cursor: str) -> Dict[str, Any]:"
    },
    "app.pagination.validate_cursor": {
      "calls": [
        "base64.b64decode",
        "field_validator",
        "total_seconds",
        "decode",
        "datetime.utcnow",
        "datetime.fromisoformat",
        "all",
        "ValueError",
        "sanitize_string",
        "json.loads"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": "Validate and decode pagination cursor.",
      "file_path": "app/pagination.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 87,
      "line_start": 61,
      "module": "app.pagination",
      "name": "validate_cursor",
      "signature": "def validate_cursor(cls, v: Optional[str]) -> Optional[str]:"
    },
    "app.pagination.validate_model_used": {
      "calls": [
        "field_validator",
        "join",
        "ValueError",
        "sanitize_string"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": "Validate Whisper model name.",
      "file_path": "app/pagination.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 361,
      "line_start": 351,
      "module": "app.pagination",
      "name": "validate_model_used",
      "signature": "def validate_model_used(cls, v: Optional[str]) -> Optional[str]:"
    },
    "app.pagination.validate_sort_by": {
      "calls": [
        "field_validator",
        "join",
        "ValueError",
        "sanitize_string"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": "Validate sort field.",
      "file_path": "app/pagination.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 104,
      "line_start": 91,
      "module": "app.pagination",
      "name": "validate_sort_by",
      "signature": "def validate_sort_by(cls, v: str) -> str:"
    },
    "app.pagination.validate_sort_order": {
      "calls": [
        "field_validator",
        "lower",
        "ValueError",
        "sanitize_string"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": "Validate sort order.",
      "file_path": "app/pagination.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 115,
      "line_start": 108,
      "module": "app.pagination",
      "name": "validate_sort_order",
      "signature": "def validate_sort_order(cls, v: str) -> str:"
    },
    "app.pagination.validate_status": {
      "calls": [
        "field_validator",
        "join",
        "ValueError",
        "sanitize_string"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": "Validate job status.",
      "file_path": "app/pagination.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 347,
      "line_start": 337,
      "module": "app.pagination",
      "name": "validate_status",
      "signature": "def validate_status(cls, v: Optional[str]) -> Optional[str]:"
    },
    "app.rate_limiter.MemoryRateLimitStore.__init__": {
      "calls": [
        "time.time",
        "defaultdict",
        "asyncio.Lock"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 156,
      "line_start": 152,
      "module": "app.rate_limiter",
      "name": "MemoryRateLimitStore.__init__",
      "signature": "def __init__(self, config: RateLimitConfig):"
    },
    "app.rate_limiter.MemoryRateLimitStore._cleanup_old_entries": {
      "calls": [
        "len",
        "self.counters.keys",
        "logger.info",
        "counter._cleanup_old_requests",
        "list",
        "sum",
        "counters.keys",
        "time.time",
        "self.counters.values"
      ],
      "decorators": [],
      "docstring": "Clean up old rate limit entries.",
      "file_path": "app/rate_limiter.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 245,
      "line_start": 221,
      "module": "app.rate_limiter",
      "name": "MemoryRateLimitStore._cleanup_old_entries",
      "signature": "async def _cleanup_old_entries(self) -> None:"
    },
    "app.rate_limiter.MemoryRateLimitStore._maybe_cleanup": {
      "calls": [
        "time.time",
        "self._cleanup_old_entries"
      ],
      "decorators": [],
      "docstring": "Perform cleanup if needed.",
      "file_path": "app/rate_limiter.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 219,
      "line_start": 212,
      "module": "app.rate_limiter",
      "name": "MemoryRateLimitStore._maybe_cleanup",
      "signature": "async def _maybe_cleanup(self) -> None:"
    },
    "app.rate_limiter.MemoryRateLimitStore.check_rate_limit": {
      "calls": [
        "counter.get_stats",
        "logger.warning",
        "counter.add_request",
        "self._maybe_cleanup",
        "SlidingWindowCounter"
      ],
      "decorators": [],
      "docstring": "Check if request is within rate limits.\n\nArgs:\n    identifier: Unique identifier (IP, user ID, etc.)\n    limit_type: Type of limit (global, user, endpoint)\n    rate_limit: Rate limit configuration\n    \nReturns:\n    Tuple of (allowed, rate_limit_info)",
      "file_path": "app/rate_limiter.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 210,
      "line_start": 158,
      "module": "app.rate_limiter",
      "name": "MemoryRateLimitStore.check_rate_limit",
      "signature": "async def check_rate_limit( self, identifier: str, limit_type: str, rate_limit: RateLimit ) -> Tuple[bool, Dict[str, Any]]:"
    },
    "app.rate_limiter.RateLimitMiddleware.__init__": {
      "calls": [
        "self._log_configuration",
        "logger.info",
        "MemoryRateLimitStore",
        "RateLimitConfig",
        "super",
        "__init__"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 256,
      "line_start": 251,
      "module": "app.rate_limiter",
      "name": "RateLimitMiddleware.__init__",
      "signature": "def __init__(self, app, config: Optional[RateLimitConfig] = None):"
    },
    "app.rate_limiter.RateLimitMiddleware._add_rate_limit_headers": {
      "calls": [
        "int",
        "str"
      ],
      "decorators": [],
      "docstring": "Add rate limit headers to successful response.",
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 483,
      "line_start": 470,
      "module": "app.rate_limiter",
      "name": "RateLimitMiddleware._add_rate_limit_headers",
      "signature": "def _add_rate_limit_headers(self, response: Response, rate_info: Dict[str, Any]) -> None:"
    },
    "app.rate_limiter.RateLimitMiddleware._check_all_limits": {
      "calls": [
        "self.store.check_rate_limit",
        "self._get_user_id",
        "self._get_endpoint_limit"
      ],
      "decorators": [],
      "docstring": "Check all applicable rate limits for a request.",
      "file_path": "app/rate_limiter.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 361,
      "line_start": 312,
      "module": "app.rate_limiter",
      "name": "RateLimitMiddleware._check_all_limits",
      "signature": "async def _check_all_limits(self, request: Request, client_ip: str) -> Dict[str, Any]:"
    },
    "app.rate_limiter.RateLimitMiddleware._create_rate_limit_response": {
      "calls": [
        "headers.get",
        "str",
        "JSONResponse",
        "time.time",
        "max",
        "rate_info.get",
        "int"
      ],
      "decorators": [],
      "docstring": "Create rate limit exceeded response.",
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 468,
      "line_start": 439,
      "module": "app.rate_limiter",
      "name": "RateLimitMiddleware._create_rate_limit_response",
      "signature": "def _create_rate_limit_response( self, message: str, status_code: int, rate_info: Dict[str, Any] ) -> JSONResponse:"
    },
    "app.rate_limiter.RateLimitMiddleware._get_client_ip": {
      "calls": [
        "strip",
        "getattr",
        "self._is_valid_ip",
        "request.headers.get",
        "forwarded_for.split"
      ],
      "decorators": [],
      "docstring": "Extract client IP address with proxy support.",
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 380,
      "line_start": 363,
      "module": "app.rate_limiter",
      "name": "RateLimitMiddleware._get_client_ip",
      "signature": "def _get_client_ip(self, request: Request) -> str:"
    },
    "app.rate_limiter.RateLimitMiddleware._get_endpoint_limit": {
      "calls": [
        "self.config.endpoint_limits.items",
        "self._matches_endpoint_pattern"
      ],
      "decorators": [],
      "docstring": "Get rate limit for specific endpoint.",
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 412,
      "line_start": 401,
      "module": "app.rate_limiter",
      "name": "RateLimitMiddleware._get_endpoint_limit",
      "signature": "def _get_endpoint_limit(self, path: str, method: str) -> Optional[RateLimit]:"
    },
    "app.rate_limiter.RateLimitMiddleware._get_user_id": {
      "calls": [
        "request.headers.get",
        "hasattr",
        "getattr",
        "auth_header.startswith"
      ],
      "decorators": [],
      "docstring": "Extract user ID from authenticated request.",
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 399,
      "line_start": 382,
      "module": "app.rate_limiter",
      "name": "RateLimitMiddleware._get_user_id",
      "signature": "def _get_user_id(self, request: Request) -> Optional[str]:"
    },
    "app.rate_limiter.RateLimitMiddleware._is_ip_blocked": {
      "calls": [],
      "decorators": [],
      "docstring": "Check if IP is in blacklist.",
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 437,
      "line_start": 435,
      "module": "app.rate_limiter",
      "name": "RateLimitMiddleware._is_ip_blocked",
      "signature": "def _is_ip_blocked(self, ip: str) -> bool:"
    },
    "app.rate_limiter.RateLimitMiddleware._is_ip_whitelisted": {
      "calls": [],
      "decorators": [],
      "docstring": "Check if IP is in whitelist.",
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 433,
      "line_start": 431,
      "module": "app.rate_limiter",
      "name": "RateLimitMiddleware._is_ip_whitelisted",
      "signature": "def _is_ip_whitelisted(self, ip: str) -> bool:"
    },
    "app.rate_limiter.RateLimitMiddleware._is_valid_ip": {
      "calls": [
        "ipaddress.ip_address"
      ],
      "decorators": [],
      "docstring": "Check if string is a valid IP address.",
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 429,
      "line_start": 423,
      "module": "app.rate_limiter",
      "name": "RateLimitMiddleware._is_valid_ip",
      "signature": "def _is_valid_ip(self, ip: str) -> bool:"
    },
    "app.rate_limiter.RateLimitMiddleware._log_configuration": {
      "calls": [
        "self.config.endpoint_limits.items",
        "logger.info",
        "len"
      ],
      "decorators": [],
      "docstring": "Log rate limiting configuration.",
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 264,
      "line_start": 258,
      "module": "app.rate_limiter",
      "name": "RateLimitMiddleware._log_configuration",
      "signature": "def _log_configuration(self) -> None:"
    },
    "app.rate_limiter.RateLimitMiddleware._matches_endpoint_pattern": {
      "calls": [
        "path.startswith",
        "pattern.endswith"
      ],
      "decorators": [],
      "docstring": "Check if path matches endpoint pattern.",
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 421,
      "line_start": 414,
      "module": "app.rate_limiter",
      "name": "RateLimitMiddleware._matches_endpoint_pattern",
      "signature": "def _matches_endpoint_pattern(self, path: str, pattern: str) -> bool:"
    },
    "app.rate_limiter.RateLimitMiddleware.dispatch": {
      "calls": [
        "self._create_rate_limit_response",
        "self._check_all_limits",
        "logger.warning",
        "call_next",
        "self._is_ip_blocked",
        "self._is_ip_whitelisted",
        "str",
        "logger.error",
        "self._add_rate_limit_headers",
        "self._get_client_ip"
      ],
      "decorators": [],
      "docstring": "Process request through rate limiting.",
      "file_path": "app/rate_limiter.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 310,
      "line_start": 266,
      "module": "app.rate_limiter",
      "name": "RateLimitMiddleware.dispatch",
      "signature": "async def dispatch(self, request: Request, call_next):"
    },
    "app.rate_limiter.SlidingWindowCounter.__init__": {
      "calls": [
        "time.time",
        "deque"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 90,
      "line_start": 86,
      "module": "app.rate_limiter",
      "name": "SlidingWindowCounter.__init__",
      "signature": "def __init__(self, window_size: int, max_requests: int):"
    },
    "app.rate_limiter.SlidingWindowCounter._cleanup_old_requests": {
      "calls": [
        "self.requests.popleft"
      ],
      "decorators": [],
      "docstring": "Remove requests older than the window size.",
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 123,
      "line_start": 119,
      "module": "app.rate_limiter",
      "name": "SlidingWindowCounter._cleanup_old_requests",
      "signature": "def _cleanup_old_requests(self, current_time: float) -> None:"
    },
    "app.rate_limiter.SlidingWindowCounter.add_request": {
      "calls": [
        "self.requests.append",
        "time.time",
        "self._cleanup_old_requests",
        "len"
      ],
      "decorators": [],
      "docstring": "Add a request and check if rate limit is exceeded.\n\nReturns:\n    Tuple of (allowed, remaining_requests, reset_time)",
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 117,
      "line_start": 92,
      "module": "app.rate_limiter",
      "name": "SlidingWindowCounter.add_request",
      "signature": "def add_request(self, timestamp: Optional[float] = None) -> Tuple[bool, int, float]:"
    },
    "app.rate_limiter.SlidingWindowCounter.get_stats": {
      "calls": [
        "time.time",
        "self._cleanup_old_requests",
        "max",
        "len"
      ],
      "decorators": [],
      "docstring": "Get current rate limit statistics.",
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 146,
      "line_start": 125,
      "module": "app.rate_limiter",
      "name": "SlidingWindowCounter.get_stats",
      "signature": "def get_stats(self) -> Dict[str, Any]:"
    },
    "app.rate_limiter.__init__": {
      "calls": [
        "self._log_configuration",
        "logger.info",
        "MemoryRateLimitStore",
        "RateLimitConfig",
        "super",
        "__init__"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 256,
      "line_start": 251,
      "module": "app.rate_limiter",
      "name": "__init__",
      "signature": "def __init__(self, app, config: Optional[RateLimitConfig] = None):"
    },
    "app.rate_limiter._add_rate_limit_headers": {
      "calls": [
        "int",
        "str"
      ],
      "decorators": [],
      "docstring": "Add rate limit headers to successful response.",
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 483,
      "line_start": 470,
      "module": "app.rate_limiter",
      "name": "_add_rate_limit_headers",
      "signature": "def _add_rate_limit_headers(self, response: Response, rate_info: Dict[str, Any]) -> None:"
    },
    "app.rate_limiter._check_all_limits": {
      "calls": [
        "self.store.check_rate_limit",
        "self._get_user_id",
        "self._get_endpoint_limit"
      ],
      "decorators": [],
      "docstring": "Check all applicable rate limits for a request.",
      "file_path": "app/rate_limiter.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 361,
      "line_start": 312,
      "module": "app.rate_limiter",
      "name": "_check_all_limits",
      "signature": "async def _check_all_limits(self, request: Request, client_ip: str) -> Dict[str, Any]:"
    },
    "app.rate_limiter._cleanup_old_entries": {
      "calls": [
        "len",
        "self.counters.keys",
        "logger.info",
        "counter._cleanup_old_requests",
        "list",
        "sum",
        "counters.keys",
        "time.time",
        "self.counters.values"
      ],
      "decorators": [],
      "docstring": "Clean up old rate limit entries.",
      "file_path": "app/rate_limiter.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 245,
      "line_start": 221,
      "module": "app.rate_limiter",
      "name": "_cleanup_old_entries",
      "signature": "async def _cleanup_old_entries(self) -> None:"
    },
    "app.rate_limiter._cleanup_old_requests": {
      "calls": [
        "self.requests.popleft"
      ],
      "decorators": [],
      "docstring": "Remove requests older than the window size.",
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 123,
      "line_start": 119,
      "module": "app.rate_limiter",
      "name": "_cleanup_old_requests",
      "signature": "def _cleanup_old_requests(self, current_time: float) -> None:"
    },
    "app.rate_limiter._create_rate_limit_response": {
      "calls": [
        "headers.get",
        "str",
        "JSONResponse",
        "time.time",
        "max",
        "rate_info.get",
        "int"
      ],
      "decorators": [],
      "docstring": "Create rate limit exceeded response.",
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 468,
      "line_start": 439,
      "module": "app.rate_limiter",
      "name": "_create_rate_limit_response",
      "signature": "def _create_rate_limit_response( self, message: str, status_code: int, rate_info: Dict[str, Any] ) -> JSONResponse:"
    },
    "app.rate_limiter._get_client_ip": {
      "calls": [
        "strip",
        "getattr",
        "self._is_valid_ip",
        "request.headers.get",
        "forwarded_for.split"
      ],
      "decorators": [],
      "docstring": "Extract client IP address with proxy support.",
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 380,
      "line_start": 363,
      "module": "app.rate_limiter",
      "name": "_get_client_ip",
      "signature": "def _get_client_ip(self, request: Request) -> str:"
    },
    "app.rate_limiter._get_endpoint_limit": {
      "calls": [
        "self.config.endpoint_limits.items",
        "self._matches_endpoint_pattern"
      ],
      "decorators": [],
      "docstring": "Get rate limit for specific endpoint.",
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 412,
      "line_start": 401,
      "module": "app.rate_limiter",
      "name": "_get_endpoint_limit",
      "signature": "def _get_endpoint_limit(self, path: str, method: str) -> Optional[RateLimit]:"
    },
    "app.rate_limiter._get_user_id": {
      "calls": [
        "request.headers.get",
        "hasattr",
        "getattr",
        "auth_header.startswith"
      ],
      "decorators": [],
      "docstring": "Extract user ID from authenticated request.",
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 399,
      "line_start": 382,
      "module": "app.rate_limiter",
      "name": "_get_user_id",
      "signature": "def _get_user_id(self, request: Request) -> Optional[str]:"
    },
    "app.rate_limiter._is_ip_blocked": {
      "calls": [],
      "decorators": [],
      "docstring": "Check if IP is in blacklist.",
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 437,
      "line_start": 435,
      "module": "app.rate_limiter",
      "name": "_is_ip_blocked",
      "signature": "def _is_ip_blocked(self, ip: str) -> bool:"
    },
    "app.rate_limiter._is_ip_whitelisted": {
      "calls": [],
      "decorators": [],
      "docstring": "Check if IP is in whitelist.",
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 433,
      "line_start": 431,
      "module": "app.rate_limiter",
      "name": "_is_ip_whitelisted",
      "signature": "def _is_ip_whitelisted(self, ip: str) -> bool:"
    },
    "app.rate_limiter._is_valid_ip": {
      "calls": [
        "ipaddress.ip_address"
      ],
      "decorators": [],
      "docstring": "Check if string is a valid IP address.",
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 429,
      "line_start": 423,
      "module": "app.rate_limiter",
      "name": "_is_valid_ip",
      "signature": "def _is_valid_ip(self, ip: str) -> bool:"
    },
    "app.rate_limiter._log_configuration": {
      "calls": [
        "self.config.endpoint_limits.items",
        "logger.info",
        "len"
      ],
      "decorators": [],
      "docstring": "Log rate limiting configuration.",
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 264,
      "line_start": 258,
      "module": "app.rate_limiter",
      "name": "_log_configuration",
      "signature": "def _log_configuration(self) -> None:"
    },
    "app.rate_limiter._matches_endpoint_pattern": {
      "calls": [
        "path.startswith",
        "pattern.endswith"
      ],
      "decorators": [],
      "docstring": "Check if path matches endpoint pattern.",
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 421,
      "line_start": 414,
      "module": "app.rate_limiter",
      "name": "_matches_endpoint_pattern",
      "signature": "def _matches_endpoint_pattern(self, path: str, pattern: str) -> bool:"
    },
    "app.rate_limiter._maybe_cleanup": {
      "calls": [
        "time.time",
        "self._cleanup_old_entries"
      ],
      "decorators": [],
      "docstring": "Perform cleanup if needed.",
      "file_path": "app/rate_limiter.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 219,
      "line_start": 212,
      "module": "app.rate_limiter",
      "name": "_maybe_cleanup",
      "signature": "async def _maybe_cleanup(self) -> None:"
    },
    "app.rate_limiter.add_request": {
      "calls": [
        "self.requests.append",
        "time.time",
        "self._cleanup_old_requests",
        "len"
      ],
      "decorators": [],
      "docstring": "Add a request and check if rate limit is exceeded.\n\nReturns:\n    Tuple of (allowed, remaining_requests, reset_time)",
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 117,
      "line_start": 92,
      "module": "app.rate_limiter",
      "name": "add_request",
      "signature": "def add_request(self, timestamp: Optional[float] = None) -> Tuple[bool, int, float]:"
    },
    "app.rate_limiter.check_rate_limit": {
      "calls": [
        "counter.get_stats",
        "logger.warning",
        "counter.add_request",
        "self._maybe_cleanup",
        "SlidingWindowCounter"
      ],
      "decorators": [],
      "docstring": "Check if request is within rate limits.\n\nArgs:\n    identifier: Unique identifier (IP, user ID, etc.)\n    limit_type: Type of limit (global, user, endpoint)\n    rate_limit: Rate limit configuration\n    \nReturns:\n    Tuple of (allowed, rate_limit_info)",
      "file_path": "app/rate_limiter.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 210,
      "line_start": 158,
      "module": "app.rate_limiter",
      "name": "check_rate_limit",
      "signature": "async def check_rate_limit( self, identifier: str, limit_type: str, rate_limit: RateLimit ) -> Tuple[bool, Dict[str, Any]]:"
    },
    "app.rate_limiter.create_development_rate_limiter": {
      "calls": [
        "RateLimit",
        "RateLimitMiddleware",
        "RateLimitConfig"
      ],
      "decorators": [],
      "docstring": "Create a lenient rate limiter for development.",
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 513,
      "line_start": 502,
      "module": "app.rate_limiter",
      "name": "create_development_rate_limiter",
      "signature": "def create_development_rate_limiter() -> RateLimitMiddleware:"
    },
    "app.rate_limiter.create_strict_rate_limiter": {
      "calls": [
        "RateLimit",
        "RateLimitMiddleware",
        "RateLimitConfig"
      ],
      "decorators": [],
      "docstring": "Create a strict rate limiter for production use.",
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 499,
      "line_start": 487,
      "module": "app.rate_limiter",
      "name": "create_strict_rate_limiter",
      "signature": "def create_strict_rate_limiter() -> RateLimitMiddleware:"
    },
    "app.rate_limiter.dispatch": {
      "calls": [
        "self._create_rate_limit_response",
        "self._check_all_limits",
        "logger.warning",
        "call_next",
        "self._is_ip_blocked",
        "self._is_ip_whitelisted",
        "str",
        "logger.error",
        "self._add_rate_limit_headers",
        "self._get_client_ip"
      ],
      "decorators": [],
      "docstring": "Process request through rate limiting.",
      "file_path": "app/rate_limiter.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 310,
      "line_start": 266,
      "module": "app.rate_limiter",
      "name": "dispatch",
      "signature": "async def dispatch(self, request: Request, call_next):"
    },
    "app.rate_limiter.get_stats": {
      "calls": [
        "time.time",
        "self._cleanup_old_requests",
        "max",
        "len"
      ],
      "decorators": [],
      "docstring": "Get current rate limit statistics.",
      "file_path": "app/rate_limiter.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 146,
      "line_start": 125,
      "module": "app.rate_limiter",
      "name": "get_stats",
      "signature": "def get_stats(self) -> Dict[str, Any]:"
    },
    "app.schemas.ErrorResponseSchema.sanitize_message": {
      "calls": [
        "field_validator",
        "sanitize_string"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": "Sanitize error message.",
      "file_path": "app/schemas.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 462,
      "line_start": 460,
      "module": "app.schemas",
      "name": "ErrorResponseSchema.sanitize_message",
      "signature": "def sanitize_message(cls, v: str) -> str:"
    },
    "app.schemas.FileUploadSchema.validate_filename": {
      "calls": [
        "validate_no_sql_injection",
        "field_validator",
        "ValidationConfig.FILENAME_PATTERN.match",
        "ValueError",
        "sanitize_string"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": "Validate filename security.",
      "file_path": "app/schemas.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 274,
      "line_start": 259,
      "module": "app.schemas",
      "name": "FileUploadSchema.validate_filename",
      "signature": "def validate_filename(cls, v: Optional[str]) -> Optional[str]:"
    },
    "app.schemas.FileUploadSchema.validate_language": {
      "calls": [
        "field_validator",
        "re.match",
        "ValueError",
        "sanitize_string",
        "v.lower"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": "Validate language code.",
      "file_path": "app/schemas.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 305,
      "line_start": 294,
      "module": "app.schemas",
      "name": "FileUploadSchema.validate_language",
      "signature": "def validate_language(cls, v: Optional[str]) -> Optional[str]:"
    },
    "app.schemas.FileUploadSchema.validate_model": {
      "calls": [
        "field_validator",
        "join",
        "ValueError",
        "sanitize_string"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": "Validate model name.",
      "file_path": "app/schemas.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 290,
      "line_start": 278,
      "module": "app.schemas",
      "name": "FileUploadSchema.validate_model",
      "signature": "def validate_model(cls, v: Optional[str]) -> Optional[str]:"
    },
    "app.schemas.JobIdSchema.validate_job_id": {
      "calls": [
        "validate_no_sql_injection",
        "ValidationConfig.JOB_ID_PATTERN.match",
        "field_validator",
        "ValueError",
        "sanitize_string"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": "Validate job ID format.",
      "file_path": "app/schemas.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 366,
      "line_start": 359,
      "module": "app.schemas",
      "name": "JobIdSchema.validate_job_id",
      "signature": "def validate_job_id(cls, v: str) -> str:"
    },
    "app.schemas.JobQuerySchema.validate_status": {
      "calls": [
        "field_validator",
        "join",
        "ValueError",
        "sanitize_string"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": "Validate job status.",
      "file_path": "app/schemas.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 344,
      "line_start": 332,
      "module": "app.schemas",
      "name": "JobQuerySchema.validate_status",
      "signature": "def validate_status(cls, v: Optional[str]) -> Optional[str]:"
    },
    "app.schemas.JobResponseSchema.sanitize_text_fields": {
      "calls": [
        "field_validator",
        "sanitize_string"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": "Sanitize text fields in responses.",
      "file_path": "app/schemas.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 412,
      "line_start": 408,
      "module": "app.schemas",
      "name": "JobResponseSchema.sanitize_text_fields",
      "signature": "def sanitize_text_fields(cls, v: Optional[str]) -> Optional[str]:"
    },
    "app.schemas.PasswordChangeSchema.validate_new_password": {
      "calls": [
        "field_validator",
        "UserRegistrationSchema.validate_password"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": "Apply same validation as registration.",
      "file_path": "app/schemas.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 234,
      "line_start": 232,
      "module": "app.schemas",
      "name": "PasswordChangeSchema.validate_new_password",
      "signature": "def validate_new_password(cls, v: str) -> str:"
    },
    "app.schemas.UserLoginSchema.validate_password": {
      "calls": [
        "field_validator",
        "ValueError",
        "len"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": null,
      "file_path": "app/schemas.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 212,
      "line_start": 207,
      "module": "app.schemas",
      "name": "UserLoginSchema.validate_password",
      "signature": "def validate_password(cls, v: str) -> str:"
    },
    "app.schemas.UserLoginSchema.validate_username": {
      "calls": [
        "field_validator",
        "validate_no_sql_injection",
        "sanitize_string"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": null,
      "file_path": "app/schemas.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 203,
      "line_start": 202,
      "module": "app.schemas",
      "name": "UserLoginSchema.validate_username",
      "signature": "def validate_username(cls, v: str) -> str:"
    },
    "app.schemas.UserRegistrationSchema.validate_password": {
      "calls": [
        "len",
        "field_validator",
        "ValueError",
        "re.search",
        "v.lower"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": "Validate password strength and security.",
      "file_path": "app/schemas.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 183,
      "line_start": 170,
      "module": "app.schemas",
      "name": "UserRegistrationSchema.validate_password",
      "signature": "def validate_password(cls, v: str) -> str:"
    },
    "app.schemas.UserRegistrationSchema.validate_username": {
      "calls": [
        "validate_no_sql_injection",
        "field_validator",
        "ValidationConfig.USERNAME_PATTERN.match",
        "ValueError",
        "sanitize_string",
        "v.lower"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": "Validate username format and security.",
      "file_path": "app/schemas.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 166,
      "line_start": 154,
      "module": "app.schemas",
      "name": "UserRegistrationSchema.validate_username",
      "signature": "def validate_username(cls, v: str) -> str:"
    },
    "app.schemas.UserResponseSchema.sanitize_username": {
      "calls": [
        "field_validator",
        "sanitize_string"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": "Ensure username is sanitized in responses.",
      "file_path": "app/schemas.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 390,
      "line_start": 388,
      "module": "app.schemas",
      "name": "UserResponseSchema.sanitize_username",
      "signature": "def sanitize_username(cls, v: str) -> str:"
    },
    "app.schemas.create_validation_error_response": {
      "calls": [
        "join",
        "error.errors",
        "str",
        "sanitize_string"
      ],
      "decorators": [],
      "docstring": "Create a sanitized validation error response.",
      "file_path": "app/schemas.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 521,
      "line_start": 506,
      "module": "app.schemas",
      "name": "create_validation_error_response",
      "signature": "def create_validation_error_response(error: ValidationError) -> Dict[str, Any]:"
    },
    "app.schemas.sanitize_message": {
      "calls": [
        "field_validator",
        "sanitize_string"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": "Sanitize error message.",
      "file_path": "app/schemas.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 462,
      "line_start": 460,
      "module": "app.schemas",
      "name": "sanitize_message",
      "signature": "def sanitize_message(cls, v: str) -> str:"
    },
    "app.schemas.sanitize_string": {
      "calls": [
        "replace",
        "len",
        "value.replace",
        "html.escape",
        "isinstance",
        "re.search",
        "ValueError",
        "bleach.clean",
        "value.strip"
      ],
      "decorators": [],
      "docstring": "Sanitize string input to prevent XSS and injection attacks.\n\nArgs:\n    value: Input string to sanitize\n    allow_html: If True, allows safe HTML tags\n    \nReturns:\n    Sanitized string",
      "file_path": "app/schemas.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 98,
      "line_start": 64,
      "module": "app.schemas",
      "name": "sanitize_string",
      "signature": "def sanitize_string(value: str, allow_html: bool = False) -> str:"
    },
    "app.schemas.sanitize_text_fields": {
      "calls": [
        "field_validator",
        "sanitize_string"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": "Sanitize text fields in responses.",
      "file_path": "app/schemas.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 412,
      "line_start": 408,
      "module": "app.schemas",
      "name": "sanitize_text_fields",
      "signature": "def sanitize_text_fields(cls, v: Optional[str]) -> Optional[str]:"
    },
    "app.schemas.sanitize_username": {
      "calls": [
        "field_validator",
        "sanitize_string"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": "Ensure username is sanitized in responses.",
      "file_path": "app/schemas.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 390,
      "line_start": 388,
      "module": "app.schemas",
      "name": "sanitize_username",
      "signature": "def sanitize_username(cls, v: str) -> str:"
    },
    "app.schemas.validate_filename": {
      "calls": [
        "validate_no_sql_injection",
        "field_validator",
        "ValidationConfig.FILENAME_PATTERN.match",
        "ValueError",
        "sanitize_string"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": "Validate filename security.",
      "file_path": "app/schemas.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 274,
      "line_start": 259,
      "module": "app.schemas",
      "name": "validate_filename",
      "signature": "def validate_filename(cls, v: Optional[str]) -> Optional[str]:"
    },
    "app.schemas.validate_job_id": {
      "calls": [
        "validate_no_sql_injection",
        "ValidationConfig.JOB_ID_PATTERN.match",
        "field_validator",
        "ValueError",
        "sanitize_string"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": "Validate job ID format.",
      "file_path": "app/schemas.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 366,
      "line_start": 359,
      "module": "app.schemas",
      "name": "validate_job_id",
      "signature": "def validate_job_id(cls, v: str) -> str:"
    },
    "app.schemas.validate_json_depth": {
      "calls": [
        "validate_json_depth",
        "isinstance",
        "data.values",
        "ValueError"
      ],
      "decorators": [],
      "docstring": "Validate JSON depth to prevent nested object DoS attacks.",
      "file_path": "app/schemas.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 503,
      "line_start": 493,
      "module": "app.schemas",
      "name": "validate_json_depth",
      "signature": "def validate_json_depth(data: Any, max_depth: int = 10, current_depth: int = 0) -> None:"
    },
    "app.schemas.validate_language": {
      "calls": [
        "field_validator",
        "re.match",
        "ValueError",
        "sanitize_string",
        "v.lower"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": "Validate language code.",
      "file_path": "app/schemas.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 305,
      "line_start": 294,
      "module": "app.schemas",
      "name": "validate_language",
      "signature": "def validate_language(cls, v: Optional[str]) -> Optional[str]:"
    },
    "app.schemas.validate_model": {
      "calls": [
        "field_validator",
        "join",
        "ValueError",
        "sanitize_string"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": "Validate model name.",
      "file_path": "app/schemas.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 290,
      "line_start": 278,
      "module": "app.schemas",
      "name": "validate_model",
      "signature": "def validate_model(cls, v: Optional[str]) -> Optional[str]:"
    },
    "app.schemas.validate_new_password": {
      "calls": [
        "field_validator",
        "UserRegistrationSchema.validate_password"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": "Apply same validation as registration.",
      "file_path": "app/schemas.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 234,
      "line_start": 232,
      "module": "app.schemas",
      "name": "validate_new_password",
      "signature": "def validate_new_password(cls, v: str) -> str:"
    },
    "app.schemas.validate_no_sql_injection": {
      "calls": [
        "value.lower",
        "ValueError"
      ],
      "decorators": [],
      "docstring": "Validate that string doesn't contain SQL injection patterns.",
      "file_path": "app/schemas.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 113,
      "line_start": 101,
      "module": "app.schemas",
      "name": "validate_no_sql_injection",
      "signature": "def validate_no_sql_injection(value: str) -> str:"
    },
    "app.schemas.validate_password": {
      "calls": [
        "field_validator",
        "ValueError",
        "len"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": null,
      "file_path": "app/schemas.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 212,
      "line_start": 207,
      "module": "app.schemas",
      "name": "validate_password",
      "signature": "def validate_password(cls, v: str) -> str:"
    },
    "app.schemas.validate_request_size": {
      "calls": [
        "ValueError"
      ],
      "decorators": [],
      "docstring": "Validate request size to prevent DoS attacks.",
      "file_path": "app/schemas.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 490,
      "line_start": 487,
      "module": "app.schemas",
      "name": "validate_request_size",
      "signature": "def validate_request_size(content_length: Optional[int], max_size: int = 104857600) -> None:"
    },
    "app.schemas.validate_status": {
      "calls": [
        "field_validator",
        "join",
        "ValueError",
        "sanitize_string"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": "Validate job status.",
      "file_path": "app/schemas.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 344,
      "line_start": 332,
      "module": "app.schemas",
      "name": "validate_status",
      "signature": "def validate_status(cls, v: Optional[str]) -> Optional[str]:"
    },
    "app.schemas.validate_username": {
      "calls": [
        "field_validator",
        "validate_no_sql_injection",
        "sanitize_string"
      ],
      "decorators": [
        "field_validator",
        "classmethod"
      ],
      "docstring": null,
      "file_path": "app/schemas.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 203,
      "line_start": 202,
      "module": "app.schemas",
      "name": "validate_username",
      "signature": "def validate_username(cls, v: str) -> str:"
    },
    "app.security_middleware.SecurityEventLogger.__init__": {
      "calls": [
        "logging.getLogger"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 457,
      "line_start": 456,
      "module": "app.security_middleware",
      "name": "SecurityEventLogger.__init__",
      "signature": "def __init__(self):"
    },
    "app.security_middleware.SecurityEventLogger.log_attack_attempt": {
      "calls": [
        "self.logger.warning"
      ],
      "decorators": [],
      "docstring": "Log security attack attempt.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 472,
      "line_start": 459,
      "module": "app.security_middleware",
      "name": "SecurityEventLogger.log_attack_attempt",
      "signature": "def log_attack_attempt( self, attack_type: str, client_ip: str, user_agent: str, payload: str, request_path: str ) -> None:"
    },
    "app.security_middleware.SecurityEventLogger.log_authentication_failure": {
      "calls": [
        "self.logger.warning"
      ],
      "decorators": [],
      "docstring": "Log authentication failure.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 498,
      "line_start": 488,
      "module": "app.security_middleware",
      "name": "SecurityEventLogger.log_authentication_failure",
      "signature": "def log_authentication_failure( self, client_ip: str, username: str, failure_reason: str ) -> None:"
    },
    "app.security_middleware.SecurityEventLogger.log_rate_limit_exceeded": {
      "calls": [
        "self.logger.warning"
      ],
      "decorators": [],
      "docstring": "Log rate limit exceeded event.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 486,
      "line_start": 474,
      "module": "app.security_middleware",
      "name": "SecurityEventLogger.log_rate_limit_exceeded",
      "signature": "def log_rate_limit_exceeded( self, client_ip: str, user_id: Optional[str], endpoint: str, limit_type: str ) -> None:"
    },
    "app.security_middleware.SecurityEventLogger.log_suspicious_activity": {
      "calls": [
        "self.logger.warning"
      ],
      "decorators": [],
      "docstring": "Log suspicious activity.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 510,
      "line_start": 500,
      "module": "app.security_middleware",
      "name": "SecurityEventLogger.log_suspicious_activity",
      "signature": "def log_suspicious_activity( self, activity_type: str, client_ip: str, details: Dict[str, Any] ) -> None:"
    },
    "app.security_middleware.SecurityMiddleware.__init__": {
      "calls": [
        "super",
        "SecurityValidator",
        "logger.info",
        "__init__"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 353,
      "line_start": 349,
      "module": "app.security_middleware",
      "name": "SecurityMiddleware.__init__",
      "signature": "def __init__(self, app, config: Optional[Dict[str, Any]] = None):"
    },
    "app.security_middleware.SecurityMiddleware._add_security_headers": {
      "calls": [
        "SecurityConfig.SECURITY_HEADERS.items"
      ],
      "decorators": [],
      "docstring": "Add security headers to response.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 450,
      "line_start": 447,
      "module": "app.security_middleware",
      "name": "SecurityMiddleware._add_security_headers",
      "signature": "def _add_security_headers(self, response: Response) -> None:"
    },
    "app.security_middleware.SecurityMiddleware._is_json_request": {
      "calls": [
        "request.headers.get",
        "content_type.startswith"
      ],
      "decorators": [],
      "docstring": "Check if request contains JSON payload.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 417,
      "line_start": 414,
      "module": "app.security_middleware",
      "name": "SecurityMiddleware._is_json_request",
      "signature": "def _is_json_request(self, request: Request) -> bool:"
    },
    "app.security_middleware.SecurityMiddleware._validate_json_payload": {
      "calls": [
        "HTTPException",
        "request.body",
        "json.loads",
        "self.validator.validate_json_payload"
      ],
      "decorators": [],
      "docstring": "Validate JSON payload in request body.",
      "file_path": "app/security_middleware.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 445,
      "line_start": 419,
      "module": "app.security_middleware",
      "name": "SecurityMiddleware._validate_json_payload",
      "signature": "async def _validate_json_payload(self, request: Request) -> None:"
    },
    "app.security_middleware.SecurityMiddleware.dispatch": {
      "calls": [
        "HTTPException",
        "self.validator.validate_url",
        "call_next",
        "self.validator.validate_request_size",
        "self.validator.validate_headers",
        "self._add_security_headers",
        "str",
        "JSONResponse",
        "request.headers.get",
        "time.time",
        "self._is_json_request",
        "logger.error",
        "self._validate_json_payload",
        "dict",
        "logger.debug",
        "int"
      ],
      "decorators": [],
      "docstring": "Process request through security validation.",
      "file_path": "app/security_middleware.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 412,
      "line_start": 355,
      "module": "app.security_middleware",
      "name": "SecurityMiddleware.dispatch",
      "signature": "async def dispatch(self, request: Request, call_next):"
    },
    "app.security_middleware.SecurityValidator._check_malicious_patterns": {
      "calls": [
        "HTTPException",
        "logger.warning",
        "isinstance",
        "text.lower",
        "re.search"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Check text for malicious patterns.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 343,
      "line_start": 311,
      "module": "app.security_middleware",
      "name": "SecurityValidator._check_malicious_patterns",
      "signature": "def _check_malicious_patterns(text: str, context: str = \"input\") -> None:"
    },
    "app.security_middleware.SecurityValidator._validate_content_type": {
      "calls": [
        "strip",
        "HTTPException",
        "lower",
        "content_type.split"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Validate Content-Type header.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 221,
      "line_start": 209,
      "module": "app.security_middleware",
      "name": "SecurityValidator._validate_content_type",
      "signature": "def _validate_content_type(content_type: str) -> None:"
    },
    "app.security_middleware.SecurityValidator._validate_json_content": {
      "calls": [
        "isinstance",
        "data.items",
        "SecurityValidator._validate_json_content",
        "SecurityValidator._check_malicious_patterns"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Validate JSON content for malicious patterns.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 308,
      "line_start": 295,
      "module": "app.security_middleware",
      "name": "SecurityValidator._validate_json_content",
      "signature": "def _validate_json_content(data: Any) -> None:"
    },
    "app.security_middleware.SecurityValidator._validate_json_structure": {
      "calls": [
        "HTTPException",
        "len",
        "SecurityValidator._validate_json_structure",
        "data.items",
        "isinstance"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Validate JSON structure for DoS protection.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 292,
      "line_start": 254,
      "module": "app.security_middleware",
      "name": "SecurityValidator._validate_json_structure",
      "signature": "def _validate_json_structure(data: Any, depth: int, max_depth: int) -> None:"
    },
    "app.security_middleware.SecurityValidator._validate_user_agent": {
      "calls": [
        "logger.warning",
        "HTTPException",
        "user_agent.lower",
        "len"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Validate User-Agent header.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 206,
      "line_start": 181,
      "module": "app.security_middleware",
      "name": "SecurityValidator._validate_user_agent",
      "signature": "def _validate_user_agent(user_agent: str) -> None:"
    },
    "app.security_middleware.SecurityValidator.validate_headers": {
      "calls": [
        "HTTPException",
        "headers.items",
        "name.lower",
        "logger.warning",
        "len",
        "SecurityValidator._validate_content_type",
        "SecurityValidator._check_malicious_patterns",
        "SecurityValidator._validate_user_agent"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Validate request headers for security issues.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 178,
      "line_start": 143,
      "module": "app.security_middleware",
      "name": "SecurityValidator.validate_headers",
      "signature": "def validate_headers(headers: Dict[str, str]) -> None:"
    },
    "app.security_middleware.SecurityValidator.validate_json_payload": {
      "calls": [
        "SecurityValidator._validate_json_structure",
        "SecurityValidator._validate_json_content"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Validate JSON payload structure and content.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 251,
      "line_start": 245,
      "module": "app.security_middleware",
      "name": "SecurityValidator.validate_json_payload",
      "signature": "def validate_json_payload(data: Any, max_depth: int = None) -> None:"
    },
    "app.security_middleware.SecurityValidator.validate_request_size": {
      "calls": [
        "HTTPException"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Validate request size to prevent DoS attacks.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 140,
      "line_start": 134,
      "module": "app.security_middleware",
      "name": "SecurityValidator.validate_request_size",
      "signature": "def validate_request_size(content_length: Optional[int]) -> None:"
    },
    "app.security_middleware.SecurityValidator.validate_url": {
      "calls": [
        "HTTPException",
        "logger.warning",
        "unquote",
        "SecurityValidator._check_malicious_patterns",
        "re.search"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Validate URL for security issues.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 242,
      "line_start": 224,
      "module": "app.security_middleware",
      "name": "SecurityValidator.validate_url",
      "signature": "def validate_url(url: str) -> None:"
    },
    "app.security_middleware.__init__": {
      "calls": [
        "logging.getLogger"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 457,
      "line_start": 456,
      "module": "app.security_middleware",
      "name": "__init__",
      "signature": "def __init__(self):"
    },
    "app.security_middleware._add_security_headers": {
      "calls": [
        "SecurityConfig.SECURITY_HEADERS.items"
      ],
      "decorators": [],
      "docstring": "Add security headers to response.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 450,
      "line_start": 447,
      "module": "app.security_middleware",
      "name": "_add_security_headers",
      "signature": "def _add_security_headers(self, response: Response) -> None:"
    },
    "app.security_middleware._check_malicious_patterns": {
      "calls": [
        "HTTPException",
        "logger.warning",
        "isinstance",
        "text.lower",
        "re.search"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Check text for malicious patterns.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 343,
      "line_start": 311,
      "module": "app.security_middleware",
      "name": "_check_malicious_patterns",
      "signature": "def _check_malicious_patterns(text: str, context: str = \"input\") -> None:"
    },
    "app.security_middleware._is_json_request": {
      "calls": [
        "request.headers.get",
        "content_type.startswith"
      ],
      "decorators": [],
      "docstring": "Check if request contains JSON payload.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 417,
      "line_start": 414,
      "module": "app.security_middleware",
      "name": "_is_json_request",
      "signature": "def _is_json_request(self, request: Request) -> bool:"
    },
    "app.security_middleware._validate_content_type": {
      "calls": [
        "strip",
        "HTTPException",
        "lower",
        "content_type.split"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Validate Content-Type header.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 221,
      "line_start": 209,
      "module": "app.security_middleware",
      "name": "_validate_content_type",
      "signature": "def _validate_content_type(content_type: str) -> None:"
    },
    "app.security_middleware._validate_json_content": {
      "calls": [
        "isinstance",
        "data.items",
        "SecurityValidator._validate_json_content",
        "SecurityValidator._check_malicious_patterns"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Validate JSON content for malicious patterns.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 308,
      "line_start": 295,
      "module": "app.security_middleware",
      "name": "_validate_json_content",
      "signature": "def _validate_json_content(data: Any) -> None:"
    },
    "app.security_middleware._validate_json_payload": {
      "calls": [
        "HTTPException",
        "request.body",
        "json.loads",
        "self.validator.validate_json_payload"
      ],
      "decorators": [],
      "docstring": "Validate JSON payload in request body.",
      "file_path": "app/security_middleware.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 445,
      "line_start": 419,
      "module": "app.security_middleware",
      "name": "_validate_json_payload",
      "signature": "async def _validate_json_payload(self, request: Request) -> None:"
    },
    "app.security_middleware._validate_json_structure": {
      "calls": [
        "HTTPException",
        "len",
        "SecurityValidator._validate_json_structure",
        "data.items",
        "isinstance"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Validate JSON structure for DoS protection.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 292,
      "line_start": 254,
      "module": "app.security_middleware",
      "name": "_validate_json_structure",
      "signature": "def _validate_json_structure(data: Any, depth: int, max_depth: int) -> None:"
    },
    "app.security_middleware._validate_user_agent": {
      "calls": [
        "logger.warning",
        "HTTPException",
        "user_agent.lower",
        "len"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Validate User-Agent header.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 206,
      "line_start": 181,
      "module": "app.security_middleware",
      "name": "_validate_user_agent",
      "signature": "def _validate_user_agent(user_agent: str) -> None:"
    },
    "app.security_middleware.create_development_security_middleware": {
      "calls": [
        "SecurityMiddleware"
      ],
      "decorators": [],
      "docstring": "Create lenient security middleware for development.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 540,
      "line_start": 530,
      "module": "app.security_middleware",
      "name": "create_development_security_middleware",
      "signature": "def create_development_security_middleware() -> SecurityMiddleware:"
    },
    "app.security_middleware.create_security_middleware": {
      "calls": [
        "SecurityMiddleware",
        "config.setdefault"
      ],
      "decorators": [],
      "docstring": "Create security middleware with configuration.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 527,
      "line_start": 514,
      "module": "app.security_middleware",
      "name": "create_security_middleware",
      "signature": "def create_security_middleware( enable_strict_validation: bool = True, custom_config: Optional[Dict[str, Any]] = None ) -> SecurityMiddleware:"
    },
    "app.security_middleware.dispatch": {
      "calls": [
        "HTTPException",
        "self.validator.validate_url",
        "call_next",
        "self.validator.validate_request_size",
        "self.validator.validate_headers",
        "self._add_security_headers",
        "str",
        "JSONResponse",
        "request.headers.get",
        "time.time",
        "self._is_json_request",
        "logger.error",
        "self._validate_json_payload",
        "dict",
        "logger.debug",
        "int"
      ],
      "decorators": [],
      "docstring": "Process request through security validation.",
      "file_path": "app/security_middleware.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 412,
      "line_start": 355,
      "module": "app.security_middleware",
      "name": "dispatch",
      "signature": "async def dispatch(self, request: Request, call_next):"
    },
    "app.security_middleware.log_attack_attempt": {
      "calls": [
        "self.logger.warning"
      ],
      "decorators": [],
      "docstring": "Log security attack attempt.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 472,
      "line_start": 459,
      "module": "app.security_middleware",
      "name": "log_attack_attempt",
      "signature": "def log_attack_attempt( self, attack_type: str, client_ip: str, user_agent: str, payload: str, request_path: str ) -> None:"
    },
    "app.security_middleware.log_authentication_failure": {
      "calls": [
        "self.logger.warning"
      ],
      "decorators": [],
      "docstring": "Log authentication failure.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 498,
      "line_start": 488,
      "module": "app.security_middleware",
      "name": "log_authentication_failure",
      "signature": "def log_authentication_failure( self, client_ip: str, username: str, failure_reason: str ) -> None:"
    },
    "app.security_middleware.log_rate_limit_exceeded": {
      "calls": [
        "self.logger.warning"
      ],
      "decorators": [],
      "docstring": "Log rate limit exceeded event.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 486,
      "line_start": 474,
      "module": "app.security_middleware",
      "name": "log_rate_limit_exceeded",
      "signature": "def log_rate_limit_exceeded( self, client_ip: str, user_id: Optional[str], endpoint: str, limit_type: str ) -> None:"
    },
    "app.security_middleware.log_suspicious_activity": {
      "calls": [
        "self.logger.warning"
      ],
      "decorators": [],
      "docstring": "Log suspicious activity.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 510,
      "line_start": 500,
      "module": "app.security_middleware",
      "name": "log_suspicious_activity",
      "signature": "def log_suspicious_activity( self, activity_type: str, client_ip: str, details: Dict[str, Any] ) -> None:"
    },
    "app.security_middleware.validate_headers": {
      "calls": [
        "HTTPException",
        "headers.items",
        "name.lower",
        "logger.warning",
        "len",
        "SecurityValidator._validate_content_type",
        "SecurityValidator._check_malicious_patterns",
        "SecurityValidator._validate_user_agent"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Validate request headers for security issues.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 178,
      "line_start": 143,
      "module": "app.security_middleware",
      "name": "validate_headers",
      "signature": "def validate_headers(headers: Dict[str, str]) -> None:"
    },
    "app.security_middleware.validate_json_payload": {
      "calls": [
        "SecurityValidator._validate_json_structure",
        "SecurityValidator._validate_json_content"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Validate JSON payload structure and content.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 251,
      "line_start": 245,
      "module": "app.security_middleware",
      "name": "validate_json_payload",
      "signature": "def validate_json_payload(data: Any, max_depth: int = None) -> None:"
    },
    "app.security_middleware.validate_request_size": {
      "calls": [
        "HTTPException"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Validate request size to prevent DoS attacks.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 140,
      "line_start": 134,
      "module": "app.security_middleware",
      "name": "validate_request_size",
      "signature": "def validate_request_size(content_length: Optional[int]) -> None:"
    },
    "app.security_middleware.validate_url": {
      "calls": [
        "HTTPException",
        "logger.warning",
        "unquote",
        "SecurityValidator._check_malicious_patterns",
        "re.search"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Validate URL for security issues.",
      "file_path": "app/security_middleware.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 242,
      "line_start": 224,
      "module": "app.security_middleware",
      "name": "validate_url",
      "signature": "def validate_url(url: str) -> None:"
    },
    "app.worker.get_whisper_model": {
      "calls": [
        "whisper.load_model",
        "logging.info"
      ],
      "decorators": [],
      "docstring": "Load and cache Whisper models",
      "file_path": "app/worker.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 55,
      "line_start": 50,
      "module": "app.worker",
      "name": "get_whisper_model",
      "signature": "def get_whisper_model(model_name: str):"
    },
    "app.worker.health_check": {
      "calls": [
        "datetime.utcnow",
        "isoformat"
      ],
      "decorators": [
        "celery_app.task"
      ],
      "docstring": "Simple health check task",
      "file_path": "app/worker.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 169,
      "line_start": 167,
      "module": "app.worker",
      "name": "health_check",
      "signature": "def health_check():"
    },
    "app.worker.setup_periodic_tasks": {
      "calls": [
        "sender.add_periodic_task",
        "health_check.s"
      ],
      "decorators": [
        "celery_app.on_after_configure.connect"
      ],
      "docstring": "Setup periodic tasks",
      "file_path": "app/worker.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 176,
      "line_start": 173,
      "module": "app.worker",
      "name": "setup_periodic_tasks",
      "signature": "def setup_periodic_tasks(sender, **kwargs):"
    },
    "app.worker.transcribe_audio": {
      "calls": [
        "strip",
        "upload_path.unlink",
        "db.close",
        "logging.info",
        "logging.warning",
        "model.transcribe",
        "first",
        "filter",
        "manager.send_progress",
        "FileNotFoundError",
        "db.query",
        "datetime.utcnow",
        "int",
        "result.get",
        "Path",
        "get_whisper_model",
        "upload_path.exists",
        "logging.error",
        "asyncio.create_task",
        "celery_app.task",
        "SessionLocal",
        "str",
        "db.commit"
      ],
      "decorators": [
        "celery_app.task"
      ],
      "docstring": "Background task to transcribe audio file",
      "file_path": "app/worker.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 163,
      "line_start": 58,
      "module": "app.worker",
      "name": "transcribe_audio",
      "signature": "def transcribe_audio(self, job_id: str):"
    },
    "generate_function_docs.ApplicationDocumentationGenerator.__init__": {
      "calls": [
        "Path"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "generate_function_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 47,
      "line_start": 43,
      "module": "generate_function_docs",
      "name": "ApplicationDocumentationGenerator.__init__",
      "signature": "def __init__(self, project_root: str):"
    },
    "generate_function_docs.ApplicationDocumentationGenerator._check_for_api_endpoint": {
      "calls": [
        "isinstance",
        "self.api_endpoints.append",
        "APIEndpoint",
        "decorator.func.attr.upper"
      ],
      "decorators": [],
      "docstring": "Check if function is a FastAPI endpoint",
      "file_path": "generate_function_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 160,
      "line_start": 138,
      "module": "generate_function_docs",
      "name": "ApplicationDocumentationGenerator._check_for_api_endpoint",
      "signature": "def _check_for_api_endpoint(self, node: ast.FunctionDef, func_info: FunctionInfo):"
    },
    "generate_function_docs.ApplicationDocumentationGenerator._extract_function_calls": {
      "calls": [
        "calls.append",
        "set",
        "ast.walk",
        "list",
        "self._get_attribute_path",
        "isinstance"
      ],
      "decorators": [],
      "docstring": "Extract function calls within a function",
      "file_path": "generate_function_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 122,
      "line_start": 111,
      "module": "generate_function_docs",
      "name": "ApplicationDocumentationGenerator._extract_function_calls",
      "signature": "def _extract_function_calls(self, node: ast.FunctionDef) -> List[str]:"
    },
    "generate_function_docs.ApplicationDocumentationGenerator._extract_functions_from_ast": {
      "calls": [
        "self._check_for_api_endpoint",
        "self._extract_function_calls",
        "file_path.relative_to",
        "self._get_function_signature",
        "FunctionInfo",
        "ast.walk",
        "ast.get_docstring",
        "str",
        "isinstance",
        "content.split"
      ],
      "decorators": [],
      "docstring": "Extract function information from AST",
      "file_path": "generate_function_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 93,
      "line_start": 67,
      "module": "generate_function_docs",
      "name": "ApplicationDocumentationGenerator._extract_functions_from_ast",
      "signature": "def _extract_functions_from_ast(self, tree: ast.AST, file_path: Path, content: str):"
    },
    "generate_function_docs.ApplicationDocumentationGenerator._generate_data_flow_analysis": {
      "calls": [
        "join",
        "self.functions.values",
        "f.name.lower",
        "any",
        "next"
      ],
      "decorators": [],
      "docstring": "Generate data flow analysis",
      "file_path": "generate_function_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 248,
      "line_start": 222,
      "module": "generate_function_docs",
      "name": "ApplicationDocumentationGenerator._generate_data_flow_analysis",
      "signature": "def _generate_data_flow_analysis(self) -> str:"
    },
    "generate_function_docs.ApplicationDocumentationGenerator._get_attribute_path": {
      "calls": [
        "join",
        "isinstance",
        "reversed",
        "parts.append"
      ],
      "decorators": [],
      "docstring": "Get full attribute path like 'obj.method'",
      "file_path": "generate_function_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 136,
      "line_start": 124,
      "module": "generate_function_docs",
      "name": "ApplicationDocumentationGenerator._get_attribute_path",
      "signature": "def _get_attribute_path(self, node: ast.Attribute) -> str:"
    },
    "generate_function_docs.ApplicationDocumentationGenerator._get_function_signature": {
      "calls": [
        "strip",
        "join",
        "len",
        "min",
        "signature_lines.append",
        "line.endswith",
        "range"
      ],
      "decorators": [],
      "docstring": "Extract function signature from AST node",
      "file_path": "generate_function_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 109,
      "line_start": 95,
      "module": "generate_function_docs",
      "name": "ApplicationDocumentationGenerator._get_function_signature",
      "signature": "def _get_function_signature(self, node: ast.FunctionDef, lines: List[str]) -> str:"
    },
    "generate_function_docs.ApplicationDocumentationGenerator.analyze_python_files": {
      "calls": [
        "any",
        "self.project_root.rglob",
        "open",
        "f.read",
        "print",
        "list",
        "str",
        "self._extract_functions_from_ast",
        "ast.parse"
      ],
      "decorators": [],
      "docstring": "Analyze all Python files to extract function information",
      "file_path": "generate_function_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 65,
      "line_start": 49,
      "module": "generate_function_docs",
      "name": "ApplicationDocumentationGenerator.analyze_python_files",
      "signature": "def analyze_python_files(self):"
    },
    "generate_function_docs.ApplicationDocumentationGenerator.generate_documentation": {
      "calls": [
        "join",
        "self.functions.items",
        "endpoint.description.split",
        "len",
        "sorted",
        "append",
        "functions_by_file.items",
        "endpoints_by_file.items",
        "Path.cwd",
        "func.docstring.split",
        "self._generate_data_flow_analysis"
      ],
      "decorators": [],
      "docstring": "Generate comprehensive documentation",
      "file_path": "generate_function_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 220,
      "line_start": 162,
      "module": "generate_function_docs",
      "name": "ApplicationDocumentationGenerator.generate_documentation",
      "signature": "def generate_documentation(self) -> str:"
    },
    "generate_function_docs.ApplicationDocumentationGenerator.save_documentation": {
      "calls": [
        "len",
        "open",
        "print",
        "f.write",
        "self.analyze_python_files",
        "self.generate_documentation"
      ],
      "decorators": [],
      "docstring": "Save documentation to file",
      "file_path": "generate_function_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 260,
      "line_start": 250,
      "module": "generate_function_docs",
      "name": "ApplicationDocumentationGenerator.save_documentation",
      "signature": "def save_documentation(self, output_path: str):"
    },
    "generate_function_docs.__init__": {
      "calls": [
        "Path"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "generate_function_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 47,
      "line_start": 43,
      "module": "generate_function_docs",
      "name": "__init__",
      "signature": "def __init__(self, project_root: str):"
    },
    "generate_function_docs._check_for_api_endpoint": {
      "calls": [
        "isinstance",
        "self.api_endpoints.append",
        "APIEndpoint",
        "decorator.func.attr.upper"
      ],
      "decorators": [],
      "docstring": "Check if function is a FastAPI endpoint",
      "file_path": "generate_function_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 160,
      "line_start": 138,
      "module": "generate_function_docs",
      "name": "_check_for_api_endpoint",
      "signature": "def _check_for_api_endpoint(self, node: ast.FunctionDef, func_info: FunctionInfo):"
    },
    "generate_function_docs._extract_function_calls": {
      "calls": [
        "calls.append",
        "set",
        "ast.walk",
        "list",
        "self._get_attribute_path",
        "isinstance"
      ],
      "decorators": [],
      "docstring": "Extract function calls within a function",
      "file_path": "generate_function_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 122,
      "line_start": 111,
      "module": "generate_function_docs",
      "name": "_extract_function_calls",
      "signature": "def _extract_function_calls(self, node: ast.FunctionDef) -> List[str]:"
    },
    "generate_function_docs._extract_functions_from_ast": {
      "calls": [
        "self._check_for_api_endpoint",
        "self._extract_function_calls",
        "file_path.relative_to",
        "self._get_function_signature",
        "FunctionInfo",
        "ast.walk",
        "ast.get_docstring",
        "str",
        "isinstance",
        "content.split"
      ],
      "decorators": [],
      "docstring": "Extract function information from AST",
      "file_path": "generate_function_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 93,
      "line_start": 67,
      "module": "generate_function_docs",
      "name": "_extract_functions_from_ast",
      "signature": "def _extract_functions_from_ast(self, tree: ast.AST, file_path: Path, content: str):"
    },
    "generate_function_docs._generate_data_flow_analysis": {
      "calls": [
        "join",
        "self.functions.values",
        "f.name.lower",
        "any",
        "next"
      ],
      "decorators": [],
      "docstring": "Generate data flow analysis",
      "file_path": "generate_function_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 248,
      "line_start": 222,
      "module": "generate_function_docs",
      "name": "_generate_data_flow_analysis",
      "signature": "def _generate_data_flow_analysis(self) -> str:"
    },
    "generate_function_docs._get_attribute_path": {
      "calls": [
        "join",
        "isinstance",
        "reversed",
        "parts.append"
      ],
      "decorators": [],
      "docstring": "Get full attribute path like 'obj.method'",
      "file_path": "generate_function_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 136,
      "line_start": 124,
      "module": "generate_function_docs",
      "name": "_get_attribute_path",
      "signature": "def _get_attribute_path(self, node: ast.Attribute) -> str:"
    },
    "generate_function_docs._get_function_signature": {
      "calls": [
        "strip",
        "join",
        "len",
        "min",
        "signature_lines.append",
        "line.endswith",
        "range"
      ],
      "decorators": [],
      "docstring": "Extract function signature from AST node",
      "file_path": "generate_function_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 109,
      "line_start": 95,
      "module": "generate_function_docs",
      "name": "_get_function_signature",
      "signature": "def _get_function_signature(self, node: ast.FunctionDef, lines: List[str]) -> str:"
    },
    "generate_function_docs.analyze_python_files": {
      "calls": [
        "any",
        "self.project_root.rglob",
        "open",
        "f.read",
        "print",
        "list",
        "str",
        "self._extract_functions_from_ast",
        "ast.parse"
      ],
      "decorators": [],
      "docstring": "Analyze all Python files to extract function information",
      "file_path": "generate_function_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 65,
      "line_start": 49,
      "module": "generate_function_docs",
      "name": "analyze_python_files",
      "signature": "def analyze_python_files(self):"
    },
    "generate_function_docs.generate_documentation": {
      "calls": [
        "join",
        "self.functions.items",
        "endpoint.description.split",
        "len",
        "sorted",
        "append",
        "functions_by_file.items",
        "endpoints_by_file.items",
        "Path.cwd",
        "func.docstring.split",
        "self._generate_data_flow_analysis"
      ],
      "decorators": [],
      "docstring": "Generate comprehensive documentation",
      "file_path": "generate_function_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 220,
      "line_start": 162,
      "module": "generate_function_docs",
      "name": "generate_documentation",
      "signature": "def generate_documentation(self) -> str:"
    },
    "generate_function_docs.save_documentation": {
      "calls": [
        "len",
        "open",
        "print",
        "f.write",
        "self.analyze_python_files",
        "self.generate_documentation"
      ],
      "decorators": [],
      "docstring": "Save documentation to file",
      "file_path": "generate_function_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 260,
      "line_start": 250,
      "module": "generate_function_docs",
      "name": "save_documentation",
      "signature": "def save_documentation(self, output_path: str):"
    },
    "scripts.dev.auth_dev_bypass.apply_auth_bypass": {
      "calls": [
        "join",
        "lines.append",
        "lines.insert",
        "open",
        "line.startswith",
        "print",
        "f.read",
        "f.write",
        "enumerate",
        "content.split"
      ],
      "decorators": [],
      "docstring": "Apply the authentication bypass to the application",
      "file_path": "scripts/dev/auth_dev_bypass.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 91,
      "line_start": 50,
      "module": "scripts.dev.auth_dev_bypass",
      "name": "apply_auth_bypass",
      "signature": "def apply_auth_bypass():"
    },
    "scripts.dev.auth_dev_bypass.create_auth_bypass": {
      "calls": [
        "open",
        "print",
        "f.write"
      ],
      "decorators": [],
      "docstring": "Create a temporary authentication bypass",
      "file_path": "scripts/dev/auth_dev_bypass.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 48,
      "line_start": 17,
      "module": "scripts.dev.auth_dev_bypass",
      "name": "create_auth_bypass",
      "signature": "def create_auth_bypass():"
    },
    "scripts.dev.auth_dev_bypass.main": {
      "calls": [
        "create_auth_bypass",
        "apply_auth_bypass",
        "len",
        "print",
        "remove_auth_bypass"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "scripts/dev/auth_dev_bypass.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 153,
      "line_start": 131,
      "module": "scripts.dev.auth_dev_bypass",
      "name": "main",
      "signature": "def main():"
    },
    "scripts.dev.auth_dev_bypass.remove_auth_bypass": {
      "calls": [
        "Path",
        "join",
        "line.strip",
        "open",
        "line.startswith",
        "print",
        "f.read",
        "f.write",
        "clean_lines.append",
        "content.split",
        "bypass_file.exists",
        "bypass_file.unlink"
      ],
      "decorators": [],
      "docstring": "Remove the authentication bypass",
      "file_path": "scripts/dev/auth_dev_bypass.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 129,
      "line_start": 93,
      "module": "scripts.dev.auth_dev_bypass",
      "name": "remove_auth_bypass",
      "signature": "def remove_auth_bypass():"
    },
    "scripts.dev.comprehensive_integration_test.IntegratedApplicationTest.__init__": {
      "calls": [],
      "decorators": [],
      "docstring": null,
      "file_path": "scripts/dev/comprehensive_integration_test.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 43,
      "line_start": 39,
      "module": "scripts.dev.comprehensive_integration_test",
      "name": "IntegratedApplicationTest.__init__",
      "signature": "def __init__(self):"
    },
    "scripts.dev.comprehensive_integration_test.IntegratedApplicationTest.authenticate": {
      "calls": [
        "response.json",
        "TestResult",
        "requests.post",
        "str",
        "time.time"
      ],
      "decorators": [],
      "docstring": "Test authentication and get token",
      "file_path": "scripts/dev/comprehensive_integration_test.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 150,
      "line_start": 102,
      "module": "scripts.dev.comprehensive_integration_test",
      "name": "IntegratedApplicationTest.authenticate",
      "signature": "def authenticate(self) -> TestResult:"
    },
    "scripts.dev.comprehensive_integration_test.IntegratedApplicationTest.generate_test_report": {
      "calls": [
        "any",
        "len",
        "open",
        "datetime.now",
        "print",
        "categories.items",
        "sum",
        "append",
        "result.function_chain.lower",
        "isoformat",
        "json.dump"
      ],
      "decorators": [],
      "docstring": "Generate comprehensive test report",
      "file_path": "scripts/dev/comprehensive_integration_test.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 407,
      "line_start": 334,
      "module": "scripts.dev.comprehensive_integration_test",
      "name": "IntegratedApplicationTest.generate_test_report",
      "signature": "def generate_test_report(self, results: List[TestResult]):"
    },
    "scripts.dev.comprehensive_integration_test.IntegratedApplicationTest.run_comprehensive_tests": {
      "calls": [
        "self.authenticate",
        "results.append",
        "self.test_file_upload_chain",
        "TestResult",
        "print",
        "self.test_api_endpoint"
      ],
      "decorators": [],
      "docstring": "Run all comprehensive function chain tests",
      "file_path": "scripts/dev/comprehensive_integration_test.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 332,
      "line_start": 274,
      "module": "scripts.dev.comprehensive_integration_test",
      "name": "IntegratedApplicationTest.run_comprehensive_tests",
      "signature": "def run_comprehensive_tests(self) -> List[TestResult]:"
    },
    "scripts.dev.comprehensive_integration_test.IntegratedApplicationTest.run_full_test_suite": {
      "calls": [
        "print",
        "self.generate_test_report",
        "self.start_test_environment",
        "self.run_comprehensive_tests",
        "self.stop_test_environment"
      ],
      "decorators": [],
      "docstring": "Run the complete test suite",
      "file_path": "scripts/dev/comprehensive_integration_test.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 458,
      "line_start": 409,
      "module": "scripts.dev.comprehensive_integration_test",
      "name": "IntegratedApplicationTest.run_full_test_suite",
      "signature": "def run_full_test_suite(self):"
    },
    "scripts.dev.comprehensive_integration_test.IntegratedApplicationTest.start_test_environment": {
      "calls": [
        "print",
        "time.sleep",
        "subprocess.Popen",
        "range",
        "requests.get"
      ],
      "decorators": [],
      "docstring": "Start the application in test mode",
      "file_path": "scripts/dev/comprehensive_integration_test.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 88,
      "line_start": 45,
      "module": "scripts.dev.comprehensive_integration_test",
      "name": "IntegratedApplicationTest.start_test_environment",
      "signature": "def start_test_environment(self):"
    },
    "scripts.dev.comprehensive_integration_test.IntegratedApplicationTest.stop_test_environment": {
      "calls": [
        "self.server_process.terminate",
        "self.server_process.kill",
        "print",
        "self.server_process.wait"
      ],
      "decorators": [],
      "docstring": "Stop the test environment",
      "file_path": "scripts/dev/comprehensive_integration_test.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 100,
      "line_start": 90,
      "module": "scripts.dev.comprehensive_integration_test",
      "name": "IntegratedApplicationTest.stop_test_environment",
      "signature": "def stop_test_environment(self):"
    },
    "scripts.dev.comprehensive_integration_test.IntegratedApplicationTest.test_api_endpoint": {
      "calls": [
        "requests.put",
        "TestResult",
        "requests.delete",
        "requests.post",
        "str",
        "time.time",
        "ValueError",
        "requests.get"
      ],
      "decorators": [],
      "docstring": "Test a single API endpoint",
      "file_path": "scripts/dev/comprehensive_integration_test.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 193,
      "line_start": 152,
      "module": "scripts.dev.comprehensive_integration_test",
      "name": "IntegratedApplicationTest.test_api_endpoint",
      "signature": "def test_api_endpoint(self, method: str, endpoint: str, test_name: str, data: Optional[Dict] = None, expect_auth: bool = True) -> TestResult:"
    },
    "scripts.dev.comprehensive_integration_test.IntegratedApplicationTest.test_file_upload_chain": {
      "calls": [
        "data.get",
        "bytes",
        "TestResult",
        "open",
        "test_audio_path.unlink",
        "response.json",
        "f.write",
        "requests.post",
        "str",
        "time.time"
      ],
      "decorators": [],
      "docstring": "Test file upload functionality with a real test file",
      "file_path": "scripts/dev/comprehensive_integration_test.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 272,
      "line_start": 195,
      "module": "scripts.dev.comprehensive_integration_test",
      "name": "IntegratedApplicationTest.test_file_upload_chain",
      "signature": "def test_file_upload_chain(self) -> TestResult:"
    },
    "scripts.dev.comprehensive_integration_test.__init__": {
      "calls": [],
      "decorators": [],
      "docstring": null,
      "file_path": "scripts/dev/comprehensive_integration_test.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 43,
      "line_start": 39,
      "module": "scripts.dev.comprehensive_integration_test",
      "name": "__init__",
      "signature": "def __init__(self):"
    },
    "scripts.dev.comprehensive_integration_test.authenticate": {
      "calls": [
        "response.json",
        "TestResult",
        "requests.post",
        "str",
        "time.time"
      ],
      "decorators": [],
      "docstring": "Test authentication and get token",
      "file_path": "scripts/dev/comprehensive_integration_test.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 150,
      "line_start": 102,
      "module": "scripts.dev.comprehensive_integration_test",
      "name": "authenticate",
      "signature": "def authenticate(self) -> TestResult:"
    },
    "scripts.dev.comprehensive_integration_test.generate_test_report": {
      "calls": [
        "any",
        "len",
        "open",
        "datetime.now",
        "print",
        "categories.items",
        "sum",
        "append",
        "result.function_chain.lower",
        "isoformat",
        "json.dump"
      ],
      "decorators": [],
      "docstring": "Generate comprehensive test report",
      "file_path": "scripts/dev/comprehensive_integration_test.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 407,
      "line_start": 334,
      "module": "scripts.dev.comprehensive_integration_test",
      "name": "generate_test_report",
      "signature": "def generate_test_report(self, results: List[TestResult]):"
    },
    "scripts.dev.comprehensive_integration_test.main": {
      "calls": [
        "tester.run_full_test_suite",
        "IntegratedApplicationTest",
        "sys.exit"
      ],
      "decorators": [],
      "docstring": "Main entry point",
      "file_path": "scripts/dev/comprehensive_integration_test.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 466,
      "line_start": 460,
      "module": "scripts.dev.comprehensive_integration_test",
      "name": "main",
      "signature": "def main():"
    },
    "scripts.dev.comprehensive_integration_test.run_comprehensive_tests": {
      "calls": [
        "self.authenticate",
        "results.append",
        "self.test_file_upload_chain",
        "TestResult",
        "print",
        "self.test_api_endpoint"
      ],
      "decorators": [],
      "docstring": "Run all comprehensive function chain tests",
      "file_path": "scripts/dev/comprehensive_integration_test.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 332,
      "line_start": 274,
      "module": "scripts.dev.comprehensive_integration_test",
      "name": "run_comprehensive_tests",
      "signature": "def run_comprehensive_tests(self) -> List[TestResult]:"
    },
    "scripts.dev.comprehensive_integration_test.run_full_test_suite": {
      "calls": [
        "print",
        "self.generate_test_report",
        "self.start_test_environment",
        "self.run_comprehensive_tests",
        "self.stop_test_environment"
      ],
      "decorators": [],
      "docstring": "Run the complete test suite",
      "file_path": "scripts/dev/comprehensive_integration_test.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 458,
      "line_start": 409,
      "module": "scripts.dev.comprehensive_integration_test",
      "name": "run_full_test_suite",
      "signature": "def run_full_test_suite(self):"
    },
    "scripts.dev.comprehensive_integration_test.start_test_environment": {
      "calls": [
        "print",
        "time.sleep",
        "subprocess.Popen",
        "range",
        "requests.get"
      ],
      "decorators": [],
      "docstring": "Start the application in test mode",
      "file_path": "scripts/dev/comprehensive_integration_test.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 88,
      "line_start": 45,
      "module": "scripts.dev.comprehensive_integration_test",
      "name": "start_test_environment",
      "signature": "def start_test_environment(self):"
    },
    "scripts.dev.comprehensive_integration_test.stop_test_environment": {
      "calls": [
        "self.server_process.terminate",
        "self.server_process.kill",
        "print",
        "self.server_process.wait"
      ],
      "decorators": [],
      "docstring": "Stop the test environment",
      "file_path": "scripts/dev/comprehensive_integration_test.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 100,
      "line_start": 90,
      "module": "scripts.dev.comprehensive_integration_test",
      "name": "stop_test_environment",
      "signature": "def stop_test_environment(self):"
    },
    "scripts.dev.comprehensive_integration_test.test_api_endpoint": {
      "calls": [
        "requests.put",
        "TestResult",
        "requests.delete",
        "requests.post",
        "str",
        "time.time",
        "ValueError",
        "requests.get"
      ],
      "decorators": [],
      "docstring": "Test a single API endpoint",
      "file_path": "scripts/dev/comprehensive_integration_test.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 193,
      "line_start": 152,
      "module": "scripts.dev.comprehensive_integration_test",
      "name": "test_api_endpoint",
      "signature": "def test_api_endpoint(self, method: str, endpoint: str, test_name: str, data: Optional[Dict] = None, expect_auth: bool = True) -> TestResult:"
    },
    "scripts.dev.comprehensive_integration_test.test_file_upload_chain": {
      "calls": [
        "data.get",
        "bytes",
        "TestResult",
        "open",
        "test_audio_path.unlink",
        "response.json",
        "f.write",
        "requests.post",
        "str",
        "time.time"
      ],
      "decorators": [],
      "docstring": "Test file upload functionality with a real test file",
      "file_path": "scripts/dev/comprehensive_integration_test.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 272,
      "line_start": 195,
      "module": "scripts.dev.comprehensive_integration_test",
      "name": "test_file_upload_chain",
      "signature": "def test_file_upload_chain(self) -> TestResult:"
    },
    "scripts.dev.fix_authentication.AuthenticationFixer.__init__": {
      "calls": [],
      "decorators": [],
      "docstring": null,
      "file_path": "scripts/dev/fix_authentication.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 25,
      "line_start": 23,
      "module": "scripts.dev.fix_authentication",
      "name": "AuthenticationFixer.__init__",
      "signature": "def __init__(self):"
    },
    "scripts.dev.fix_authentication.AuthenticationFixer.create_users": {
      "calls": [
        "get_user_by_username",
        "print",
        "create_user",
        "created_users.append",
        "verify_password"
      ],
      "decorators": [],
      "docstring": "Create and verify users",
      "file_path": "scripts/dev/fix_authentication.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 87,
      "line_start": 52,
      "module": "scripts.dev.fix_authentication",
      "name": "AuthenticationFixer.create_users",
      "signature": "def create_users(self):"
    },
    "scripts.dev.fix_authentication.AuthenticationFixer.reset_database": {
      "calls": [
        "Path",
        "join",
        "inspect",
        "print",
        "db_file.exists",
        "db_file.unlink",
        "Base.metadata.create_all",
        "inspector.get_table_names"
      ],
      "decorators": [],
      "docstring": "Completely reset the database",
      "file_path": "scripts/dev/fix_authentication.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 50,
      "line_start": 27,
      "module": "scripts.dev.fix_authentication",
      "name": "AuthenticationFixer.reset_database",
      "signature": "def reset_database(self):"
    },
    "scripts.dev.fix_authentication.AuthenticationFixer.run_complete_fix": {
      "calls": [
        "self.reset_database",
        "self.test_authenticated_endpoints",
        "len",
        "print",
        "self.test_authentication",
        "self.create_users",
        "self.test_file_upload_with_auth",
        "self.start_server"
      ],
      "decorators": [],
      "docstring": "Run the complete authentication fix and test",
      "file_path": "scripts/dev/fix_authentication.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 362,
      "line_start": 284,
      "module": "scripts.dev.fix_authentication",
      "name": "AuthenticationFixer.run_complete_fix",
      "signature": "def run_complete_fix(self):"
    },
    "scripts.dev.fix_authentication.AuthenticationFixer.start_server": {
      "calls": [
        "print",
        "range",
        "subprocess.Popen",
        "time.sleep",
        "requests.get"
      ],
      "decorators": [],
      "docstring": "Start the server with clean database",
      "file_path": "scripts/dev/fix_authentication.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 120,
      "line_start": 89,
      "module": "scripts.dev.fix_authentication",
      "name": "AuthenticationFixer.start_server",
      "signature": "def start_server(self):"
    },
    "scripts.dev.fix_authentication.AuthenticationFixer.stop_server": {
      "calls": [
        "self.server_process.terminate",
        "self.server_process.kill",
        "print",
        "self.server_process.wait"
      ],
      "decorators": [],
      "docstring": "Stop the test server",
      "file_path": "scripts/dev/fix_authentication.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 282,
      "line_start": 272,
      "module": "scripts.dev.fix_authentication",
      "name": "AuthenticationFixer.stop_server",
      "signature": "def stop_server(self):"
    },
    "scripts.dev.fix_authentication.AuthenticationFixer.test_authenticated_endpoints": {
      "calls": [
        "len",
        "print",
        "requests.get"
      ],
      "decorators": [],
      "docstring": "Test endpoints that require authentication",
      "file_path": "scripts/dev/fix_authentication.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 201,
      "line_start": 151,
      "module": "scripts.dev.fix_authentication",
      "name": "AuthenticationFixer.test_authenticated_endpoints",
      "signature": "def test_authenticated_endpoints(self, successful_logins):"
    },
    "scripts.dev.fix_authentication.AuthenticationFixer.test_authentication": {
      "calls": [
        "print",
        "requests.post",
        "successful_logins.append",
        "response.json"
      ],
      "decorators": [],
      "docstring": "Test authentication for all users",
      "file_path": "scripts/dev/fix_authentication.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 149,
      "line_start": 122,
      "module": "scripts.dev.fix_authentication",
      "name": "AuthenticationFixer.test_authentication",
      "signature": "def test_authentication(self, users):"
    },
    "scripts.dev.fix_authentication.AuthenticationFixer.test_file_upload_with_auth": {
      "calls": [
        "bytes",
        "open",
        "response.json",
        "test_audio_path.unlink",
        "print",
        "f.write",
        "requests.post",
        "result_data.get"
      ],
      "decorators": [],
      "docstring": "Test file upload with authentication",
      "file_path": "scripts/dev/fix_authentication.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 270,
      "line_start": 203,
      "module": "scripts.dev.fix_authentication",
      "name": "AuthenticationFixer.test_file_upload_with_auth",
      "signature": "def test_file_upload_with_auth(self, successful_logins):"
    },
    "scripts.dev.fix_authentication.__init__": {
      "calls": [],
      "decorators": [],
      "docstring": null,
      "file_path": "scripts/dev/fix_authentication.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 25,
      "line_start": 23,
      "module": "scripts.dev.fix_authentication",
      "name": "__init__",
      "signature": "def __init__(self):"
    },
    "scripts.dev.fix_authentication.create_users": {
      "calls": [
        "get_user_by_username",
        "print",
        "create_user",
        "created_users.append",
        "verify_password"
      ],
      "decorators": [],
      "docstring": "Create and verify users",
      "file_path": "scripts/dev/fix_authentication.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 87,
      "line_start": 52,
      "module": "scripts.dev.fix_authentication",
      "name": "create_users",
      "signature": "def create_users(self):"
    },
    "scripts.dev.fix_authentication.main": {
      "calls": [
        "print",
        "fixer.run_complete_fix",
        "AuthenticationFixer"
      ],
      "decorators": [],
      "docstring": "Main entry point",
      "file_path": "scripts/dev/fix_authentication.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 373,
      "line_start": 364,
      "module": "scripts.dev.fix_authentication",
      "name": "main",
      "signature": "def main():"
    },
    "scripts.dev.fix_authentication.reset_database": {
      "calls": [
        "Path",
        "join",
        "inspect",
        "print",
        "db_file.exists",
        "db_file.unlink",
        "Base.metadata.create_all",
        "inspector.get_table_names"
      ],
      "decorators": [],
      "docstring": "Completely reset the database",
      "file_path": "scripts/dev/fix_authentication.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 50,
      "line_start": 27,
      "module": "scripts.dev.fix_authentication",
      "name": "reset_database",
      "signature": "def reset_database(self):"
    },
    "scripts.dev.fix_authentication.run_complete_fix": {
      "calls": [
        "self.reset_database",
        "self.test_authenticated_endpoints",
        "len",
        "print",
        "self.test_authentication",
        "self.create_users",
        "self.test_file_upload_with_auth",
        "self.start_server"
      ],
      "decorators": [],
      "docstring": "Run the complete authentication fix and test",
      "file_path": "scripts/dev/fix_authentication.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 362,
      "line_start": 284,
      "module": "scripts.dev.fix_authentication",
      "name": "run_complete_fix",
      "signature": "def run_complete_fix(self):"
    },
    "scripts.dev.fix_authentication.start_server": {
      "calls": [
        "print",
        "range",
        "subprocess.Popen",
        "time.sleep",
        "requests.get"
      ],
      "decorators": [],
      "docstring": "Start the server with clean database",
      "file_path": "scripts/dev/fix_authentication.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 120,
      "line_start": 89,
      "module": "scripts.dev.fix_authentication",
      "name": "start_server",
      "signature": "def start_server(self):"
    },
    "scripts.dev.fix_authentication.stop_server": {
      "calls": [
        "self.server_process.terminate",
        "self.server_process.kill",
        "print",
        "self.server_process.wait"
      ],
      "decorators": [],
      "docstring": "Stop the test server",
      "file_path": "scripts/dev/fix_authentication.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 282,
      "line_start": 272,
      "module": "scripts.dev.fix_authentication",
      "name": "stop_server",
      "signature": "def stop_server(self):"
    },
    "scripts.dev.fix_authentication.test_authenticated_endpoints": {
      "calls": [
        "len",
        "print",
        "requests.get"
      ],
      "decorators": [],
      "docstring": "Test endpoints that require authentication",
      "file_path": "scripts/dev/fix_authentication.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 201,
      "line_start": 151,
      "module": "scripts.dev.fix_authentication",
      "name": "test_authenticated_endpoints",
      "signature": "def test_authenticated_endpoints(self, successful_logins):"
    },
    "scripts.dev.fix_authentication.test_authentication": {
      "calls": [
        "print",
        "requests.post",
        "successful_logins.append",
        "response.json"
      ],
      "decorators": [],
      "docstring": "Test authentication for all users",
      "file_path": "scripts/dev/fix_authentication.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 149,
      "line_start": 122,
      "module": "scripts.dev.fix_authentication",
      "name": "test_authentication",
      "signature": "def test_authentication(self, users):"
    },
    "scripts.dev.fix_authentication.test_file_upload_with_auth": {
      "calls": [
        "bytes",
        "open",
        "response.json",
        "test_audio_path.unlink",
        "print",
        "f.write",
        "requests.post",
        "result_data.get"
      ],
      "decorators": [],
      "docstring": "Test file upload with authentication",
      "file_path": "scripts/dev/fix_authentication.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 270,
      "line_start": 203,
      "module": "scripts.dev.fix_authentication",
      "name": "test_file_upload_with_auth",
      "signature": "def test_file_upload_with_auth(self, successful_logins):"
    },
    "scripts.dev.full_stack_function_mapper.FullStackMapper.__init__": {
      "calls": [],
      "decorators": [],
      "docstring": null,
      "file_path": "scripts/dev/full_stack_function_mapper.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 56,
      "line_start": 53,
      "module": "scripts.dev.full_stack_function_mapper",
      "name": "FullStackMapper.__init__",
      "signature": "def __init__(self, base_url=\"http://localhost:8000\"):"
    },
    "scripts.dev.full_stack_function_mapper.FullStackMapper.define_function_chains": {
      "calls": [
        "self.function_chains.extend",
        "FunctionChain"
      ],
      "decorators": [],
      "docstring": "Define all user action \u2192 backend function chains",
      "file_path": "scripts/dev/full_stack_function_mapper.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 255,
      "line_start": 58,
      "module": "scripts.dev.full_stack_function_mapper",
      "name": "FullStackMapper.define_function_chains",
      "signature": "def define_function_chains(self):"
    },
    "scripts.dev.full_stack_function_mapper.FullStackMapper.generate_dependency_graph": {
      "calls": [
        "extend",
        "open",
        "print",
        "append",
        "json.dump"
      ],
      "decorators": [],
      "docstring": "Generate a visual dependency graph of all function chains",
      "file_path": "scripts/dev/full_stack_function_mapper.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 463,
      "line_start": 424,
      "module": "scripts.dev.full_stack_function_mapper",
      "name": "FullStackMapper.generate_dependency_graph",
      "signature": "def generate_dependency_graph(self):"
    },
    "scripts.dev.full_stack_function_mapper.FullStackMapper.run_all_tests": {
      "calls": [
        "len",
        "open",
        "print",
        "append",
        "enumerate",
        "self.define_function_chains",
        "self.test_function_chain",
        "json.dump"
      ],
      "decorators": [],
      "docstring": "Run all function chain tests",
      "file_path": "scripts/dev/full_stack_function_mapper.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 422,
      "line_start": 383,
      "module": "scripts.dev.full_stack_function_mapper",
      "name": "FullStackMapper.run_all_tests",
      "signature": "async def run_all_tests(self):"
    },
    "scripts.dev.full_stack_function_mapper.FullStackMapper.test_api_chain": {
      "calls": [
        "join",
        "endpoint.replace",
        "chain.frontend_function.lower",
        "requests.put",
        "chain.api_endpoint.split",
        "requests.delete",
        "requests.post",
        "str",
        "chain.test_data.items",
        "requests.get"
      ],
      "decorators": [],
      "docstring": "Test a complete API function chain",
      "file_path": "scripts/dev/full_stack_function_mapper.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 337,
      "line_start": 290,
      "module": "scripts.dev.full_stack_function_mapper",
      "name": "FullStackMapper.test_api_chain",
      "signature": "async def test_api_chain(self, chain: FunctionChain) -> Tuple[bool, str]:"
    },
    "scripts.dev.full_stack_function_mapper.FullStackMapper.test_authentication_chain": {
      "calls": [
        "requests.post",
        "str",
        "response.json"
      ],
      "decorators": [],
      "docstring": "Test authentication function chain",
      "file_path": "scripts/dev/full_stack_function_mapper.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 288,
      "line_start": 257,
      "module": "scripts.dev.full_stack_function_mapper",
      "name": "FullStackMapper.test_authentication_chain",
      "signature": "async def test_authentication_chain(self, chain: FunctionChain) -> Tuple[bool, str]:"
    },
    "scripts.dev.full_stack_function_mapper.FullStackMapper.test_function_chain": {
      "calls": [
        "datetime.now",
        "print",
        "self.test_websocket_chain",
        "time.time",
        "chain.api_endpoint.lower",
        "chain.api_endpoint.startswith",
        "self.test_api_chain",
        "self.test_authentication_chain",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Test a complete function chain",
      "file_path": "scripts/dev/full_stack_function_mapper.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 381,
      "line_start": 348,
      "module": "scripts.dev.full_stack_function_mapper",
      "name": "FullStackMapper.test_function_chain",
      "signature": "async def test_function_chain(self, chain: FunctionChain) -> Dict[str, Any]:"
    },
    "scripts.dev.full_stack_function_mapper.FullStackMapper.test_websocket_chain": {
      "calls": [
        "str"
      ],
      "decorators": [],
      "docstring": "Test WebSocket function chain",
      "file_path": "scripts/dev/full_stack_function_mapper.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 346,
      "line_start": 339,
      "module": "scripts.dev.full_stack_function_mapper",
      "name": "FullStackMapper.test_websocket_chain",
      "signature": "async def test_websocket_chain(self, chain: FunctionChain) -> Tuple[bool, str]:"
    },
    "scripts.dev.full_stack_function_mapper.__init__": {
      "calls": [],
      "decorators": [],
      "docstring": null,
      "file_path": "scripts/dev/full_stack_function_mapper.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 56,
      "line_start": 53,
      "module": "scripts.dev.full_stack_function_mapper",
      "name": "__init__",
      "signature": "def __init__(self, base_url=\"http://localhost:8000\"):"
    },
    "scripts.dev.full_stack_function_mapper.define_function_chains": {
      "calls": [
        "self.function_chains.extend",
        "FunctionChain"
      ],
      "decorators": [],
      "docstring": "Define all user action \u2192 backend function chains",
      "file_path": "scripts/dev/full_stack_function_mapper.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 255,
      "line_start": 58,
      "module": "scripts.dev.full_stack_function_mapper",
      "name": "define_function_chains",
      "signature": "def define_function_chains(self):"
    },
    "scripts.dev.full_stack_function_mapper.generate_dependency_graph": {
      "calls": [
        "extend",
        "open",
        "print",
        "append",
        "json.dump"
      ],
      "decorators": [],
      "docstring": "Generate a visual dependency graph of all function chains",
      "file_path": "scripts/dev/full_stack_function_mapper.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 463,
      "line_start": 424,
      "module": "scripts.dev.full_stack_function_mapper",
      "name": "generate_dependency_graph",
      "signature": "def generate_dependency_graph(self):"
    },
    "scripts.dev.full_stack_function_mapper.main": {
      "calls": [
        "mapper.define_function_chains",
        "FullStackMapper",
        "mapper.generate_dependency_graph",
        "print",
        "mapper.run_all_tests"
      ],
      "decorators": [],
      "docstring": "Main execution function",
      "file_path": "scripts/dev/full_stack_function_mapper.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 486,
      "line_start": 465,
      "module": "scripts.dev.full_stack_function_mapper",
      "name": "main",
      "signature": "async def main():"
    },
    "scripts.dev.full_stack_function_mapper.run_all_tests": {
      "calls": [
        "len",
        "open",
        "print",
        "append",
        "enumerate",
        "self.define_function_chains",
        "self.test_function_chain",
        "json.dump"
      ],
      "decorators": [],
      "docstring": "Run all function chain tests",
      "file_path": "scripts/dev/full_stack_function_mapper.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 422,
      "line_start": 383,
      "module": "scripts.dev.full_stack_function_mapper",
      "name": "run_all_tests",
      "signature": "async def run_all_tests(self):"
    },
    "scripts.dev.full_stack_function_mapper.test_api_chain": {
      "calls": [
        "join",
        "endpoint.replace",
        "chain.frontend_function.lower",
        "requests.put",
        "chain.api_endpoint.split",
        "requests.delete",
        "requests.post",
        "str",
        "chain.test_data.items",
        "requests.get"
      ],
      "decorators": [],
      "docstring": "Test a complete API function chain",
      "file_path": "scripts/dev/full_stack_function_mapper.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 337,
      "line_start": 290,
      "module": "scripts.dev.full_stack_function_mapper",
      "name": "test_api_chain",
      "signature": "async def test_api_chain(self, chain: FunctionChain) -> Tuple[bool, str]:"
    },
    "scripts.dev.full_stack_function_mapper.test_authentication_chain": {
      "calls": [
        "requests.post",
        "str",
        "response.json"
      ],
      "decorators": [],
      "docstring": "Test authentication function chain",
      "file_path": "scripts/dev/full_stack_function_mapper.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 288,
      "line_start": 257,
      "module": "scripts.dev.full_stack_function_mapper",
      "name": "test_authentication_chain",
      "signature": "async def test_authentication_chain(self, chain: FunctionChain) -> Tuple[bool, str]:"
    },
    "scripts.dev.full_stack_function_mapper.test_function_chain": {
      "calls": [
        "datetime.now",
        "print",
        "self.test_websocket_chain",
        "time.time",
        "chain.api_endpoint.lower",
        "chain.api_endpoint.startswith",
        "self.test_api_chain",
        "self.test_authentication_chain",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Test a complete function chain",
      "file_path": "scripts/dev/full_stack_function_mapper.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 381,
      "line_start": 348,
      "module": "scripts.dev.full_stack_function_mapper",
      "name": "test_function_chain",
      "signature": "async def test_function_chain(self, chain: FunctionChain) -> Dict[str, Any]:"
    },
    "scripts.dev.full_stack_function_mapper.test_websocket_chain": {
      "calls": [
        "str"
      ],
      "decorators": [],
      "docstring": "Test WebSocket function chain",
      "file_path": "scripts/dev/full_stack_function_mapper.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 346,
      "line_start": 339,
      "module": "scripts.dev.full_stack_function_mapper",
      "name": "test_websocket_chain",
      "signature": "async def test_websocket_chain(self, chain: FunctionChain) -> Tuple[bool, str]:"
    },
    "scripts.dev.init_sqlite_dev.init_sqlite_dev_db": {
      "calls": [
        "get_user_by_username",
        "print",
        "create_user",
        "Base.metadata.create_all",
        "verify_password"
      ],
      "decorators": [],
      "docstring": "Initialize SQLite database for development",
      "file_path": "scripts/dev/init_sqlite_dev.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 54,
      "line_start": 15,
      "module": "scripts.dev.init_sqlite_dev",
      "name": "init_sqlite_dev_db",
      "signature": "def init_sqlite_dev_db():"
    },
    "scripts.dev.init_sqlite_dev.main": {
      "calls": [
        "test_authentication",
        "print",
        "init_sqlite_dev_db"
      ],
      "decorators": [],
      "docstring": "Main function",
      "file_path": "scripts/dev/init_sqlite_dev.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 118,
      "line_start": 88,
      "module": "scripts.dev.init_sqlite_dev",
      "name": "main",
      "signature": "def main():"
    },
    "scripts.dev.init_sqlite_dev.test_authentication": {
      "calls": [
        "print",
        "requests.post",
        "response.json"
      ],
      "decorators": [],
      "docstring": "Test authentication with the created users",
      "file_path": "scripts/dev/init_sqlite_dev.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 86,
      "line_start": 56,
      "module": "scripts.dev.init_sqlite_dev",
      "name": "test_authentication",
      "signature": "def test_authentication():"
    },
    "scripts.dev.test_all_functions.APITests.test_api_route_modules": {
      "calls": [
        "str",
        "importlib.import_module",
        "log_test",
        "module_name.split"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Test that API route modules can be imported.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 229,
      "line_start": 217,
      "module": "scripts.dev.test_all_functions",
      "name": "APITests.test_api_route_modules",
      "signature": "def test_api_route_modules():"
    },
    "scripts.dev.test_all_functions.APITests.test_fastapi_app_creation": {
      "calls": [
        "hasattr",
        "str",
        "log_test",
        "len"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Test that FastAPI app can be created.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 214,
      "line_start": 197,
      "module": "scripts.dev.test_all_functions",
      "name": "APITests.test_fastapi_app_creation",
      "signature": "def test_fastapi_app_creation():"
    },
    "scripts.dev.test_all_functions.ConfigurationTests.test_environment_variables": {
      "calls": [
        "log_test",
        "os.getenv",
        "len"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Test environment variable handling.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 150,
      "line_start": 138,
      "module": "scripts.dev.test_all_functions",
      "name": "ConfigurationTests.test_environment_variables",
      "signature": "def test_environment_variables():"
    },
    "scripts.dev.test_all_functions.ConfigurationTests.test_settings_loading": {
      "calls": [
        "str",
        "log_test"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Test that settings can be loaded correctly.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 135,
      "line_start": 113,
      "module": "scripts.dev.test_all_functions",
      "name": "ConfigurationTests.test_settings_loading",
      "signature": "def test_settings_loading():"
    },
    "scripts.dev.test_all_functions.ContainerTests.test_container_services": {
      "calls": [
        "join",
        "str",
        "result.stdout.strip",
        "ContainerTests.test_docker_availability",
        "log_test",
        "subprocess.run",
        "split"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Test if application containers are running.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 321,
      "line_start": 289,
      "module": "scripts.dev.test_all_functions",
      "name": "ContainerTests.test_container_services",
      "signature": "def test_container_services():"
    },
    "scripts.dev.test_all_functions.ContainerTests.test_docker_availability": {
      "calls": [
        "log_test",
        "result.stdout.strip",
        "str",
        "subprocess.run"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Test if Docker is available and working.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 286,
      "line_start": 274,
      "module": "scripts.dev.test_all_functions",
      "name": "ContainerTests.test_docker_availability",
      "signature": "def test_docker_availability():"
    },
    "scripts.dev.test_all_functions.DatabaseTests.test_database_models": {
      "calls": [
        "str",
        "log_test",
        "len"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Test that database models can be imported and defined.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 168,
      "line_start": 156,
      "module": "scripts.dev.test_all_functions",
      "name": "DatabaseTests.test_database_models",
      "signature": "def test_database_models():"
    },
    "scripts.dev.test_all_functions.DatabaseTests.test_migrations": {
      "calls": [
        "len",
        "migrations_dir.glob",
        "open",
        "f.read",
        "list",
        "str",
        "log_test",
        "migrations_dir.exists"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Test that migration files exist and are valid.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 191,
      "line_start": 171,
      "module": "scripts.dev.test_all_functions",
      "name": "DatabaseTests.test_migrations",
      "signature": "def test_migrations():"
    },
    "scripts.dev.test_all_functions.InfrastructureTests.test_file_structure": {
      "calls": [
        "path.exists",
        "log_test"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Test that all required files and directories exist.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 93,
      "line_start": 79,
      "module": "scripts.dev.test_all_functions",
      "name": "InfrastructureTests.test_file_structure",
      "signature": "def test_file_structure():"
    },
    "scripts.dev.test_all_functions.InfrastructureTests.test_model_files": {
      "calls": [
        "model_path.stat",
        "log_test",
        "model_path.exists"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Test that required Whisper model files exist.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 107,
      "line_start": 96,
      "module": "scripts.dev.test_all_functions",
      "name": "InfrastructureTests.test_model_files",
      "signature": "def test_model_files():"
    },
    "scripts.dev.test_all_functions.InfrastructureTests.test_python_imports": {
      "calls": [
        "str",
        "__import__",
        "log_test"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Test that all required Python modules can be imported.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 76,
      "line_start": 63,
      "module": "scripts.dev.test_all_functions",
      "name": "InfrastructureTests.test_python_imports",
      "signature": "def test_python_imports():"
    },
    "scripts.dev.test_all_functions.UtilityTests.test_logging_setup": {
      "calls": [
        "get_system_logger",
        "str",
        "log_test"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Test logging configuration.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 334,
      "line_start": 327,
      "module": "scripts.dev.test_all_functions",
      "name": "UtilityTests.test_logging_setup",
      "signature": "def test_logging_setup():"
    },
    "scripts.dev.test_all_functions.UtilityTests.test_path_configuration": {
      "calls": [
        "str",
        "path.exists",
        "log_test"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Test path configuration.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 355,
      "line_start": 337,
      "module": "scripts.dev.test_all_functions",
      "name": "UtilityTests.test_path_configuration",
      "signature": "def test_path_configuration():"
    },
    "scripts.dev.test_all_functions.WorkerTests.test_celery_app_creation": {
      "calls": [
        "len",
        "list",
        "str",
        "log_test",
        "celery_app.tasks.keys"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Test that Celery app can be created.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 246,
      "line_start": 235,
      "module": "scripts.dev.test_all_functions",
      "name": "WorkerTests.test_celery_app_creation",
      "signature": "def test_celery_app_creation():"
    },
    "scripts.dev.test_all_functions.WorkerTests.test_whisper_model_loading": {
      "calls": [
        "tiny_model.exists",
        "str",
        "hasattr",
        "log_test"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Test that Whisper models can be loaded.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 268,
      "line_start": 249,
      "module": "scripts.dev.test_all_functions",
      "name": "WorkerTests.test_whisper_model_loading",
      "signature": "def test_whisper_model_loading():"
    },
    "scripts.dev.test_all_functions.log_test": {
      "calls": [
        "append",
        "status.lower",
        "print",
        "get"
      ],
      "decorators": [],
      "docstring": "Log a test result.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 57,
      "line_start": 39,
      "module": "scripts.dev.test_all_functions",
      "name": "log_test",
      "signature": "def log_test(category: str, test_name: str, status: str, details: str = \"\", error: str = \"\"):"
    },
    "scripts.dev.test_all_functions.main": {
      "calls": [
        "sys.exit",
        "argparse.ArgumentParser",
        "parser.add_argument",
        "run_all_tests",
        "parser.parse_args"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 423,
      "line_start": 409,
      "module": "scripts.dev.test_all_functions",
      "name": "main",
      "signature": "def main():"
    },
    "scripts.dev.test_all_functions.run_all_tests": {
      "calls": [
        "getattr",
        "method_name.startswith",
        "dir",
        "open",
        "print",
        "test_categories.append",
        "str",
        "method",
        "traceback.print_exc",
        "log_test",
        "json.dump"
      ],
      "decorators": [],
      "docstring": "Run all test categories.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 407,
      "line_start": 357,
      "module": "scripts.dev.test_all_functions",
      "name": "run_all_tests",
      "signature": "def run_all_tests(test_local=True, test_containers=False, verbose=False):"
    },
    "scripts.dev.test_all_functions.test_api_route_modules": {
      "calls": [
        "str",
        "importlib.import_module",
        "log_test",
        "module_name.split"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Test that API route modules can be imported.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 229,
      "line_start": 217,
      "module": "scripts.dev.test_all_functions",
      "name": "test_api_route_modules",
      "signature": "def test_api_route_modules():"
    },
    "scripts.dev.test_all_functions.test_celery_app_creation": {
      "calls": [
        "len",
        "list",
        "str",
        "log_test",
        "celery_app.tasks.keys"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Test that Celery app can be created.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 246,
      "line_start": 235,
      "module": "scripts.dev.test_all_functions",
      "name": "test_celery_app_creation",
      "signature": "def test_celery_app_creation():"
    },
    "scripts.dev.test_all_functions.test_container_services": {
      "calls": [
        "join",
        "str",
        "result.stdout.strip",
        "ContainerTests.test_docker_availability",
        "log_test",
        "subprocess.run",
        "split"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Test if application containers are running.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 321,
      "line_start": 289,
      "module": "scripts.dev.test_all_functions",
      "name": "test_container_services",
      "signature": "def test_container_services():"
    },
    "scripts.dev.test_all_functions.test_database_models": {
      "calls": [
        "str",
        "log_test",
        "len"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Test that database models can be imported and defined.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 168,
      "line_start": 156,
      "module": "scripts.dev.test_all_functions",
      "name": "test_database_models",
      "signature": "def test_database_models():"
    },
    "scripts.dev.test_all_functions.test_docker_availability": {
      "calls": [
        "log_test",
        "result.stdout.strip",
        "str",
        "subprocess.run"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Test if Docker is available and working.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 286,
      "line_start": 274,
      "module": "scripts.dev.test_all_functions",
      "name": "test_docker_availability",
      "signature": "def test_docker_availability():"
    },
    "scripts.dev.test_all_functions.test_environment_variables": {
      "calls": [
        "log_test",
        "os.getenv",
        "len"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Test environment variable handling.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 150,
      "line_start": 138,
      "module": "scripts.dev.test_all_functions",
      "name": "test_environment_variables",
      "signature": "def test_environment_variables():"
    },
    "scripts.dev.test_all_functions.test_fastapi_app_creation": {
      "calls": [
        "hasattr",
        "str",
        "log_test",
        "len"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Test that FastAPI app can be created.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 214,
      "line_start": 197,
      "module": "scripts.dev.test_all_functions",
      "name": "test_fastapi_app_creation",
      "signature": "def test_fastapi_app_creation():"
    },
    "scripts.dev.test_all_functions.test_file_structure": {
      "calls": [
        "path.exists",
        "log_test"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Test that all required files and directories exist.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 93,
      "line_start": 79,
      "module": "scripts.dev.test_all_functions",
      "name": "test_file_structure",
      "signature": "def test_file_structure():"
    },
    "scripts.dev.test_all_functions.test_logging_setup": {
      "calls": [
        "get_system_logger",
        "str",
        "log_test"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Test logging configuration.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 334,
      "line_start": 327,
      "module": "scripts.dev.test_all_functions",
      "name": "test_logging_setup",
      "signature": "def test_logging_setup():"
    },
    "scripts.dev.test_all_functions.test_migrations": {
      "calls": [
        "len",
        "migrations_dir.glob",
        "open",
        "f.read",
        "list",
        "str",
        "log_test",
        "migrations_dir.exists"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Test that migration files exist and are valid.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 191,
      "line_start": 171,
      "module": "scripts.dev.test_all_functions",
      "name": "test_migrations",
      "signature": "def test_migrations():"
    },
    "scripts.dev.test_all_functions.test_model_files": {
      "calls": [
        "model_path.stat",
        "log_test",
        "model_path.exists"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Test that required Whisper model files exist.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 107,
      "line_start": 96,
      "module": "scripts.dev.test_all_functions",
      "name": "test_model_files",
      "signature": "def test_model_files():"
    },
    "scripts.dev.test_all_functions.test_path_configuration": {
      "calls": [
        "str",
        "path.exists",
        "log_test"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Test path configuration.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 355,
      "line_start": 337,
      "module": "scripts.dev.test_all_functions",
      "name": "test_path_configuration",
      "signature": "def test_path_configuration():"
    },
    "scripts.dev.test_all_functions.test_python_imports": {
      "calls": [
        "str",
        "__import__",
        "log_test"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Test that all required Python modules can be imported.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 76,
      "line_start": 63,
      "module": "scripts.dev.test_all_functions",
      "name": "test_python_imports",
      "signature": "def test_python_imports():"
    },
    "scripts.dev.test_all_functions.test_settings_loading": {
      "calls": [
        "str",
        "log_test"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Test that settings can be loaded correctly.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 135,
      "line_start": 113,
      "module": "scripts.dev.test_all_functions",
      "name": "test_settings_loading",
      "signature": "def test_settings_loading():"
    },
    "scripts.dev.test_all_functions.test_whisper_model_loading": {
      "calls": [
        "tiny_model.exists",
        "str",
        "hasattr",
        "log_test"
      ],
      "decorators": [
        "staticmethod"
      ],
      "docstring": "Test that Whisper models can be loaded.",
      "file_path": "scripts/dev/test_all_functions.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 268,
      "line_start": 249,
      "module": "scripts.dev.test_all_functions",
      "name": "test_whisper_model_loading",
      "signature": "def test_whisper_model_loading():"
    },
    "scripts.dev.test_features.main": {
      "calls": [
        "results.append",
        "len",
        "print",
        "sum",
        "time.sleep",
        "test"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "scripts/dev/test_features.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 153,
      "line_start": 122,
      "module": "scripts.dev.test_features",
      "name": "main",
      "signature": "def main():"
    },
    "scripts.dev.test_features.test_api_caching": {
      "calls": [
        "time.time",
        "print",
        "requests.get"
      ],
      "decorators": [],
      "docstring": "Test API response caching",
      "file_path": "scripts/dev/test_features.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 96,
      "line_start": 69,
      "module": "scripts.dev.test_features",
      "name": "test_api_caching",
      "signature": "def test_api_caching():"
    },
    "scripts.dev.test_features.test_error_handling": {
      "calls": [
        "print",
        "requests.post",
        "requests.get"
      ],
      "decorators": [],
      "docstring": "Test error handling",
      "file_path": "scripts/dev/test_features.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 120,
      "line_start": 98,
      "module": "scripts.dev.test_features",
      "name": "test_error_handling",
      "signature": "def test_error_handling():"
    },
    "scripts.dev.test_features.test_rate_limiting": {
      "calls": [
        "print",
        "requests.post",
        "range",
        "dict",
        "time.sleep"
      ],
      "decorators": [],
      "docstring": "Test rate limiting middleware",
      "file_path": "scripts/dev/test_features.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 67,
      "line_start": 43,
      "module": "scripts.dev.test_features",
      "name": "test_rate_limiting",
      "signature": "def test_rate_limiting():"
    },
    "scripts.dev.test_features.test_security_headers": {
      "calls": [
        "security_checks.items",
        "print",
        "dict",
        "requests.get"
      ],
      "decorators": [],
      "docstring": "Test security headers middleware",
      "file_path": "scripts/dev/test_features.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 41,
      "line_start": 12,
      "module": "scripts.dev.test_features",
      "name": "test_security_headers",
      "signature": "def test_security_headers():"
    },
    "scripts.dev_setup.init_database": {
      "calls": [
        "SessionLocal",
        "join",
        "db.execute",
        "print",
        "Base.metadata.create_all",
        "text"
      ],
      "decorators": [],
      "docstring": "Initialize SQLite database with tables.",
      "file_path": "scripts/dev_setup.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 33,
      "line_start": 15,
      "module": "scripts.dev_setup",
      "name": "init_database",
      "signature": "def init_database():"
    },
    "scripts.dev_setup.main": {
      "calls": [
        "test_app_startup",
        "print",
        "init_database"
      ],
      "decorators": [],
      "docstring": "Main development setup function.",
      "file_path": "scripts/dev_setup.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 67,
      "line_start": 45,
      "module": "scripts.dev_setup",
      "name": "main",
      "signature": "def main():"
    },
    "scripts.dev_setup.test_app_startup": {
      "calls": [
        "print"
      ],
      "decorators": [],
      "docstring": "Test that the application can start.",
      "file_path": "scripts/dev_setup.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 43,
      "line_start": 35,
      "module": "scripts.dev_setup",
      "name": "test_app_startup",
      "signature": "def test_app_startup():"
    },
    "scripts.update_manifest.collect_files": {
      "calls": [
        "os.path.relpath",
        "should_exclude",
        "os.path.join",
        "sorted",
        "files.append",
        "os.walk"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "scripts/update_manifest.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 42,
      "line_start": 24,
      "module": "scripts.update_manifest",
      "name": "collect_files",
      "signature": "def collect_files(root):"
    },
    "scripts.update_manifest.main": {
      "calls": [
        "strip",
        "os.path.dirname",
        "pf.read",
        "result.stdout.strip",
        "line.split",
        "subprocess.run",
        "nf.read",
        "pf.write",
        "len",
        "open",
        "datetime.now",
        "strftime",
        "print",
        "f.write",
        "split",
        "hashlib.sha256",
        "line.strip",
        "hexdigest",
        "collect_files",
        "os.path.join",
        "mf.write",
        "os.path.exists",
        "line.startswith",
        "join",
        "os.makedirs"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "scripts/update_manifest.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 132,
      "line_start": 44,
      "module": "scripts.update_manifest",
      "name": "main",
      "signature": "def main():"
    },
    "scripts.update_manifest.should_exclude": {
      "calls": [
        "ex.endswith",
        "path.endswith"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "scripts/update_manifest.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 22,
      "line_start": 12,
      "module": "scripts.update_manifest",
      "name": "should_exclude",
      "signature": "def should_exclude(path):"
    },
    "scripts.validate_db_performance.main": {
      "calls": [
        "check_func",
        "print",
        "results.append",
        "len"
      ],
      "decorators": [],
      "docstring": "Run all database performance validations",
      "file_path": "scripts/validate_db_performance.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 261,
      "line_start": 213,
      "module": "scripts.validate_db_performance",
      "name": "main",
      "signature": "def main():"
    },
    "scripts.validate_db_performance.run_simple_performance_check": {
      "calls": [
        "time.time",
        "print"
      ],
      "decorators": [],
      "docstring": "Run a simple performance check without requiring database setup",
      "file_path": "scripts/validate_db_performance.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 210,
      "line_start": 185,
      "module": "scripts.validate_db_performance",
      "name": "run_simple_performance_check",
      "signature": "def run_simple_performance_check():"
    },
    "scripts.validate_db_performance.validate_migration_scripts": {
      "calls": [
        "Path",
        "migration_file.exists",
        "print",
        "migration_file.stat"
      ],
      "decorators": [],
      "docstring": "Validate that migration scripts exist",
      "file_path": "scripts/validate_db_performance.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 155,
      "line_start": 135,
      "module": "scripts.validate_db_performance",
      "name": "validate_migration_scripts",
      "signature": "def validate_migration_scripts():"
    },
    "scripts.validate_db_performance.validate_model_indexes": {
      "calls": [
        "print",
        "any",
        "len"
      ],
      "decorators": [],
      "docstring": "Validate that our optimized models have the expected indexes",
      "file_path": "scripts/validate_db_performance.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 68,
      "line_start": 15,
      "module": "scripts.validate_db_performance",
      "name": "validate_model_indexes",
      "signature": "def validate_model_indexes():"
    },
    "scripts.validate_db_performance.validate_optimized_endpoints": {
      "calls": [
        "print"
      ],
      "decorators": [],
      "docstring": "Validate that optimized endpoint patterns are available",
      "file_path": "scripts/validate_db_performance.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 182,
      "line_start": 158,
      "module": "scripts.validate_db_performance",
      "name": "validate_optimized_endpoints",
      "signature": "def validate_optimized_endpoints():"
    },
    "scripts.validate_db_performance.validate_performance_middleware": {
      "calls": [
        "print"
      ],
      "decorators": [],
      "docstring": "Validate that performance monitoring middleware is available",
      "file_path": "scripts/validate_db_performance.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 132,
      "line_start": 115,
      "module": "scripts.validate_db_performance",
      "name": "validate_performance_middleware",
      "signature": "def validate_performance_middleware():"
    },
    "scripts.validate_db_performance.validate_query_optimizations": {
      "calls": [
        "hasattr",
        "QueryPerformanceMonitor",
        "print"
      ],
      "decorators": [],
      "docstring": "Validate that our query optimization patterns are available",
      "file_path": "scripts/validate_db_performance.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 112,
      "line_start": 71,
      "module": "scripts.validate_db_performance",
      "name": "validate_query_optimizations",
      "signature": "def validate_query_optimizations():"
    },
    "scripts.validate_pagination_009.main": {
      "calls": [
        "print",
        "test_func",
        "len"
      ],
      "decorators": [],
      "docstring": "Run all validation tests.",
      "file_path": "scripts/validate_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 211,
      "line_start": 177,
      "module": "scripts.validate_pagination_009",
      "name": "main",
      "signature": "def main():"
    },
    "scripts.validate_pagination_009.test_cursor_generation": {
      "calls": [
        "CursorGenerator.generate_cursor",
        "print",
        "CursorGenerator.parse_cursor",
        "traceback.print_exc"
      ],
      "decorators": [],
      "docstring": "Test cursor generation and parsing.",
      "file_path": "scripts/validate_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 103,
      "line_start": 66,
      "module": "scripts.validate_pagination_009",
      "name": "test_cursor_generation",
      "signature": "def test_cursor_generation():"
    },
    "scripts.validate_pagination_009.test_job_query_filters": {
      "calls": [
        "JobQueryFilters",
        "print",
        "traceback.print_exc"
      ],
      "decorators": [],
      "docstring": "Test JobQueryFilters validation.",
      "file_path": "scripts/validate_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 131,
      "line_start": 105,
      "module": "scripts.validate_pagination_009",
      "name": "test_job_query_filters",
      "signature": "def test_job_query_filters():"
    },
    "scripts.validate_pagination_009.test_pagination_imports": {
      "calls": [
        "print",
        "traceback.print_exc"
      ],
      "decorators": [],
      "docstring": "Test that all pagination modules can be imported.",
      "file_path": "scripts/validate_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 29,
      "line_start": 17,
      "module": "scripts.validate_pagination_009",
      "name": "test_pagination_imports",
      "signature": "def test_pagination_imports():"
    },
    "scripts.validate_pagination_009.test_pagination_request_validation": {
      "calls": [
        "PaginationRequest",
        "print",
        "traceback.print_exc"
      ],
      "decorators": [],
      "docstring": "Test PaginationRequest validation.",
      "file_path": "scripts/validate_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 64,
      "line_start": 31,
      "module": "scripts.validate_pagination_009",
      "name": "test_pagination_request_validation",
      "signature": "def test_pagination_request_validation():"
    },
    "scripts.validate_pagination_009.test_schemas_integration": {
      "calls": [
        "print",
        "traceback.print_exc",
        "PaginatedJobsResponseSchema",
        "datetime.utcnow",
        "JobResponseSchema"
      ],
      "decorators": [],
      "docstring": "Test integration with response schemas.",
      "file_path": "scripts/validate_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 175,
      "line_start": 133,
      "module": "scripts.validate_pagination_009",
      "name": "test_schemas_integration",
      "signature": "def test_schemas_integration():"
    },
    "tests.test_backup_system.TestBackupAPI.test_backup_health_endpoint": {
      "calls": [
        "test_client.get",
        "patch",
        "Mock",
        "response.json"
      ],
      "decorators": [
        "patch"
      ],
      "docstring": "Test backup health check endpoint.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": true,
      "line_end": 648,
      "line_start": 632,
      "module": "tests.test_backup_system",
      "name": "TestBackupAPI.test_backup_health_endpoint",
      "signature": "def test_backup_health_endpoint(self, mock_get_service, test_client):"
    },
    "tests.test_backup_system.TestBackupAPI.test_backup_status_endpoint": {
      "calls": [
        "test_client.get",
        "patch",
        "Mock",
        "response.json"
      ],
      "decorators": [
        "patch"
      ],
      "docstring": "Test backup status API endpoint.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": true,
      "line_end": 604,
      "line_start": 588,
      "module": "tests.test_backup_system",
      "name": "TestBackupAPI.test_backup_status_endpoint",
      "signature": "def test_backup_status_endpoint(self, mock_get_service, test_client):"
    },
    "tests.test_backup_system.TestBackupAPI.test_client": {
      "calls": [
        "app.include_router",
        "FastAPI",
        "TestClient"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Create test client with backup router.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 585,
      "line_start": 577,
      "module": "tests.test_backup_system",
      "name": "TestBackupAPI.test_client",
      "signature": "def test_client(self):"
    },
    "tests.test_backup_system.TestBackupAPI.test_create_backup_endpoint": {
      "calls": [
        "patch",
        "test_client.post",
        "Mock",
        "response.json"
      ],
      "decorators": [
        "patch"
      ],
      "docstring": "Test create backup API endpoint.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": true,
      "line_end": 629,
      "line_start": 607,
      "module": "tests.test_backup_system",
      "name": "TestBackupAPI.test_create_backup_endpoint",
      "signature": "def test_create_backup_endpoint(self, mock_get_service, test_client):"
    },
    "tests.test_backup_system.TestBackupConfiguration.test_get_backup_config_defaults": {
      "calls": [
        "get_backup_config",
        "isinstance"
      ],
      "decorators": [],
      "docstring": "Test getting default backup configuration.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 473,
      "line_start": 465,
      "module": "tests.test_backup_system",
      "name": "TestBackupConfiguration.test_get_backup_config_defaults",
      "signature": "def test_get_backup_config_defaults(self):"
    },
    "tests.test_backup_system.TestBackupConfiguration.test_validate_backup_config": {
      "calls": [
        "validate_backup_config"
      ],
      "decorators": [],
      "docstring": "Test backup configuration validation.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 485,
      "line_start": 475,
      "module": "tests.test_backup_system",
      "name": "TestBackupConfiguration.test_validate_backup_config",
      "signature": "def test_validate_backup_config(self):"
    },
    "tests.test_backup_system.TestBackupConfiguration.test_validate_backup_config_invalid": {
      "calls": [
        "pytest.raises",
        "validate_backup_config"
      ],
      "decorators": [],
      "docstring": "Test backup configuration validation with invalid config.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 495,
      "line_start": 487,
      "module": "tests.test_backup_system",
      "name": "TestBackupConfiguration.test_validate_backup_config_invalid",
      "signature": "def test_validate_backup_config_invalid(self):"
    },
    "tests.test_backup_system.TestBackupOrchestrator.temp_dirs": {
      "calls": [
        "write_text",
        "sqlite3.connect",
        "tempfile.mkdtemp",
        "Path",
        "conn.close",
        "conn.execute",
        "shutil.rmtree",
        "str",
        "conn.commit"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Create temporary directories for testing.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 372,
      "line_start": 345,
      "module": "tests.test_backup_system",
      "name": "TestBackupOrchestrator.temp_dirs",
      "signature": "def temp_dirs(self):"
    },
    "tests.test_backup_system.TestBackupOrchestrator.test_full_backup_orchestration": {
      "calls": [
        "orchestrator.create_full_backup",
        "BackupOrchestrator"
      ],
      "decorators": [],
      "docstring": "Test full backup orchestration.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 404,
      "line_start": 388,
      "module": "tests.test_backup_system",
      "name": "TestBackupOrchestrator.test_full_backup_orchestration",
      "signature": "def test_full_backup_orchestration(self, temp_dirs):"
    },
    "tests.test_backup_system.TestBackupOrchestrator.test_orchestrator_init": {
      "calls": [
        "BackupOrchestrator",
        "len"
      ],
      "decorators": [],
      "docstring": "Test BackupOrchestrator initialization.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 386,
      "line_start": 374,
      "module": "tests.test_backup_system",
      "name": "TestBackupOrchestrator.test_orchestrator_init",
      "signature": "def test_orchestrator_init(self, temp_dirs):"
    },
    "tests.test_backup_system.TestBackupService.temp_service_setup": {
      "calls": [
        "write_text",
        "sqlite3.connect",
        "tempfile.mkdtemp",
        "Path",
        "conn.close",
        "conn.execute",
        "shutil.rmtree",
        "str",
        "conn.commit"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Set up temporary environment for service testing.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 537,
      "line_start": 503,
      "module": "tests.test_backup_system",
      "name": "TestBackupService.temp_service_setup",
      "signature": "def temp_service_setup(self):"
    },
    "tests.test_backup_system.TestBackupService.test_backup_service_init": {
      "calls": [
        "BackupService"
      ],
      "decorators": [],
      "docstring": "Test BackupService initialization.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 546,
      "line_start": 539,
      "module": "tests.test_backup_system",
      "name": "TestBackupService.test_backup_service_init",
      "signature": "def test_backup_service_init(self, temp_service_setup):"
    },
    "tests.test_backup_system.TestBackupService.test_backup_service_status": {
      "calls": [
        "service.get_service_status",
        "BackupService",
        "isinstance"
      ],
      "decorators": [],
      "docstring": "Test getting backup service status.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 558,
      "line_start": 548,
      "module": "tests.test_backup_system",
      "name": "TestBackupService.test_backup_service_status",
      "signature": "def test_backup_service_status(self, temp_service_setup):"
    },
    "tests.test_backup_system.TestBackupService.test_manual_backup_creation": {
      "calls": [
        "isinstance",
        "BackupService",
        "service.create_manual_backup"
      ],
      "decorators": [],
      "docstring": "Test manual backup creation through service.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 568,
      "line_start": 560,
      "module": "tests.test_backup_system",
      "name": "TestBackupService.test_manual_backup_creation",
      "signature": "def test_manual_backup_creation(self, temp_service_setup):"
    },
    "tests.test_backup_system.TestBackupSystemAvailability.test_backup_system_imports": {
      "calls": [
        "pytest.skip"
      ],
      "decorators": [],
      "docstring": "Test that all backup system components can be imported.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 51,
      "line_start": 40,
      "module": "tests.test_backup_system",
      "name": "TestBackupSystemAvailability.test_backup_system_imports",
      "signature": "def test_backup_system_imports(self):"
    },
    "tests.test_backup_system.TestBackupSystemIntegration.test_backup_system_end_to_end": {
      "calls": [
        "write_text",
        "Path",
        "sqlite3.connect",
        "conn.close",
        "conn.execute",
        "service.recovery_manager.validate_system_recovery",
        "service.recovery_manager.list_available_backups",
        "str",
        "pytest.mark.skipif",
        "tempfile.TemporaryDirectory",
        "conn.commit",
        "BackupService",
        "isinstance",
        "backup_dir.mkdir",
        "source_dir.mkdir",
        "storage_dir.mkdir",
        "service.create_manual_backup"
      ],
      "decorators": [
        "pytest.mark.skipif"
      ],
      "docstring": "Test complete backup and recovery workflow.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 706,
      "line_start": 655,
      "module": "tests.test_backup_system",
      "name": "TestBackupSystemIntegration.test_backup_system_end_to_end",
      "signature": "def test_backup_system_end_to_end(self):"
    },
    "tests.test_backup_system.TestCompressionEngine.temp_test_file": {
      "calls": [
        "tempfile.NamedTemporaryFile",
        "f.write",
        "os.unlink",
        "os.path.exists"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Create temporary test file.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 213,
      "line_start": 204,
      "module": "tests.test_backup_system",
      "name": "TestCompressionEngine.temp_test_file",
      "signature": "def temp_test_file(self):"
    },
    "tests.test_backup_system.TestCompressionEngine.test_compress_file": {
      "calls": [
        "os.unlink",
        "engine.compress_file",
        "tempfile.NamedTemporaryFile",
        "os.path.getsize",
        "CompressionEngine",
        "os.path.exists"
      ],
      "decorators": [],
      "docstring": "Test file compression.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 232,
      "line_start": 220,
      "module": "tests.test_backup_system",
      "name": "TestCompressionEngine.test_compress_file",
      "signature": "def test_compress_file(self, temp_test_file):"
    },
    "tests.test_backup_system.TestCompressionEngine.test_compression_engine_init": {
      "calls": [
        "CompressionEngine"
      ],
      "decorators": [],
      "docstring": "Test CompressionEngine initialization.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 218,
      "line_start": 215,
      "module": "tests.test_backup_system",
      "name": "TestCompressionEngine.test_compression_engine_init",
      "signature": "def test_compression_engine_init(self):"
    },
    "tests.test_backup_system.TestCompressionEngine.test_decompress_file": {
      "calls": [
        "os.unlink",
        "engine.compress_file",
        "open",
        "engine.decompress_file",
        "tempfile.NamedTemporaryFile",
        "original.read",
        "decompressed.read",
        "CompressionEngine"
      ],
      "decorators": [],
      "docstring": "Test file decompression.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 256,
      "line_start": 234,
      "module": "tests.test_backup_system",
      "name": "TestCompressionEngine.test_decompress_file",
      "signature": "def test_decompress_file(self, temp_test_file):"
    },
    "tests.test_backup_system.TestDatabaseBackupEngine.temp_backup_dir": {
      "calls": [
        "shutil.rmtree",
        "tempfile.mkdtemp"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Create temporary backup directory.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 88,
      "line_start": 84,
      "module": "tests.test_backup_system",
      "name": "TestDatabaseBackupEngine.temp_backup_dir",
      "signature": "def temp_backup_dir(self):"
    },
    "tests.test_backup_system.TestDatabaseBackupEngine.temp_db": {
      "calls": [
        "sqlite3.connect",
        "conn.close",
        "os.unlink",
        "conn.execute",
        "conn.commit",
        "tempfile.NamedTemporaryFile",
        "os.path.exists"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Create a temporary SQLite database for testing.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 81,
      "line_start": 59,
      "module": "tests.test_backup_system",
      "name": "TestDatabaseBackupEngine.temp_db",
      "signature": "def temp_db(self):"
    },
    "tests.test_backup_system.TestDatabaseBackupEngine.test_backup_integrity_check": {
      "calls": [
        "engine.create_full_backup",
        "DatabaseBackupEngine",
        "engine.verify_backup_integrity"
      ],
      "decorators": [],
      "docstring": "Test backup file integrity verification.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 136,
      "line_start": 130,
      "module": "tests.test_backup_system",
      "name": "TestDatabaseBackupEngine.test_backup_integrity_check",
      "signature": "def test_backup_integrity_check(self, temp_db, temp_backup_dir):"
    },
    "tests.test_backup_system.TestDatabaseBackupEngine.test_create_full_backup": {
      "calls": [
        "sqlite3.connect",
        "backup_conn.execute",
        "engine.create_full_backup",
        "cursor.fetchone",
        "DatabaseBackupEngine",
        "os.path.exists",
        "backup_conn.close"
      ],
      "decorators": [],
      "docstring": "Test creating a full database backup.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 113,
      "line_start": 98,
      "module": "tests.test_backup_system",
      "name": "TestDatabaseBackupEngine.test_create_full_backup",
      "signature": "def test_create_full_backup(self, temp_db, temp_backup_dir):"
    },
    "tests.test_backup_system.TestDatabaseBackupEngine.test_database_backup_engine_init": {
      "calls": [
        "DatabaseBackupEngine"
      ],
      "decorators": [],
      "docstring": "Test DatabaseBackupEngine initialization.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 96,
      "line_start": 90,
      "module": "tests.test_backup_system",
      "name": "TestDatabaseBackupEngine.test_database_backup_engine_init",
      "signature": "def test_database_backup_engine_init(self, temp_db, temp_backup_dir):"
    },
    "tests.test_backup_system.TestDatabaseBackupEngine.test_wal_backup": {
      "calls": [
        "sqlite3.connect",
        "conn.close",
        "conn.execute",
        "engine.backup_wal_files",
        "conn.commit",
        "DatabaseBackupEngine"
      ],
      "decorators": [],
      "docstring": "Test WAL file backup.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 128,
      "line_start": 115,
      "module": "tests.test_backup_system",
      "name": "TestDatabaseBackupEngine.test_wal_backup",
      "signature": "def test_wal_backup(self, temp_db, temp_backup_dir):"
    },
    "tests.test_backup_system.TestFileBackupEngine.temp_backup_dir": {
      "calls": [
        "shutil.rmtree",
        "tempfile.mkdtemp"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Create temporary backup directory.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 165,
      "line_start": 161,
      "module": "tests.test_backup_system",
      "name": "TestFileBackupEngine.temp_backup_dir",
      "signature": "def temp_backup_dir(self):"
    },
    "tests.test_backup_system.TestFileBackupEngine.temp_source_dir": {
      "calls": [
        "write_text",
        "Path",
        "tempfile.mkdtemp",
        "shutil.rmtree",
        "subdir.mkdir"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Create temporary source directory with test files.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 158,
      "line_start": 144,
      "module": "tests.test_backup_system",
      "name": "TestFileBackupEngine.temp_source_dir",
      "signature": "def temp_source_dir(self):"
    },
    "tests.test_backup_system.TestFileBackupEngine.test_create_file_backup": {
      "calls": [
        "engine.create_backup",
        "FileBackupEngine",
        "os.path.exists"
      ],
      "decorators": [],
      "docstring": "Test creating file backup.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 183,
      "line_start": 175,
      "module": "tests.test_backup_system",
      "name": "TestFileBackupEngine.test_create_file_backup",
      "signature": "def test_create_file_backup(self, temp_source_dir, temp_backup_dir):"
    },
    "tests.test_backup_system.TestFileBackupEngine.test_file_backup_engine_init": {
      "calls": [
        "FileBackupEngine"
      ],
      "decorators": [],
      "docstring": "Test FileBackupEngine initialization.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 173,
      "line_start": 167,
      "module": "tests.test_backup_system",
      "name": "TestFileBackupEngine.test_file_backup_engine_init",
      "signature": "def test_file_backup_engine_init(self, temp_source_dir, temp_backup_dir):"
    },
    "tests.test_backup_system.TestFileBackupEngine.test_file_deduplication": {
      "calls": [
        "write_text",
        "engine.create_backup",
        "Path",
        "FileBackupEngine"
      ],
      "decorators": [],
      "docstring": "Test file deduplication functionality.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 196,
      "line_start": 185,
      "module": "tests.test_backup_system",
      "name": "TestFileBackupEngine.test_file_deduplication",
      "signature": "def test_file_deduplication(self, temp_source_dir, temp_backup_dir):"
    },
    "tests.test_backup_system.TestRecoveryManager.temp_recovery_setup": {
      "calls": [
        "Path",
        "tempfile.mkdtemp",
        "shutil.rmtree",
        "str",
        "file_backup.write_text",
        "db_backup.write_text"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Set up temporary environment for recovery testing.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 433,
      "line_start": 412,
      "module": "tests.test_backup_system",
      "name": "TestRecoveryManager.temp_recovery_setup",
      "signature": "def temp_recovery_setup(self):"
    },
    "tests.test_backup_system.TestRecoveryManager.test_list_available_backups": {
      "calls": [
        "isinstance",
        "RecoveryManager",
        "manager.list_available_backups"
      ],
      "decorators": [],
      "docstring": "Test listing available backups.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 458,
      "line_start": 446,
      "module": "tests.test_backup_system",
      "name": "TestRecoveryManager.test_list_available_backups",
      "signature": "def test_list_available_backups(self, temp_recovery_setup):"
    },
    "tests.test_backup_system.TestRecoveryManager.test_recovery_manager_init": {
      "calls": [
        "RecoveryManager",
        "len"
      ],
      "decorators": [],
      "docstring": "Test RecoveryManager initialization.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 444,
      "line_start": 435,
      "module": "tests.test_backup_system",
      "name": "TestRecoveryManager.test_recovery_manager_init",
      "signature": "def test_recovery_manager_init(self, temp_recovery_setup):"
    },
    "tests.test_backup_system.TestStorageBackends.temp_storage_dir": {
      "calls": [
        "shutil.rmtree",
        "tempfile.mkdtemp"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Create temporary storage directory.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 268,
      "line_start": 264,
      "module": "tests.test_backup_system",
      "name": "TestStorageBackends.temp_storage_dir",
      "signature": "def temp_storage_dir(self):"
    },
    "tests.test_backup_system.TestStorageBackends.temp_test_file": {
      "calls": [
        "tempfile.NamedTemporaryFile",
        "f.write",
        "os.unlink",
        "os.path.exists"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Create temporary test file to upload.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 280,
      "line_start": 271,
      "module": "tests.test_backup_system",
      "name": "TestStorageBackends.temp_test_file",
      "signature": "def temp_test_file(self):"
    },
    "tests.test_backup_system.TestStorageBackends.test_local_storage_backend": {
      "calls": [
        "Path",
        "os.unlink",
        "backend.upload_file",
        "expected_path.exists",
        "LocalStorageBackend",
        "open",
        "backend.delete_file",
        "tempfile.NamedTemporaryFile",
        "original.read",
        "downloaded.read",
        "backend.download_file"
      ],
      "decorators": [],
      "docstring": "Test local storage backend.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 309,
      "line_start": 282,
      "module": "tests.test_backup_system",
      "name": "TestStorageBackends.test_local_storage_backend",
      "signature": "def test_local_storage_backend(self, temp_storage_dir, temp_test_file):"
    },
    "tests.test_backup_system.TestStorageBackends.test_s3_storage_backend_mock": {
      "calls": [
        "os.unlink",
        "backend.upload_file",
        "mock_s3.delete_object.assert_called_once",
        "backend.delete_file",
        "S3StorageBackend",
        "mock_s3.upload_file.assert_called_once",
        "tempfile.NamedTemporaryFile",
        "mock_s3.download_file.assert_called_once",
        "Mock",
        "patch",
        "backend.download_file"
      ],
      "decorators": [],
      "docstring": "Test S3 storage backend with mocked boto3.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 337,
      "line_start": 311,
      "module": "tests.test_backup_system",
      "name": "TestStorageBackends.test_s3_storage_backend_mock",
      "signature": "def test_s3_storage_backend_mock(self, temp_test_file):"
    },
    "tests.test_backup_system.temp_backup_dir": {
      "calls": [
        "shutil.rmtree",
        "tempfile.mkdtemp"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Create temporary backup directory.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 165,
      "line_start": 161,
      "module": "tests.test_backup_system",
      "name": "temp_backup_dir",
      "signature": "def temp_backup_dir(self):"
    },
    "tests.test_backup_system.temp_db": {
      "calls": [
        "sqlite3.connect",
        "conn.close",
        "os.unlink",
        "conn.execute",
        "conn.commit",
        "tempfile.NamedTemporaryFile",
        "os.path.exists"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Create a temporary SQLite database for testing.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 81,
      "line_start": 59,
      "module": "tests.test_backup_system",
      "name": "temp_db",
      "signature": "def temp_db(self):"
    },
    "tests.test_backup_system.temp_dirs": {
      "calls": [
        "write_text",
        "sqlite3.connect",
        "tempfile.mkdtemp",
        "Path",
        "conn.close",
        "conn.execute",
        "shutil.rmtree",
        "str",
        "conn.commit"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Create temporary directories for testing.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 372,
      "line_start": 345,
      "module": "tests.test_backup_system",
      "name": "temp_dirs",
      "signature": "def temp_dirs(self):"
    },
    "tests.test_backup_system.temp_recovery_setup": {
      "calls": [
        "Path",
        "tempfile.mkdtemp",
        "shutil.rmtree",
        "str",
        "file_backup.write_text",
        "db_backup.write_text"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Set up temporary environment for recovery testing.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 433,
      "line_start": 412,
      "module": "tests.test_backup_system",
      "name": "temp_recovery_setup",
      "signature": "def temp_recovery_setup(self):"
    },
    "tests.test_backup_system.temp_service_setup": {
      "calls": [
        "write_text",
        "sqlite3.connect",
        "tempfile.mkdtemp",
        "Path",
        "conn.close",
        "conn.execute",
        "shutil.rmtree",
        "str",
        "conn.commit"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Set up temporary environment for service testing.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 537,
      "line_start": 503,
      "module": "tests.test_backup_system",
      "name": "temp_service_setup",
      "signature": "def temp_service_setup(self):"
    },
    "tests.test_backup_system.temp_source_dir": {
      "calls": [
        "write_text",
        "Path",
        "tempfile.mkdtemp",
        "shutil.rmtree",
        "subdir.mkdir"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Create temporary source directory with test files.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 158,
      "line_start": 144,
      "module": "tests.test_backup_system",
      "name": "temp_source_dir",
      "signature": "def temp_source_dir(self):"
    },
    "tests.test_backup_system.temp_storage_dir": {
      "calls": [
        "shutil.rmtree",
        "tempfile.mkdtemp"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Create temporary storage directory.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 268,
      "line_start": 264,
      "module": "tests.test_backup_system",
      "name": "temp_storage_dir",
      "signature": "def temp_storage_dir(self):"
    },
    "tests.test_backup_system.temp_test_file": {
      "calls": [
        "tempfile.NamedTemporaryFile",
        "f.write",
        "os.unlink",
        "os.path.exists"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Create temporary test file to upload.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 280,
      "line_start": 271,
      "module": "tests.test_backup_system",
      "name": "temp_test_file",
      "signature": "def temp_test_file(self):"
    },
    "tests.test_backup_system.test_backup_health_endpoint": {
      "calls": [
        "test_client.get",
        "patch",
        "Mock",
        "response.json"
      ],
      "decorators": [
        "patch"
      ],
      "docstring": "Test backup health check endpoint.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": true,
      "line_end": 648,
      "line_start": 632,
      "module": "tests.test_backup_system",
      "name": "test_backup_health_endpoint",
      "signature": "def test_backup_health_endpoint(self, mock_get_service, test_client):"
    },
    "tests.test_backup_system.test_backup_integrity_check": {
      "calls": [
        "engine.create_full_backup",
        "DatabaseBackupEngine",
        "engine.verify_backup_integrity"
      ],
      "decorators": [],
      "docstring": "Test backup file integrity verification.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 136,
      "line_start": 130,
      "module": "tests.test_backup_system",
      "name": "test_backup_integrity_check",
      "signature": "def test_backup_integrity_check(self, temp_db, temp_backup_dir):"
    },
    "tests.test_backup_system.test_backup_service_init": {
      "calls": [
        "BackupService"
      ],
      "decorators": [],
      "docstring": "Test BackupService initialization.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 546,
      "line_start": 539,
      "module": "tests.test_backup_system",
      "name": "test_backup_service_init",
      "signature": "def test_backup_service_init(self, temp_service_setup):"
    },
    "tests.test_backup_system.test_backup_service_status": {
      "calls": [
        "service.get_service_status",
        "BackupService",
        "isinstance"
      ],
      "decorators": [],
      "docstring": "Test getting backup service status.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 558,
      "line_start": 548,
      "module": "tests.test_backup_system",
      "name": "test_backup_service_status",
      "signature": "def test_backup_service_status(self, temp_service_setup):"
    },
    "tests.test_backup_system.test_backup_status_endpoint": {
      "calls": [
        "test_client.get",
        "patch",
        "Mock",
        "response.json"
      ],
      "decorators": [
        "patch"
      ],
      "docstring": "Test backup status API endpoint.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": true,
      "line_end": 604,
      "line_start": 588,
      "module": "tests.test_backup_system",
      "name": "test_backup_status_endpoint",
      "signature": "def test_backup_status_endpoint(self, mock_get_service, test_client):"
    },
    "tests.test_backup_system.test_backup_system_end_to_end": {
      "calls": [
        "write_text",
        "Path",
        "sqlite3.connect",
        "conn.close",
        "conn.execute",
        "service.recovery_manager.validate_system_recovery",
        "service.recovery_manager.list_available_backups",
        "str",
        "pytest.mark.skipif",
        "tempfile.TemporaryDirectory",
        "conn.commit",
        "BackupService",
        "isinstance",
        "backup_dir.mkdir",
        "source_dir.mkdir",
        "storage_dir.mkdir",
        "service.create_manual_backup"
      ],
      "decorators": [
        "pytest.mark.skipif"
      ],
      "docstring": "Test complete backup and recovery workflow.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 706,
      "line_start": 655,
      "module": "tests.test_backup_system",
      "name": "test_backup_system_end_to_end",
      "signature": "def test_backup_system_end_to_end(self):"
    },
    "tests.test_backup_system.test_backup_system_imports": {
      "calls": [
        "pytest.skip"
      ],
      "decorators": [],
      "docstring": "Test that all backup system components can be imported.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 51,
      "line_start": 40,
      "module": "tests.test_backup_system",
      "name": "test_backup_system_imports",
      "signature": "def test_backup_system_imports(self):"
    },
    "tests.test_backup_system.test_client": {
      "calls": [
        "app.include_router",
        "FastAPI",
        "TestClient"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Create test client with backup router.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 585,
      "line_start": 577,
      "module": "tests.test_backup_system",
      "name": "test_client",
      "signature": "def test_client(self):"
    },
    "tests.test_backup_system.test_compress_file": {
      "calls": [
        "os.unlink",
        "engine.compress_file",
        "tempfile.NamedTemporaryFile",
        "os.path.getsize",
        "CompressionEngine",
        "os.path.exists"
      ],
      "decorators": [],
      "docstring": "Test file compression.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 232,
      "line_start": 220,
      "module": "tests.test_backup_system",
      "name": "test_compress_file",
      "signature": "def test_compress_file(self, temp_test_file):"
    },
    "tests.test_backup_system.test_compression_engine_init": {
      "calls": [
        "CompressionEngine"
      ],
      "decorators": [],
      "docstring": "Test CompressionEngine initialization.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 218,
      "line_start": 215,
      "module": "tests.test_backup_system",
      "name": "test_compression_engine_init",
      "signature": "def test_compression_engine_init(self):"
    },
    "tests.test_backup_system.test_create_backup_endpoint": {
      "calls": [
        "patch",
        "test_client.post",
        "Mock",
        "response.json"
      ],
      "decorators": [
        "patch"
      ],
      "docstring": "Test create backup API endpoint.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": true,
      "line_end": 629,
      "line_start": 607,
      "module": "tests.test_backup_system",
      "name": "test_create_backup_endpoint",
      "signature": "def test_create_backup_endpoint(self, mock_get_service, test_client):"
    },
    "tests.test_backup_system.test_create_file_backup": {
      "calls": [
        "engine.create_backup",
        "FileBackupEngine",
        "os.path.exists"
      ],
      "decorators": [],
      "docstring": "Test creating file backup.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 183,
      "line_start": 175,
      "module": "tests.test_backup_system",
      "name": "test_create_file_backup",
      "signature": "def test_create_file_backup(self, temp_source_dir, temp_backup_dir):"
    },
    "tests.test_backup_system.test_create_full_backup": {
      "calls": [
        "sqlite3.connect",
        "backup_conn.execute",
        "engine.create_full_backup",
        "cursor.fetchone",
        "DatabaseBackupEngine",
        "os.path.exists",
        "backup_conn.close"
      ],
      "decorators": [],
      "docstring": "Test creating a full database backup.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 113,
      "line_start": 98,
      "module": "tests.test_backup_system",
      "name": "test_create_full_backup",
      "signature": "def test_create_full_backup(self, temp_db, temp_backup_dir):"
    },
    "tests.test_backup_system.test_database_backup_engine_init": {
      "calls": [
        "DatabaseBackupEngine"
      ],
      "decorators": [],
      "docstring": "Test DatabaseBackupEngine initialization.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 96,
      "line_start": 90,
      "module": "tests.test_backup_system",
      "name": "test_database_backup_engine_init",
      "signature": "def test_database_backup_engine_init(self, temp_db, temp_backup_dir):"
    },
    "tests.test_backup_system.test_decompress_file": {
      "calls": [
        "os.unlink",
        "engine.compress_file",
        "open",
        "engine.decompress_file",
        "tempfile.NamedTemporaryFile",
        "original.read",
        "decompressed.read",
        "CompressionEngine"
      ],
      "decorators": [],
      "docstring": "Test file decompression.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 256,
      "line_start": 234,
      "module": "tests.test_backup_system",
      "name": "test_decompress_file",
      "signature": "def test_decompress_file(self, temp_test_file):"
    },
    "tests.test_backup_system.test_file_backup_engine_init": {
      "calls": [
        "FileBackupEngine"
      ],
      "decorators": [],
      "docstring": "Test FileBackupEngine initialization.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 173,
      "line_start": 167,
      "module": "tests.test_backup_system",
      "name": "test_file_backup_engine_init",
      "signature": "def test_file_backup_engine_init(self, temp_source_dir, temp_backup_dir):"
    },
    "tests.test_backup_system.test_file_deduplication": {
      "calls": [
        "write_text",
        "engine.create_backup",
        "Path",
        "FileBackupEngine"
      ],
      "decorators": [],
      "docstring": "Test file deduplication functionality.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 196,
      "line_start": 185,
      "module": "tests.test_backup_system",
      "name": "test_file_deduplication",
      "signature": "def test_file_deduplication(self, temp_source_dir, temp_backup_dir):"
    },
    "tests.test_backup_system.test_full_backup_orchestration": {
      "calls": [
        "orchestrator.create_full_backup",
        "BackupOrchestrator"
      ],
      "decorators": [],
      "docstring": "Test full backup orchestration.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 404,
      "line_start": 388,
      "module": "tests.test_backup_system",
      "name": "test_full_backup_orchestration",
      "signature": "def test_full_backup_orchestration(self, temp_dirs):"
    },
    "tests.test_backup_system.test_get_backup_config_defaults": {
      "calls": [
        "get_backup_config",
        "isinstance"
      ],
      "decorators": [],
      "docstring": "Test getting default backup configuration.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 473,
      "line_start": 465,
      "module": "tests.test_backup_system",
      "name": "test_get_backup_config_defaults",
      "signature": "def test_get_backup_config_defaults(self):"
    },
    "tests.test_backup_system.test_list_available_backups": {
      "calls": [
        "isinstance",
        "RecoveryManager",
        "manager.list_available_backups"
      ],
      "decorators": [],
      "docstring": "Test listing available backups.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 458,
      "line_start": 446,
      "module": "tests.test_backup_system",
      "name": "test_list_available_backups",
      "signature": "def test_list_available_backups(self, temp_recovery_setup):"
    },
    "tests.test_backup_system.test_local_storage_backend": {
      "calls": [
        "Path",
        "os.unlink",
        "backend.upload_file",
        "expected_path.exists",
        "LocalStorageBackend",
        "open",
        "backend.delete_file",
        "tempfile.NamedTemporaryFile",
        "original.read",
        "downloaded.read",
        "backend.download_file"
      ],
      "decorators": [],
      "docstring": "Test local storage backend.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 309,
      "line_start": 282,
      "module": "tests.test_backup_system",
      "name": "test_local_storage_backend",
      "signature": "def test_local_storage_backend(self, temp_storage_dir, temp_test_file):"
    },
    "tests.test_backup_system.test_manual_backup_creation": {
      "calls": [
        "isinstance",
        "BackupService",
        "service.create_manual_backup"
      ],
      "decorators": [],
      "docstring": "Test manual backup creation through service.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 568,
      "line_start": 560,
      "module": "tests.test_backup_system",
      "name": "test_manual_backup_creation",
      "signature": "def test_manual_backup_creation(self, temp_service_setup):"
    },
    "tests.test_backup_system.test_orchestrator_init": {
      "calls": [
        "BackupOrchestrator",
        "len"
      ],
      "decorators": [],
      "docstring": "Test BackupOrchestrator initialization.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 386,
      "line_start": 374,
      "module": "tests.test_backup_system",
      "name": "test_orchestrator_init",
      "signature": "def test_orchestrator_init(self, temp_dirs):"
    },
    "tests.test_backup_system.test_recovery_manager_init": {
      "calls": [
        "RecoveryManager",
        "len"
      ],
      "decorators": [],
      "docstring": "Test RecoveryManager initialization.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 444,
      "line_start": 435,
      "module": "tests.test_backup_system",
      "name": "test_recovery_manager_init",
      "signature": "def test_recovery_manager_init(self, temp_recovery_setup):"
    },
    "tests.test_backup_system.test_s3_storage_backend_mock": {
      "calls": [
        "os.unlink",
        "backend.upload_file",
        "mock_s3.delete_object.assert_called_once",
        "backend.delete_file",
        "S3StorageBackend",
        "mock_s3.upload_file.assert_called_once",
        "tempfile.NamedTemporaryFile",
        "mock_s3.download_file.assert_called_once",
        "Mock",
        "patch",
        "backend.download_file"
      ],
      "decorators": [],
      "docstring": "Test S3 storage backend with mocked boto3.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 337,
      "line_start": 311,
      "module": "tests.test_backup_system",
      "name": "test_s3_storage_backend_mock",
      "signature": "def test_s3_storage_backend_mock(self, temp_test_file):"
    },
    "tests.test_backup_system.test_validate_backup_config": {
      "calls": [
        "validate_backup_config"
      ],
      "decorators": [],
      "docstring": "Test backup configuration validation.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 485,
      "line_start": 475,
      "module": "tests.test_backup_system",
      "name": "test_validate_backup_config",
      "signature": "def test_validate_backup_config(self):"
    },
    "tests.test_backup_system.test_validate_backup_config_invalid": {
      "calls": [
        "pytest.raises",
        "validate_backup_config"
      ],
      "decorators": [],
      "docstring": "Test backup configuration validation with invalid config.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 495,
      "line_start": 487,
      "module": "tests.test_backup_system",
      "name": "test_validate_backup_config_invalid",
      "signature": "def test_validate_backup_config_invalid(self):"
    },
    "tests.test_backup_system.test_wal_backup": {
      "calls": [
        "sqlite3.connect",
        "conn.close",
        "conn.execute",
        "engine.backup_wal_files",
        "conn.commit",
        "DatabaseBackupEngine"
      ],
      "decorators": [],
      "docstring": "Test WAL file backup.",
      "file_path": "tests/test_backup_system.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 128,
      "line_start": 115,
      "module": "tests.test_backup_system",
      "name": "test_wal_backup",
      "signature": "def test_wal_backup(self, temp_db, temp_backup_dir):"
    },
    "tests.test_container_security_008.ContainerSecurityTester.__init__": {
      "calls": [
        "Path"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 27,
      "line_start": 24,
      "module": "tests.test_container_security_008",
      "name": "ContainerSecurityTester.__init__",
      "signature": "def __init__(self, project_root: str):"
    },
    "tests.test_container_security_008.ContainerSecurityTester.load_compose_config": {
      "calls": [
        "open",
        "yaml.safe_load"
      ],
      "decorators": [],
      "docstring": "Load and parse docker-compose.yml",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 32,
      "line_start": 29,
      "module": "tests.test_container_security_008",
      "name": "ContainerSecurityTester.load_compose_config",
      "signature": "def load_compose_config(self) -> Dict:"
    },
    "tests.test_container_security_008.ContainerSecurityTester.run_docker_command": {
      "calls": [
        "str",
        "subprocess.run"
      ],
      "decorators": [],
      "docstring": "Run docker command and return exit code, stdout, stderr",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 47,
      "line_start": 34,
      "module": "tests.test_container_security_008",
      "name": "ContainerSecurityTester.run_docker_command",
      "signature": "def run_docker_command(self, cmd: List[str]) -> Tuple[int, str, str]:"
    },
    "tests.test_container_security_008.TestContainerNetworkSecurity.test_network_isolation": {
      "calls": [
        "ContainerSecurityTester",
        "backend.get",
        "Path",
        "networks.items",
        "get",
        "tester.load_compose_config",
        "ipam.get",
        "networks.get",
        "compose_config.get",
        "network_config.get"
      ],
      "decorators": [],
      "docstring": "Test that networks are properly isolated",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 368,
      "line_start": 350,
      "module": "tests.test_container_security_008",
      "name": "TestContainerNetworkSecurity.test_network_isolation",
      "signature": "def test_network_isolation(self):"
    },
    "tests.test_container_security_008.TestContainerNetworkSecurity.test_port_exposure_minimal": {
      "calls": [
        "ContainerSecurityTester",
        "Path",
        "port.split",
        "services.items",
        "len",
        "tester.load_compose_config",
        "service_config.get",
        "isinstance",
        "compose_config.get"
      ],
      "decorators": [],
      "docstring": "Test that only necessary ports are exposed",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 390,
      "line_start": 370,
      "module": "tests.test_container_security_008",
      "name": "TestContainerNetworkSecurity.test_port_exposure_minimal",
      "signature": "def test_port_exposure_minimal(self):"
    },
    "tests.test_container_security_008.TestDockerComposeSecurityContext.compose_config": {
      "calls": [
        "tester.load_compose_config",
        "ContainerSecurityTester",
        "Path"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Load docker-compose configuration",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 118,
      "line_start": 115,
      "module": "tests.test_container_security_008",
      "name": "TestDockerComposeSecurityContext.compose_config",
      "signature": "def compose_config(self):"
    },
    "tests.test_container_security_008.TestDockerComposeSecurityContext.test_capability_dropping": {
      "calls": [
        "service_config.get",
        "compose_config.get",
        "services.items"
      ],
      "decorators": [],
      "docstring": "Test that capabilities are properly dropped",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 166,
      "line_start": 149,
      "module": "tests.test_container_security_008",
      "name": "TestDockerComposeSecurityContext.test_capability_dropping",
      "signature": "def test_capability_dropping(self, compose_config):"
    },
    "tests.test_container_security_008.TestDockerComposeSecurityContext.test_compose_file_exists": {
      "calls": [
        "Path",
        "compose_file.exists"
      ],
      "decorators": [],
      "docstring": "Test that docker-compose.yml exists",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 123,
      "line_start": 120,
      "module": "tests.test_container_security_008",
      "name": "TestDockerComposeSecurityContext.test_compose_file_exists",
      "signature": "def test_compose_file_exists(self):"
    },
    "tests.test_container_security_008.TestDockerComposeSecurityContext.test_environment_security": {
      "calls": [
        "any",
        "services.items",
        "env_var.upper",
        "service_config.get",
        "env_var.endswith",
        "isinstance",
        "environment.items",
        "compose_config.get"
      ],
      "decorators": [],
      "docstring": "Test environment variable security",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 265,
      "line_start": 244,
      "module": "tests.test_container_security_008",
      "name": "TestDockerComposeSecurityContext.test_environment_security",
      "signature": "def test_environment_security(self, compose_config):"
    },
    "tests.test_container_security_008.TestDockerComposeSecurityContext.test_network_security": {
      "calls": [
        "services.items",
        "len",
        "service_config.get",
        "networks.get",
        "backend_network.get",
        "compose_config.get"
      ],
      "decorators": [],
      "docstring": "Test network security configuration",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 228,
      "line_start": 208,
      "module": "tests.test_container_security_008",
      "name": "TestDockerComposeSecurityContext.test_network_security",
      "signature": "def test_network_security(self, compose_config):"
    },
    "tests.test_container_security_008.TestDockerComposeSecurityContext.test_no_privileged_containers": {
      "calls": [
        "service_config.get",
        "compose_config.get",
        "services.items"
      ],
      "decorators": [],
      "docstring": "Test that no containers run in privileged mode",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 131,
      "line_start": 125,
      "module": "tests.test_container_security_008",
      "name": "TestDockerComposeSecurityContext.test_no_privileged_containers",
      "signature": "def test_no_privileged_containers(self, compose_config):"
    },
    "tests.test_container_security_008.TestDockerComposeSecurityContext.test_non_root_users": {
      "calls": [
        "service_config.get",
        "compose_config.get",
        "services.items"
      ],
      "decorators": [],
      "docstring": "Test that services run as non-root users",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 180,
      "line_start": 168,
      "module": "tests.test_container_security_008",
      "name": "TestDockerComposeSecurityContext.test_non_root_users",
      "signature": "def test_non_root_users(self, compose_config):"
    },
    "tests.test_container_security_008.TestDockerComposeSecurityContext.test_read_only_filesystems": {
      "calls": [
        "service_config.get",
        "compose_config.get",
        "services.items",
        "len"
      ],
      "decorators": [],
      "docstring": "Test that containers use read-only filesystems where possible",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 194,
      "line_start": 182,
      "module": "tests.test_container_security_008",
      "name": "TestDockerComposeSecurityContext.test_read_only_filesystems",
      "signature": "def test_read_only_filesystems(self, compose_config):"
    },
    "tests.test_container_security_008.TestDockerComposeSecurityContext.test_resource_limits": {
      "calls": [
        "services.items",
        "deploy.get",
        "service_config.get",
        "resources.get",
        "compose_config.get"
      ],
      "decorators": [],
      "docstring": "Test that resource limits are configured",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 206,
      "line_start": 196,
      "module": "tests.test_container_security_008",
      "name": "TestDockerComposeSecurityContext.test_resource_limits",
      "signature": "def test_resource_limits(self, compose_config):"
    },
    "tests.test_container_security_008.TestDockerComposeSecurityContext.test_security_options_configured": {
      "calls": [
        "any",
        "services.items",
        "len",
        "service_config.get",
        "compose_config.get"
      ],
      "decorators": [],
      "docstring": "Test that security options are configured for services",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 147,
      "line_start": 133,
      "module": "tests.test_container_security_008",
      "name": "TestDockerComposeSecurityContext.test_security_options_configured",
      "signature": "def test_security_options_configured(self, compose_config):"
    },
    "tests.test_container_security_008.TestDockerComposeSecurityContext.test_volume_security": {
      "calls": [
        "any",
        "services.items",
        "service_config.get",
        "isinstance",
        "compose_config.get"
      ],
      "decorators": [],
      "docstring": "Test volume security configuration",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 242,
      "line_start": 230,
      "module": "tests.test_container_security_008",
      "name": "TestDockerComposeSecurityContext.test_volume_security",
      "signature": "def test_volume_security(self, compose_config):"
    },
    "tests.test_container_security_008.TestDockerfileSecurityHardening.test_dockerfile_exists": {
      "calls": [
        "Path",
        "dockerfile.is_file",
        "dockerfile.exists"
      ],
      "decorators": [],
      "docstring": "Test that Dockerfile exists and is readable",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 57,
      "line_start": 53,
      "module": "tests.test_container_security_008",
      "name": "TestDockerfileSecurityHardening.test_dockerfile_exists",
      "signature": "def test_dockerfile_exists(self):"
    },
    "tests.test_container_security_008.TestDockerfileSecurityHardening.test_no_sensitive_files": {
      "calls": [
        "Path",
        "line.strip",
        "line.lower",
        "dockerfile.read_text",
        "startswith",
        "content.split"
      ],
      "decorators": [],
      "docstring": "Test that Dockerfile doesn't copy sensitive files",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 100,
      "line_start": 88,
      "module": "tests.test_container_security_008",
      "name": "TestDockerfileSecurityHardening.test_no_sensitive_files",
      "signature": "def test_no_sensitive_files(self):"
    },
    "tests.test_container_security_008.TestDockerfileSecurityHardening.test_non_root_user": {
      "calls": [
        "Path",
        "dockerfile.read_text"
      ],
      "decorators": [],
      "docstring": "Test that Dockerfile specifies non-root user",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 69,
      "line_start": 59,
      "module": "tests.test_container_security_008",
      "name": "TestDockerfileSecurityHardening.test_non_root_user",
      "signature": "def test_non_root_user(self):"
    },
    "tests.test_container_security_008.TestDockerfileSecurityHardening.test_secure_base_image": {
      "calls": [
        "Path",
        "line.strip",
        "line.count",
        "len",
        "dockerfile.read_text",
        "startswith",
        "content.split"
      ],
      "decorators": [],
      "docstring": "Test that base image uses secure versioning",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 86,
      "line_start": 71,
      "module": "tests.test_container_security_008",
      "name": "TestDockerfileSecurityHardening.test_secure_base_image",
      "signature": "def test_secure_base_image(self):"
    },
    "tests.test_container_security_008.TestDockerfileSecurityHardening.test_security_labels": {
      "calls": [
        "Path",
        "dockerfile.read_text"
      ],
      "decorators": [],
      "docstring": "Test that Dockerfile includes security metadata",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 108,
      "line_start": 102,
      "module": "tests.test_container_security_008",
      "name": "TestDockerfileSecurityHardening.test_security_labels",
      "signature": "def test_security_labels(self):"
    },
    "tests.test_container_security_008.TestRuntimeContainerSecurity.container_tester": {
      "calls": [
        "Path",
        "pytest.fixture",
        "ContainerSecurityTester"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Initialize container security tester",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 274,
      "line_start": 272,
      "module": "tests.test_container_security_008",
      "name": "TestRuntimeContainerSecurity.container_tester",
      "signature": "def container_tester(self):"
    },
    "tests.test_container_security_008.TestRuntimeContainerSecurity.test_container_capabilities": {
      "calls": [
        "stdout.split",
        "line.startswith",
        "container_tester.run_docker_command",
        "pytest.skip",
        "line.split",
        "stdout.strip",
        "split"
      ],
      "decorators": [],
      "docstring": "Test that running containers have minimal capabilities",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 323,
      "line_start": 299,
      "module": "tests.test_container_security_008",
      "name": "TestRuntimeContainerSecurity.test_container_capabilities",
      "signature": "def test_container_capabilities(self, container_tester):"
    },
    "tests.test_container_security_008.TestRuntimeContainerSecurity.test_container_filesystem_readonly": {
      "calls": [
        "pytest.skip",
        "stdout.strip",
        "container_tester.run_docker_command",
        "split"
      ],
      "decorators": [],
      "docstring": "Test that containers use read-only filesystem",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 344,
      "line_start": 325,
      "module": "tests.test_container_security_008",
      "name": "TestRuntimeContainerSecurity.test_container_filesystem_readonly",
      "signature": "def test_container_filesystem_readonly(self, container_tester):"
    },
    "tests.test_container_security_008.TestRuntimeContainerSecurity.test_container_user_id": {
      "calls": [
        "container_tester.run_docker_command",
        "pytest.skip",
        "stdout.strip",
        "split",
        "int"
      ],
      "decorators": [],
      "docstring": "Test that running containers use non-root UIDs",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 297,
      "line_start": 276,
      "module": "tests.test_container_security_008",
      "name": "TestRuntimeContainerSecurity.test_container_user_id",
      "signature": "def test_container_user_id(self, container_tester):"
    },
    "tests.test_container_security_008.__init__": {
      "calls": [
        "Path"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 27,
      "line_start": 24,
      "module": "tests.test_container_security_008",
      "name": "__init__",
      "signature": "def __init__(self, project_root: str):"
    },
    "tests.test_container_security_008.compose_config": {
      "calls": [
        "tester.load_compose_config",
        "ContainerSecurityTester",
        "Path"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Load docker-compose configuration",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 118,
      "line_start": 115,
      "module": "tests.test_container_security_008",
      "name": "compose_config",
      "signature": "def compose_config(self):"
    },
    "tests.test_container_security_008.container_tester": {
      "calls": [
        "Path",
        "pytest.fixture",
        "ContainerSecurityTester"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Initialize container security tester",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 274,
      "line_start": 272,
      "module": "tests.test_container_security_008",
      "name": "container_tester",
      "signature": "def container_tester(self):"
    },
    "tests.test_container_security_008.load_compose_config": {
      "calls": [
        "open",
        "yaml.safe_load"
      ],
      "decorators": [],
      "docstring": "Load and parse docker-compose.yml",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 32,
      "line_start": 29,
      "module": "tests.test_container_security_008",
      "name": "load_compose_config",
      "signature": "def load_compose_config(self) -> Dict:"
    },
    "tests.test_container_security_008.main": {
      "calls": [
        "print",
        "pytest.main"
      ],
      "decorators": [],
      "docstring": "Run container security tests",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 412,
      "line_start": 393,
      "module": "tests.test_container_security_008",
      "name": "main",
      "signature": "def main():"
    },
    "tests.test_container_security_008.run_docker_command": {
      "calls": [
        "str",
        "subprocess.run"
      ],
      "decorators": [],
      "docstring": "Run docker command and return exit code, stdout, stderr",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 47,
      "line_start": 34,
      "module": "tests.test_container_security_008",
      "name": "run_docker_command",
      "signature": "def run_docker_command(self, cmd: List[str]) -> Tuple[int, str, str]:"
    },
    "tests.test_container_security_008.test_capability_dropping": {
      "calls": [
        "service_config.get",
        "compose_config.get",
        "services.items"
      ],
      "decorators": [],
      "docstring": "Test that capabilities are properly dropped",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 166,
      "line_start": 149,
      "module": "tests.test_container_security_008",
      "name": "test_capability_dropping",
      "signature": "def test_capability_dropping(self, compose_config):"
    },
    "tests.test_container_security_008.test_compose_file_exists": {
      "calls": [
        "Path",
        "compose_file.exists"
      ],
      "decorators": [],
      "docstring": "Test that docker-compose.yml exists",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 123,
      "line_start": 120,
      "module": "tests.test_container_security_008",
      "name": "test_compose_file_exists",
      "signature": "def test_compose_file_exists(self):"
    },
    "tests.test_container_security_008.test_container_capabilities": {
      "calls": [
        "stdout.split",
        "line.startswith",
        "container_tester.run_docker_command",
        "pytest.skip",
        "line.split",
        "stdout.strip",
        "split"
      ],
      "decorators": [],
      "docstring": "Test that running containers have minimal capabilities",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 323,
      "line_start": 299,
      "module": "tests.test_container_security_008",
      "name": "test_container_capabilities",
      "signature": "def test_container_capabilities(self, container_tester):"
    },
    "tests.test_container_security_008.test_container_filesystem_readonly": {
      "calls": [
        "pytest.skip",
        "stdout.strip",
        "container_tester.run_docker_command",
        "split"
      ],
      "decorators": [],
      "docstring": "Test that containers use read-only filesystem",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 344,
      "line_start": 325,
      "module": "tests.test_container_security_008",
      "name": "test_container_filesystem_readonly",
      "signature": "def test_container_filesystem_readonly(self, container_tester):"
    },
    "tests.test_container_security_008.test_container_user_id": {
      "calls": [
        "container_tester.run_docker_command",
        "pytest.skip",
        "stdout.strip",
        "split",
        "int"
      ],
      "decorators": [],
      "docstring": "Test that running containers use non-root UIDs",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 297,
      "line_start": 276,
      "module": "tests.test_container_security_008",
      "name": "test_container_user_id",
      "signature": "def test_container_user_id(self, container_tester):"
    },
    "tests.test_container_security_008.test_dockerfile_exists": {
      "calls": [
        "Path",
        "dockerfile.is_file",
        "dockerfile.exists"
      ],
      "decorators": [],
      "docstring": "Test that Dockerfile exists and is readable",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 57,
      "line_start": 53,
      "module": "tests.test_container_security_008",
      "name": "test_dockerfile_exists",
      "signature": "def test_dockerfile_exists(self):"
    },
    "tests.test_container_security_008.test_environment_security": {
      "calls": [
        "any",
        "services.items",
        "env_var.upper",
        "service_config.get",
        "env_var.endswith",
        "isinstance",
        "environment.items",
        "compose_config.get"
      ],
      "decorators": [],
      "docstring": "Test environment variable security",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 265,
      "line_start": 244,
      "module": "tests.test_container_security_008",
      "name": "test_environment_security",
      "signature": "def test_environment_security(self, compose_config):"
    },
    "tests.test_container_security_008.test_network_isolation": {
      "calls": [
        "ContainerSecurityTester",
        "backend.get",
        "Path",
        "networks.items",
        "get",
        "tester.load_compose_config",
        "ipam.get",
        "networks.get",
        "compose_config.get",
        "network_config.get"
      ],
      "decorators": [],
      "docstring": "Test that networks are properly isolated",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 368,
      "line_start": 350,
      "module": "tests.test_container_security_008",
      "name": "test_network_isolation",
      "signature": "def test_network_isolation(self):"
    },
    "tests.test_container_security_008.test_network_security": {
      "calls": [
        "services.items",
        "len",
        "service_config.get",
        "networks.get",
        "backend_network.get",
        "compose_config.get"
      ],
      "decorators": [],
      "docstring": "Test network security configuration",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 228,
      "line_start": 208,
      "module": "tests.test_container_security_008",
      "name": "test_network_security",
      "signature": "def test_network_security(self, compose_config):"
    },
    "tests.test_container_security_008.test_no_privileged_containers": {
      "calls": [
        "service_config.get",
        "compose_config.get",
        "services.items"
      ],
      "decorators": [],
      "docstring": "Test that no containers run in privileged mode",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 131,
      "line_start": 125,
      "module": "tests.test_container_security_008",
      "name": "test_no_privileged_containers",
      "signature": "def test_no_privileged_containers(self, compose_config):"
    },
    "tests.test_container_security_008.test_no_sensitive_files": {
      "calls": [
        "Path",
        "line.strip",
        "line.lower",
        "dockerfile.read_text",
        "startswith",
        "content.split"
      ],
      "decorators": [],
      "docstring": "Test that Dockerfile doesn't copy sensitive files",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 100,
      "line_start": 88,
      "module": "tests.test_container_security_008",
      "name": "test_no_sensitive_files",
      "signature": "def test_no_sensitive_files(self):"
    },
    "tests.test_container_security_008.test_non_root_user": {
      "calls": [
        "Path",
        "dockerfile.read_text"
      ],
      "decorators": [],
      "docstring": "Test that Dockerfile specifies non-root user",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 69,
      "line_start": 59,
      "module": "tests.test_container_security_008",
      "name": "test_non_root_user",
      "signature": "def test_non_root_user(self):"
    },
    "tests.test_container_security_008.test_non_root_users": {
      "calls": [
        "service_config.get",
        "compose_config.get",
        "services.items"
      ],
      "decorators": [],
      "docstring": "Test that services run as non-root users",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 180,
      "line_start": 168,
      "module": "tests.test_container_security_008",
      "name": "test_non_root_users",
      "signature": "def test_non_root_users(self, compose_config):"
    },
    "tests.test_container_security_008.test_port_exposure_minimal": {
      "calls": [
        "ContainerSecurityTester",
        "Path",
        "port.split",
        "services.items",
        "len",
        "tester.load_compose_config",
        "service_config.get",
        "isinstance",
        "compose_config.get"
      ],
      "decorators": [],
      "docstring": "Test that only necessary ports are exposed",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 390,
      "line_start": 370,
      "module": "tests.test_container_security_008",
      "name": "test_port_exposure_minimal",
      "signature": "def test_port_exposure_minimal(self):"
    },
    "tests.test_container_security_008.test_read_only_filesystems": {
      "calls": [
        "service_config.get",
        "compose_config.get",
        "services.items",
        "len"
      ],
      "decorators": [],
      "docstring": "Test that containers use read-only filesystems where possible",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 194,
      "line_start": 182,
      "module": "tests.test_container_security_008",
      "name": "test_read_only_filesystems",
      "signature": "def test_read_only_filesystems(self, compose_config):"
    },
    "tests.test_container_security_008.test_resource_limits": {
      "calls": [
        "services.items",
        "deploy.get",
        "service_config.get",
        "resources.get",
        "compose_config.get"
      ],
      "decorators": [],
      "docstring": "Test that resource limits are configured",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 206,
      "line_start": 196,
      "module": "tests.test_container_security_008",
      "name": "test_resource_limits",
      "signature": "def test_resource_limits(self, compose_config):"
    },
    "tests.test_container_security_008.test_secure_base_image": {
      "calls": [
        "Path",
        "line.strip",
        "line.count",
        "len",
        "dockerfile.read_text",
        "startswith",
        "content.split"
      ],
      "decorators": [],
      "docstring": "Test that base image uses secure versioning",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 86,
      "line_start": 71,
      "module": "tests.test_container_security_008",
      "name": "test_secure_base_image",
      "signature": "def test_secure_base_image(self):"
    },
    "tests.test_container_security_008.test_security_labels": {
      "calls": [
        "Path",
        "dockerfile.read_text"
      ],
      "decorators": [],
      "docstring": "Test that Dockerfile includes security metadata",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 108,
      "line_start": 102,
      "module": "tests.test_container_security_008",
      "name": "test_security_labels",
      "signature": "def test_security_labels(self):"
    },
    "tests.test_container_security_008.test_security_options_configured": {
      "calls": [
        "any",
        "services.items",
        "len",
        "service_config.get",
        "compose_config.get"
      ],
      "decorators": [],
      "docstring": "Test that security options are configured for services",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 147,
      "line_start": 133,
      "module": "tests.test_container_security_008",
      "name": "test_security_options_configured",
      "signature": "def test_security_options_configured(self, compose_config):"
    },
    "tests.test_container_security_008.test_volume_security": {
      "calls": [
        "any",
        "services.items",
        "service_config.get",
        "isinstance",
        "compose_config.get"
      ],
      "decorators": [],
      "docstring": "Test volume security configuration",
      "file_path": "tests/test_container_security_008.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 242,
      "line_start": 230,
      "module": "tests.test_container_security_008",
      "name": "test_volume_security",
      "signature": "def test_volume_security(self, compose_config):"
    },
    "tests.test_database_performance_011.BenchmarkRunner.__init__": {
      "calls": [
        "DatabasePerformanceTester"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "tests/test_database_performance_011.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 318,
      "line_start": 317,
      "module": "tests.test_database_performance_011",
      "name": "BenchmarkRunner.__init__",
      "signature": "def __init__(self):"
    },
    "tests.test_database_performance_011.BenchmarkRunner.run_baseline_benchmarks": {
      "calls": [
        "self.tester.time_operation",
        "User",
        "OptimizedAuditLogQueries.get_user_activity_summary",
        "statistics.mean",
        "len",
        "print",
        "first",
        "min",
        "filter",
        "statistics.stdev",
        "db.query",
        "datetime.utcnow",
        "self.tester.get_db_session",
        "OptimizedJobQueries.get_job_statistics",
        "OptimizedJobQueries.get_jobs_by_user_paginated",
        "OptimizedMetadataQueries.get_metadata_analytics",
        "self.tester.generate_test_data",
        "db.add",
        "self.tester.performance_results.items",
        "max",
        "db.commit"
      ],
      "decorators": [],
      "docstring": "Run baseline performance benchmarks",
      "file_path": "tests/test_database_performance_011.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 368,
      "line_start": 320,
      "module": "tests.test_database_performance_011",
      "name": "BenchmarkRunner.run_baseline_benchmarks",
      "signature": "def run_baseline_benchmarks(self) -> Dict[str, Any]:"
    },
    "tests.test_database_performance_011.BenchmarkRunner.run_stress_test": {
      "calls": [
        "random.choice",
        "OptimizedJobQueries.get_job_statistics",
        "OptimizedJobQueries.get_jobs_by_user_paginated",
        "print",
        "first",
        "filter",
        "OptimizedMetadataQueries.get_metadata_analytics",
        "time.time",
        "db.query",
        "max",
        "self.tester.get_db_session",
        "random.randint"
      ],
      "decorators": [],
      "docstring": "Run stress test to identify performance limits",
      "file_path": "tests/test_database_performance_011.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 415,
      "line_start": 370,
      "module": "tests.test_database_performance_011",
      "name": "BenchmarkRunner.run_stress_test",
      "signature": "def run_stress_test(self, duration_seconds: int = 60) -> Dict[str, Any]:"
    },
    "tests.test_database_performance_011.DatabasePerformanceTester.__init__": {
      "calls": [
        "Base.metadata.create_all",
        "QueryPerformanceMonitor",
        "sessionmaker",
        "create_engine"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "tests/test_database_performance_011.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 47,
      "line_start": 34,
      "module": "tests.test_database_performance_011",
      "name": "DatabasePerformanceTester.__init__",
      "signature": "def __init__(self, database_url: str = \"sqlite:///:memory:\"):"
    },
    "tests.test_database_performance_011.DatabasePerformanceTester.generate_test_data": {
      "calls": [
        "User",
        "limit",
        "self.get_db_session",
        "random.uniform",
        "random.choices",
        "AuditLog",
        "print",
        "filter",
        "db.query",
        "datetime.utcnow",
        "all",
        "int",
        "random.randint",
        "Job",
        "timedelta",
        "list",
        "random.random",
        "users.append",
        "db.flush",
        "join",
        "random.choice",
        "db.add",
        "TranscriptMetadata",
        "range",
        "db.commit"
      ],
      "decorators": [],
      "docstring": "Generate test data for performance testing",
      "file_path": "tests/test_database_performance_011.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 174,
      "line_start": 69,
      "module": "tests.test_database_performance_011",
      "name": "DatabasePerformanceTester.generate_test_data",
      "signature": "def generate_test_data(self, num_users: int = 100, num_jobs: int = 1000, num_metadata: int = 500):"
    },
    "tests.test_database_performance_011.DatabasePerformanceTester.get_db_session": {
      "calls": [
        "db.close",
        "self.SessionLocal"
      ],
      "decorators": [
        "contextmanager"
      ],
      "docstring": "Get database session for testing",
      "file_path": "tests/test_database_performance_011.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 56,
      "line_start": 50,
      "module": "tests.test_database_performance_011",
      "name": "DatabasePerformanceTester.get_db_session",
      "signature": "def get_db_session(self):"
    },
    "tests.test_database_performance_011.DatabasePerformanceTester.time_operation": {
      "calls": [
        "append",
        "time.time"
      ],
      "decorators": [
        "contextmanager"
      ],
      "docstring": "Time an operation and store results",
      "file_path": "tests/test_database_performance_011.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 67,
      "line_start": 59,
      "module": "tests.test_database_performance_011",
      "name": "DatabasePerformanceTester.time_operation",
      "signature": "def time_operation(self, operation_name: str):"
    },
    "tests.test_database_performance_011.TestDatabasePerformanceOptimizations.performance_tester": {
      "calls": [
        "pytest.fixture",
        "DatabasePerformanceTester",
        "tester.generate_test_data"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Setup performance testing environment",
      "file_path": "tests/test_database_performance_011.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 185,
      "line_start": 181,
      "module": "tests.test_database_performance_011",
      "name": "TestDatabasePerformanceOptimizations.performance_tester",
      "signature": "def performance_tester(self):"
    },
    "tests.test_database_performance_011.TestDatabasePerformanceOptimizations.test_index_effectiveness": {
      "calls": [
        "count",
        "print",
        "first",
        "filter",
        "statistics.mean",
        "limit",
        "Job.created_at.desc",
        "db.query",
        "query_func",
        "order_by",
        "all",
        "performance_tester.time_operation",
        "performance_tester.get_db_session"
      ],
      "decorators": [],
      "docstring": "Test that indexes are being used effectively",
      "file_path": "tests/test_database_performance_011.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 311,
      "line_start": 291,
      "module": "tests.test_database_performance_011",
      "name": "TestDatabasePerformanceOptimizations.test_index_effectiveness",
      "signature": "def test_index_effectiveness(self, performance_tester):"
    },
    "tests.test_database_performance_011.TestDatabasePerformanceOptimizations.test_job_listing_performance": {
      "calls": [
        "OptimizedJobQueries.get_jobs_by_user_paginated",
        "print",
        "limit",
        "first",
        "statistics.mean",
        "filter",
        "Job.created_at.desc",
        "order_by",
        "db.query",
        "all",
        "performance_tester.time_operation",
        "performance_tester.get_db_session"
      ],
      "decorators": [],
      "docstring": "Test job listing performance with different approaches",
      "file_path": "tests/test_database_performance_011.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 210,
      "line_start": 187,
      "module": "tests.test_database_performance_011",
      "name": "TestDatabasePerformanceOptimizations.test_job_listing_performance",
      "signature": "def test_job_listing_performance(self, performance_tester):"
    },
    "tests.test_database_performance_011.TestDatabasePerformanceOptimizations.test_job_statistics_performance": {
      "calls": [
        "OptimizedJobQueries.get_job_statistics",
        "count",
        "func.avg",
        "print",
        "filter",
        "statistics.mean",
        "db.query",
        "scalar",
        "performance_tester.time_operation",
        "performance_tester.get_db_session"
      ],
      "decorators": [],
      "docstring": "Test job statistics performance",
      "file_path": "tests/test_database_performance_011.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 232,
      "line_start": 212,
      "module": "tests.test_database_performance_011",
      "name": "TestDatabasePerformanceOptimizations.test_job_statistics_performance",
      "signature": "def test_job_statistics_performance(self, performance_tester):"
    },
    "tests.test_database_performance_011.TestDatabasePerformanceOptimizations.test_metadata_analytics_performance": {
      "calls": [
        "print",
        "OptimizedMetadataQueries.get_metadata_analytics",
        "statistics.mean",
        "isinstance",
        "performance_tester.time_operation",
        "performance_tester.get_db_session"
      ],
      "decorators": [],
      "docstring": "Test metadata analytics performance",
      "file_path": "tests/test_database_performance_011.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 258,
      "line_start": 247,
      "module": "tests.test_database_performance_011",
      "name": "TestDatabasePerformanceOptimizations.test_metadata_analytics_performance",
      "signature": "def test_metadata_analytics_performance(self, performance_tester):"
    },
    "tests.test_database_performance_011.TestDatabasePerformanceOptimizations.test_pagination_performance": {
      "calls": [
        "len",
        "limit",
        "Job.created_at.desc",
        "order_by",
        "offset",
        "db.query",
        "all",
        "performance_tester.time_operation",
        "performance_tester.get_db_session"
      ],
      "decorators": [],
      "docstring": "Test pagination performance with large datasets",
      "file_path": "tests/test_database_performance_011.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 289,
      "line_start": 274,
      "module": "tests.test_database_performance_011",
      "name": "TestDatabasePerformanceOptimizations.test_pagination_performance",
      "signature": "def test_pagination_performance(self, performance_tester):"
    },
    "tests.test_database_performance_011.TestDatabasePerformanceOptimizations.test_search_performance": {
      "calls": [
        "len",
        "limit",
        "print",
        "filter",
        "statistics.mean",
        "Job.original_filename.ilike",
        "Job.created_at.desc",
        "order_by",
        "db.query",
        "performance_tester.time_operation",
        "search_query.all",
        "performance_tester.get_db_session"
      ],
      "decorators": [],
      "docstring": "Test search query performance",
      "file_path": "tests/test_database_performance_011.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 272,
      "line_start": 260,
      "module": "tests.test_database_performance_011",
      "name": "TestDatabasePerformanceOptimizations.test_search_performance",
      "signature": "def test_search_performance(self, performance_tester):"
    },
    "tests.test_database_performance_011.TestDatabasePerformanceOptimizations.test_user_activity_performance": {
      "calls": [
        "print",
        "OptimizedAuditLogQueries.get_user_activity_summary",
        "statistics.mean",
        "isinstance",
        "performance_tester.time_operation",
        "performance_tester.get_db_session"
      ],
      "decorators": [],
      "docstring": "Test user activity query performance",
      "file_path": "tests/test_database_performance_011.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 245,
      "line_start": 234,
      "module": "tests.test_database_performance_011",
      "name": "TestDatabasePerformanceOptimizations.test_user_activity_performance",
      "signature": "def test_user_activity_performance(self, performance_tester):"
    },
    "tests.test_database_performance_011.__init__": {
      "calls": [
        "DatabasePerformanceTester"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "tests/test_database_performance_011.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 318,
      "line_start": 317,
      "module": "tests.test_database_performance_011",
      "name": "__init__",
      "signature": "def __init__(self):"
    },
    "tests.test_database_performance_011.generate_test_data": {
      "calls": [
        "User",
        "limit",
        "self.get_db_session",
        "random.uniform",
        "random.choices",
        "AuditLog",
        "print",
        "filter",
        "db.query",
        "datetime.utcnow",
        "all",
        "int",
        "random.randint",
        "Job",
        "timedelta",
        "list",
        "random.random",
        "users.append",
        "db.flush",
        "join",
        "random.choice",
        "db.add",
        "TranscriptMetadata",
        "range",
        "db.commit"
      ],
      "decorators": [],
      "docstring": "Generate test data for performance testing",
      "file_path": "tests/test_database_performance_011.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 174,
      "line_start": 69,
      "module": "tests.test_database_performance_011",
      "name": "generate_test_data",
      "signature": "def generate_test_data(self, num_users: int = 100, num_jobs: int = 1000, num_metadata: int = 500):"
    },
    "tests.test_database_performance_011.get_db_session": {
      "calls": [
        "db.close",
        "self.SessionLocal"
      ],
      "decorators": [
        "contextmanager"
      ],
      "docstring": "Get database session for testing",
      "file_path": "tests/test_database_performance_011.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 56,
      "line_start": 50,
      "module": "tests.test_database_performance_011",
      "name": "get_db_session",
      "signature": "def get_db_session(self):"
    },
    "tests.test_database_performance_011.main": {
      "calls": [
        "print",
        "runner.run_baseline_benchmarks",
        "benchmarks.items",
        "runner.run_stress_test",
        "BenchmarkRunner",
        "pytest.main"
      ],
      "decorators": [],
      "docstring": "Run database performance tests and benchmarks",
      "file_path": "tests/test_database_performance_011.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 469,
      "line_start": 418,
      "module": "tests.test_database_performance_011",
      "name": "main",
      "signature": "def main():"
    },
    "tests.test_database_performance_011.performance_tester": {
      "calls": [
        "pytest.fixture",
        "DatabasePerformanceTester",
        "tester.generate_test_data"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Setup performance testing environment",
      "file_path": "tests/test_database_performance_011.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 185,
      "line_start": 181,
      "module": "tests.test_database_performance_011",
      "name": "performance_tester",
      "signature": "def performance_tester(self):"
    },
    "tests.test_database_performance_011.run_baseline_benchmarks": {
      "calls": [
        "self.tester.time_operation",
        "User",
        "OptimizedAuditLogQueries.get_user_activity_summary",
        "statistics.mean",
        "len",
        "print",
        "first",
        "min",
        "filter",
        "statistics.stdev",
        "db.query",
        "datetime.utcnow",
        "self.tester.get_db_session",
        "OptimizedJobQueries.get_job_statistics",
        "OptimizedJobQueries.get_jobs_by_user_paginated",
        "OptimizedMetadataQueries.get_metadata_analytics",
        "self.tester.generate_test_data",
        "db.add",
        "self.tester.performance_results.items",
        "max",
        "db.commit"
      ],
      "decorators": [],
      "docstring": "Run baseline performance benchmarks",
      "file_path": "tests/test_database_performance_011.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 368,
      "line_start": 320,
      "module": "tests.test_database_performance_011",
      "name": "run_baseline_benchmarks",
      "signature": "def run_baseline_benchmarks(self) -> Dict[str, Any]:"
    },
    "tests.test_database_performance_011.run_stress_test": {
      "calls": [
        "random.choice",
        "OptimizedJobQueries.get_job_statistics",
        "OptimizedJobQueries.get_jobs_by_user_paginated",
        "print",
        "first",
        "filter",
        "OptimizedMetadataQueries.get_metadata_analytics",
        "time.time",
        "db.query",
        "max",
        "self.tester.get_db_session",
        "random.randint"
      ],
      "decorators": [],
      "docstring": "Run stress test to identify performance limits",
      "file_path": "tests/test_database_performance_011.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 415,
      "line_start": 370,
      "module": "tests.test_database_performance_011",
      "name": "run_stress_test",
      "signature": "def run_stress_test(self, duration_seconds: int = 60) -> Dict[str, Any]:"
    },
    "tests.test_database_performance_011.test_index_effectiveness": {
      "calls": [
        "count",
        "print",
        "first",
        "filter",
        "statistics.mean",
        "limit",
        "Job.created_at.desc",
        "db.query",
        "query_func",
        "order_by",
        "all",
        "performance_tester.time_operation",
        "performance_tester.get_db_session"
      ],
      "decorators": [],
      "docstring": "Test that indexes are being used effectively",
      "file_path": "tests/test_database_performance_011.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 311,
      "line_start": 291,
      "module": "tests.test_database_performance_011",
      "name": "test_index_effectiveness",
      "signature": "def test_index_effectiveness(self, performance_tester):"
    },
    "tests.test_database_performance_011.test_job_listing_performance": {
      "calls": [
        "OptimizedJobQueries.get_jobs_by_user_paginated",
        "print",
        "limit",
        "first",
        "statistics.mean",
        "filter",
        "Job.created_at.desc",
        "order_by",
        "db.query",
        "all",
        "performance_tester.time_operation",
        "performance_tester.get_db_session"
      ],
      "decorators": [],
      "docstring": "Test job listing performance with different approaches",
      "file_path": "tests/test_database_performance_011.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 210,
      "line_start": 187,
      "module": "tests.test_database_performance_011",
      "name": "test_job_listing_performance",
      "signature": "def test_job_listing_performance(self, performance_tester):"
    },
    "tests.test_database_performance_011.test_job_statistics_performance": {
      "calls": [
        "OptimizedJobQueries.get_job_statistics",
        "count",
        "func.avg",
        "print",
        "filter",
        "statistics.mean",
        "db.query",
        "scalar",
        "performance_tester.time_operation",
        "performance_tester.get_db_session"
      ],
      "decorators": [],
      "docstring": "Test job statistics performance",
      "file_path": "tests/test_database_performance_011.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 232,
      "line_start": 212,
      "module": "tests.test_database_performance_011",
      "name": "test_job_statistics_performance",
      "signature": "def test_job_statistics_performance(self, performance_tester):"
    },
    "tests.test_database_performance_011.test_metadata_analytics_performance": {
      "calls": [
        "print",
        "OptimizedMetadataQueries.get_metadata_analytics",
        "statistics.mean",
        "isinstance",
        "performance_tester.time_operation",
        "performance_tester.get_db_session"
      ],
      "decorators": [],
      "docstring": "Test metadata analytics performance",
      "file_path": "tests/test_database_performance_011.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 258,
      "line_start": 247,
      "module": "tests.test_database_performance_011",
      "name": "test_metadata_analytics_performance",
      "signature": "def test_metadata_analytics_performance(self, performance_tester):"
    },
    "tests.test_database_performance_011.test_pagination_performance": {
      "calls": [
        "len",
        "limit",
        "Job.created_at.desc",
        "order_by",
        "offset",
        "db.query",
        "all",
        "performance_tester.time_operation",
        "performance_tester.get_db_session"
      ],
      "decorators": [],
      "docstring": "Test pagination performance with large datasets",
      "file_path": "tests/test_database_performance_011.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 289,
      "line_start": 274,
      "module": "tests.test_database_performance_011",
      "name": "test_pagination_performance",
      "signature": "def test_pagination_performance(self, performance_tester):"
    },
    "tests.test_database_performance_011.test_search_performance": {
      "calls": [
        "len",
        "limit",
        "print",
        "filter",
        "statistics.mean",
        "Job.original_filename.ilike",
        "Job.created_at.desc",
        "order_by",
        "db.query",
        "performance_tester.time_operation",
        "search_query.all",
        "performance_tester.get_db_session"
      ],
      "decorators": [],
      "docstring": "Test search query performance",
      "file_path": "tests/test_database_performance_011.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 272,
      "line_start": 260,
      "module": "tests.test_database_performance_011",
      "name": "test_search_performance",
      "signature": "def test_search_performance(self, performance_tester):"
    },
    "tests.test_database_performance_011.test_user_activity_performance": {
      "calls": [
        "print",
        "OptimizedAuditLogQueries.get_user_activity_summary",
        "statistics.mean",
        "isinstance",
        "performance_tester.time_operation",
        "performance_tester.get_db_session"
      ],
      "decorators": [],
      "docstring": "Test user activity query performance",
      "file_path": "tests/test_database_performance_011.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 245,
      "line_start": 234,
      "module": "tests.test_database_performance_011",
      "name": "test_user_activity_performance",
      "signature": "def test_user_activity_performance(self, performance_tester):"
    },
    "tests.test_database_performance_011.time_operation": {
      "calls": [
        "append",
        "time.time"
      ],
      "decorators": [
        "contextmanager"
      ],
      "docstring": "Time an operation and store results",
      "file_path": "tests/test_database_performance_011.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 67,
      "line_start": 59,
      "module": "tests.test_database_performance_011",
      "name": "time_operation",
      "signature": "def time_operation(self, operation_name: str):"
    },
    "tests.test_pagination_009.TestCursorGeneration.test_cursor_generation": {
      "calls": [
        "isinstance",
        "CursorGenerator.generate_cursor",
        "CursorGenerator.parse_cursor",
        "len"
      ],
      "decorators": [],
      "docstring": "Test cursor generation and parsing.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 478,
      "line_start": 459,
      "module": "tests.test_pagination_009",
      "name": "TestCursorGeneration.test_cursor_generation",
      "signature": "def test_cursor_generation(self):"
    },
    "tests.test_pagination_009.TestCursorGeneration.test_cursor_parsing_errors": {
      "calls": [
        "base64.b64encode",
        "encode",
        "decode",
        "CursorGenerator.parse_cursor",
        "pytest.raises",
        "json.dumps"
      ],
      "decorators": [],
      "docstring": "Test cursor parsing error handling.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 496,
      "line_start": 480,
      "module": "tests.test_pagination_009",
      "name": "TestCursorGeneration.test_cursor_parsing_errors",
      "signature": "def test_cursor_parsing_errors(self):"
    },
    "tests.test_pagination_009.TestPaginationCore.get_auth_headers": {
      "calls": [
        "client.post",
        "login_response.json"
      ],
      "decorators": [],
      "docstring": "Get authentication headers for testing.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 106,
      "line_start": 99,
      "module": "tests.test_pagination_009",
      "name": "TestPaginationCore.get_auth_headers",
      "signature": "def get_auth_headers(self, username=\"testuser\"):"
    },
    "tests.test_pagination_009.TestPaginationCore.setup_database": {
      "calls": [
        "pytest.fixture",
        "db.close",
        "Job",
        "db.add",
        "User",
        "timedelta",
        "datetime.utcnow",
        "Base.metadata.drop_all",
        "range",
        "db.commit",
        "Base.metadata.create_all",
        "TestingSessionLocal"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Set up test database with sample data.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 97,
      "line_start": 46,
      "module": "tests.test_pagination_009",
      "name": "TestPaginationCore.setup_database",
      "signature": "def setup_database(self):"
    },
    "tests.test_pagination_009.TestPaginationCore.test_admin_endpoint": {
      "calls": [
        "client.get",
        "len",
        "self.get_auth_headers",
        "response.json"
      ],
      "decorators": [],
      "docstring": "Test admin-specific job listing endpoint.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 229,
      "line_start": 215,
      "module": "tests.test_pagination_009",
      "name": "TestPaginationCore.test_admin_endpoint",
      "signature": "def test_admin_endpoint(self):"
    },
    "tests.test_pagination_009.TestPaginationCore.test_basic_pagination": {
      "calls": [
        "client.get",
        "len",
        "self.get_auth_headers",
        "response.json"
      ],
      "decorators": [],
      "docstring": "Test basic pagination without cursor.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 127,
      "line_start": 108,
      "module": "tests.test_pagination_009",
      "name": "TestPaginationCore.test_basic_pagination",
      "signature": "def test_basic_pagination(self):"
    },
    "tests.test_pagination_009.TestPaginationCore.test_cursor_navigation": {
      "calls": [
        "job_ids_1.isdisjoint",
        "self.get_auth_headers",
        "client.get",
        "response1.json",
        "response2.json"
      ],
      "decorators": [],
      "docstring": "Test cursor-based navigation through pages.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 157,
      "line_start": 129,
      "module": "tests.test_pagination_009",
      "name": "TestPaginationCore.test_cursor_navigation",
      "signature": "def test_cursor_navigation(self):"
    },
    "tests.test_pagination_009.TestPaginationCore.test_filtering": {
      "calls": [
        "client.get",
        "self.get_auth_headers",
        "response.json"
      ],
      "decorators": [],
      "docstring": "Test job filtering capabilities.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 197,
      "line_start": 179,
      "module": "tests.test_pagination_009",
      "name": "TestPaginationCore.test_filtering",
      "signature": "def test_filtering(self):"
    },
    "tests.test_pagination_009.TestPaginationCore.test_sorting_options": {
      "calls": [
        "replace",
        "self.get_auth_headers",
        "response.json",
        "len",
        "client.get",
        "datetime.fromisoformat",
        "range"
      ],
      "decorators": [],
      "docstring": "Test different sorting options.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 177,
      "line_start": 159,
      "module": "tests.test_pagination_009",
      "name": "TestPaginationCore.test_sorting_options",
      "signature": "def test_sorting_options(self):"
    },
    "tests.test_pagination_009.TestPaginationCore.test_total_count_optional": {
      "calls": [
        "client.get",
        "self.get_auth_headers",
        "response.json"
      ],
      "decorators": [],
      "docstring": "Test optional total count functionality.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 213,
      "line_start": 199,
      "module": "tests.test_pagination_009",
      "name": "TestPaginationCore.test_total_count_optional",
      "signature": "def test_total_count_optional(self):"
    },
    "tests.test_pagination_009.TestPaginationEdgeCases.get_auth_headers": {
      "calls": [
        "client.post",
        "login_response.json"
      ],
      "decorators": [],
      "docstring": "Get authentication headers for testing.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 263,
      "line_start": 256,
      "module": "tests.test_pagination_009",
      "name": "TestPaginationEdgeCases.get_auth_headers",
      "signature": "def get_auth_headers(self):"
    },
    "tests.test_pagination_009.TestPaginationEdgeCases.setup_database": {
      "calls": [
        "pytest.fixture",
        "db.close",
        "db.add",
        "User",
        "Base.metadata.drop_all",
        "db.commit",
        "Base.metadata.create_all",
        "TestingSessionLocal"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Set up minimal test database.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 254,
      "line_start": 236,
      "module": "tests.test_pagination_009",
      "name": "TestPaginationEdgeCases.setup_database",
      "signature": "def setup_database(self):"
    },
    "tests.test_pagination_009.TestPaginationEdgeCases.test_empty_dataset": {
      "calls": [
        "client.get",
        "self.get_auth_headers",
        "response.json"
      ],
      "decorators": [],
      "docstring": "Test pagination with no data.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 277,
      "line_start": 265,
      "module": "tests.test_pagination_009",
      "name": "TestPaginationEdgeCases.test_empty_dataset",
      "signature": "def test_empty_dataset(self):"
    },
    "tests.test_pagination_009.TestPaginationEdgeCases.test_invalid_cursor": {
      "calls": [
        "base64.b64encode",
        "self.get_auth_headers",
        "response.json",
        "encode",
        "json.dumps",
        "decode",
        "timedelta",
        "client.get",
        "datetime.utcnow",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Test invalid cursor handling.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 317,
      "line_start": 295,
      "module": "tests.test_pagination_009",
      "name": "TestPaginationEdgeCases.test_invalid_cursor",
      "signature": "def test_invalid_cursor(self):"
    },
    "tests.test_pagination_009.TestPaginationEdgeCases.test_invalid_filter_values": {
      "calls": [
        "client.get",
        "self.get_auth_headers"
      ],
      "decorators": [],
      "docstring": "Test invalid filter value validation.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 343,
      "line_start": 333,
      "module": "tests.test_pagination_009",
      "name": "TestPaginationEdgeCases.test_invalid_filter_values",
      "signature": "def test_invalid_filter_values(self):"
    },
    "tests.test_pagination_009.TestPaginationEdgeCases.test_invalid_page_size": {
      "calls": [
        "client.get",
        "self.get_auth_headers"
      ],
      "decorators": [],
      "docstring": "Test invalid page size validation.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 293,
      "line_start": 279,
      "module": "tests.test_pagination_009",
      "name": "TestPaginationEdgeCases.test_invalid_page_size",
      "signature": "def test_invalid_page_size(self):"
    },
    "tests.test_pagination_009.TestPaginationEdgeCases.test_invalid_sort_field": {
      "calls": [
        "client.get",
        "self.get_auth_headers"
      ],
      "decorators": [],
      "docstring": "Test invalid sort field validation.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 324,
      "line_start": 319,
      "module": "tests.test_pagination_009",
      "name": "TestPaginationEdgeCases.test_invalid_sort_field",
      "signature": "def test_invalid_sort_field(self):"
    },
    "tests.test_pagination_009.TestPaginationEdgeCases.test_invalid_sort_order": {
      "calls": [
        "client.get",
        "self.get_auth_headers"
      ],
      "decorators": [],
      "docstring": "Test invalid sort order validation.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 331,
      "line_start": 326,
      "module": "tests.test_pagination_009",
      "name": "TestPaginationEdgeCases.test_invalid_sort_order",
      "signature": "def test_invalid_sort_order(self):"
    },
    "tests.test_pagination_009.TestPaginationPerformance.get_auth_headers": {
      "calls": [
        "client.post",
        "login_response.json"
      ],
      "decorators": [],
      "docstring": "Get authentication headers for testing.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 397,
      "line_start": 390,
      "module": "tests.test_pagination_009",
      "name": "TestPaginationPerformance.get_auth_headers",
      "signature": "def get_auth_headers(self):"
    },
    "tests.test_pagination_009.TestPaginationPerformance.setup_large_dataset": {
      "calls": [
        "pytest.fixture",
        "db.close",
        "db.commit",
        "Job",
        "db.add_all",
        "db.add",
        "User",
        "timedelta",
        "datetime.utcnow",
        "Base.metadata.drop_all",
        "range",
        "jobs.append",
        "Base.metadata.create_all",
        "TestingSessionLocal"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Set up large dataset for performance testing.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 388,
      "line_start": 350,
      "module": "tests.test_pagination_009",
      "name": "TestPaginationPerformance.setup_large_dataset",
      "signature": "def setup_large_dataset(self):"
    },
    "tests.test_pagination_009.TestPaginationPerformance.test_large_dataset_pagination": {
      "calls": [
        "client.get",
        "len",
        "self.get_auth_headers",
        "response.json"
      ],
      "decorators": [],
      "docstring": "Test pagination with large dataset.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 428,
      "line_start": 399,
      "module": "tests.test_pagination_009",
      "name": "TestPaginationPerformance.test_large_dataset_pagination",
      "signature": "def test_large_dataset_pagination(self):"
    },
    "tests.test_pagination_009.TestPaginationPerformance.test_total_count_performance": {
      "calls": [
        "time.time",
        "client.get",
        "self.get_auth_headers",
        "response.json"
      ],
      "decorators": [],
      "docstring": "Test total count performance impact.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 453,
      "line_start": 430,
      "module": "tests.test_pagination_009",
      "name": "TestPaginationPerformance.test_total_count_performance",
      "signature": "def test_total_count_performance(self):"
    },
    "tests.test_pagination_009.get_auth_headers": {
      "calls": [
        "client.post",
        "login_response.json"
      ],
      "decorators": [],
      "docstring": "Get authentication headers for testing.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 397,
      "line_start": 390,
      "module": "tests.test_pagination_009",
      "name": "get_auth_headers",
      "signature": "def get_auth_headers(self):"
    },
    "tests.test_pagination_009.override_get_db": {
      "calls": [
        "db.close",
        "TestingSessionLocal"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 35,
      "line_start": 30,
      "module": "tests.test_pagination_009",
      "name": "override_get_db",
      "signature": "def override_get_db():"
    },
    "tests.test_pagination_009.setup_database": {
      "calls": [
        "pytest.fixture",
        "db.close",
        "db.add",
        "User",
        "Base.metadata.drop_all",
        "db.commit",
        "Base.metadata.create_all",
        "TestingSessionLocal"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Set up minimal test database.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 254,
      "line_start": 236,
      "module": "tests.test_pagination_009",
      "name": "setup_database",
      "signature": "def setup_database(self):"
    },
    "tests.test_pagination_009.setup_large_dataset": {
      "calls": [
        "pytest.fixture",
        "db.close",
        "db.commit",
        "Job",
        "db.add_all",
        "db.add",
        "User",
        "timedelta",
        "datetime.utcnow",
        "Base.metadata.drop_all",
        "range",
        "jobs.append",
        "Base.metadata.create_all",
        "TestingSessionLocal"
      ],
      "decorators": [
        "pytest.fixture"
      ],
      "docstring": "Set up large dataset for performance testing.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 388,
      "line_start": 350,
      "module": "tests.test_pagination_009",
      "name": "setup_large_dataset",
      "signature": "def setup_large_dataset(self):"
    },
    "tests.test_pagination_009.test_admin_endpoint": {
      "calls": [
        "client.get",
        "len",
        "self.get_auth_headers",
        "response.json"
      ],
      "decorators": [],
      "docstring": "Test admin-specific job listing endpoint.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 229,
      "line_start": 215,
      "module": "tests.test_pagination_009",
      "name": "test_admin_endpoint",
      "signature": "def test_admin_endpoint(self):"
    },
    "tests.test_pagination_009.test_basic_pagination": {
      "calls": [
        "client.get",
        "len",
        "self.get_auth_headers",
        "response.json"
      ],
      "decorators": [],
      "docstring": "Test basic pagination without cursor.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 127,
      "line_start": 108,
      "module": "tests.test_pagination_009",
      "name": "test_basic_pagination",
      "signature": "def test_basic_pagination(self):"
    },
    "tests.test_pagination_009.test_cursor_generation": {
      "calls": [
        "isinstance",
        "CursorGenerator.generate_cursor",
        "CursorGenerator.parse_cursor",
        "len"
      ],
      "decorators": [],
      "docstring": "Test cursor generation and parsing.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 478,
      "line_start": 459,
      "module": "tests.test_pagination_009",
      "name": "test_cursor_generation",
      "signature": "def test_cursor_generation(self):"
    },
    "tests.test_pagination_009.test_cursor_navigation": {
      "calls": [
        "job_ids_1.isdisjoint",
        "self.get_auth_headers",
        "client.get",
        "response1.json",
        "response2.json"
      ],
      "decorators": [],
      "docstring": "Test cursor-based navigation through pages.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 157,
      "line_start": 129,
      "module": "tests.test_pagination_009",
      "name": "test_cursor_navigation",
      "signature": "def test_cursor_navigation(self):"
    },
    "tests.test_pagination_009.test_cursor_parsing_errors": {
      "calls": [
        "base64.b64encode",
        "encode",
        "decode",
        "CursorGenerator.parse_cursor",
        "pytest.raises",
        "json.dumps"
      ],
      "decorators": [],
      "docstring": "Test cursor parsing error handling.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 496,
      "line_start": 480,
      "module": "tests.test_pagination_009",
      "name": "test_cursor_parsing_errors",
      "signature": "def test_cursor_parsing_errors(self):"
    },
    "tests.test_pagination_009.test_empty_dataset": {
      "calls": [
        "client.get",
        "self.get_auth_headers",
        "response.json"
      ],
      "decorators": [],
      "docstring": "Test pagination with no data.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 277,
      "line_start": 265,
      "module": "tests.test_pagination_009",
      "name": "test_empty_dataset",
      "signature": "def test_empty_dataset(self):"
    },
    "tests.test_pagination_009.test_filtering": {
      "calls": [
        "client.get",
        "self.get_auth_headers",
        "response.json"
      ],
      "decorators": [],
      "docstring": "Test job filtering capabilities.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 197,
      "line_start": 179,
      "module": "tests.test_pagination_009",
      "name": "test_filtering",
      "signature": "def test_filtering(self):"
    },
    "tests.test_pagination_009.test_invalid_cursor": {
      "calls": [
        "base64.b64encode",
        "self.get_auth_headers",
        "response.json",
        "encode",
        "json.dumps",
        "decode",
        "timedelta",
        "client.get",
        "datetime.utcnow",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Test invalid cursor handling.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 317,
      "line_start": 295,
      "module": "tests.test_pagination_009",
      "name": "test_invalid_cursor",
      "signature": "def test_invalid_cursor(self):"
    },
    "tests.test_pagination_009.test_invalid_filter_values": {
      "calls": [
        "client.get",
        "self.get_auth_headers"
      ],
      "decorators": [],
      "docstring": "Test invalid filter value validation.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 343,
      "line_start": 333,
      "module": "tests.test_pagination_009",
      "name": "test_invalid_filter_values",
      "signature": "def test_invalid_filter_values(self):"
    },
    "tests.test_pagination_009.test_invalid_page_size": {
      "calls": [
        "client.get",
        "self.get_auth_headers"
      ],
      "decorators": [],
      "docstring": "Test invalid page size validation.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 293,
      "line_start": 279,
      "module": "tests.test_pagination_009",
      "name": "test_invalid_page_size",
      "signature": "def test_invalid_page_size(self):"
    },
    "tests.test_pagination_009.test_invalid_sort_field": {
      "calls": [
        "client.get",
        "self.get_auth_headers"
      ],
      "decorators": [],
      "docstring": "Test invalid sort field validation.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 324,
      "line_start": 319,
      "module": "tests.test_pagination_009",
      "name": "test_invalid_sort_field",
      "signature": "def test_invalid_sort_field(self):"
    },
    "tests.test_pagination_009.test_invalid_sort_order": {
      "calls": [
        "client.get",
        "self.get_auth_headers"
      ],
      "decorators": [],
      "docstring": "Test invalid sort order validation.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 331,
      "line_start": 326,
      "module": "tests.test_pagination_009",
      "name": "test_invalid_sort_order",
      "signature": "def test_invalid_sort_order(self):"
    },
    "tests.test_pagination_009.test_large_dataset_pagination": {
      "calls": [
        "client.get",
        "len",
        "self.get_auth_headers",
        "response.json"
      ],
      "decorators": [],
      "docstring": "Test pagination with large dataset.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 428,
      "line_start": 399,
      "module": "tests.test_pagination_009",
      "name": "test_large_dataset_pagination",
      "signature": "def test_large_dataset_pagination(self):"
    },
    "tests.test_pagination_009.test_sorting_options": {
      "calls": [
        "replace",
        "self.get_auth_headers",
        "response.json",
        "len",
        "client.get",
        "datetime.fromisoformat",
        "range"
      ],
      "decorators": [],
      "docstring": "Test different sorting options.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 177,
      "line_start": 159,
      "module": "tests.test_pagination_009",
      "name": "test_sorting_options",
      "signature": "def test_sorting_options(self):"
    },
    "tests.test_pagination_009.test_total_count_optional": {
      "calls": [
        "client.get",
        "self.get_auth_headers",
        "response.json"
      ],
      "decorators": [],
      "docstring": "Test optional total count functionality.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 213,
      "line_start": 199,
      "module": "tests.test_pagination_009",
      "name": "test_total_count_optional",
      "signature": "def test_total_count_optional(self):"
    },
    "tests.test_pagination_009.test_total_count_performance": {
      "calls": [
        "time.time",
        "client.get",
        "self.get_auth_headers",
        "response.json"
      ],
      "decorators": [],
      "docstring": "Test total count performance impact.",
      "file_path": "tests/test_pagination_009.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 453,
      "line_start": 430,
      "module": "tests.test_pagination_009",
      "name": "test_total_count_performance",
      "signature": "def test_total_count_performance(self):"
    },
    "tests.test_security_007.SecurityTestSuite.__init__": {
      "calls": [
        "print",
        "requests.Session"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "tests/test_security_007.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 51,
      "line_start": 39,
      "module": "tests.test_security_007",
      "name": "SecurityTestSuite.__init__",
      "signature": "def __init__(self, base_url: str = \"http://localhost:8000\"):"
    },
    "tests.test_security_007.SecurityTestSuite.print_test_summary": {
      "calls": [
        "datetime.now",
        "print"
      ],
      "decorators": [],
      "docstring": "Print comprehensive test summary.",
      "file_path": "tests/test_security_007.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 584,
      "line_start": 551,
      "module": "tests.test_security_007",
      "name": "SecurityTestSuite.print_test_summary",
      "signature": "def print_test_summary(self) -> None:"
    },
    "tests.test_security_007.SecurityTestSuite.run_all_tests": {
      "calls": [
        "datetime.now",
        "print",
        "self.print_test_summary",
        "self.setup_authentication",
        "test_func"
      ],
      "decorators": [],
      "docstring": "Run complete security test suite.",
      "file_path": "tests/test_security_007.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 549,
      "line_start": 519,
      "module": "tests.test_security_007",
      "name": "SecurityTestSuite.run_all_tests",
      "signature": "def run_all_tests(self) -> bool:"
    },
    "tests.test_security_007.SecurityTestSuite.setup_authentication": {
      "calls": [
        "print",
        "self.session.post",
        "response.json"
      ],
      "decorators": [],
      "docstring": "Setup authentication tokens for testing.",
      "file_path": "tests/test_security_007.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 76,
      "line_start": 53,
      "module": "tests.test_security_007",
      "name": "SecurityTestSuite.setup_authentication",
      "signature": "def setup_authentication(self) -> bool:"
    },
    "tests.test_security_007.SecurityTestSuite.test_concurrent_requests": {
      "calls": [
        "threading.Thread",
        "results.append",
        "len",
        "print",
        "sum",
        "thread.start",
        "time.sleep",
        "self.session.get",
        "range",
        "threads.append",
        "thread.join"
      ],
      "decorators": [],
      "docstring": "Test security under concurrent load.",
      "file_path": "tests/test_security_007.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 517,
      "line_start": 470,
      "module": "tests.test_security_007",
      "name": "SecurityTestSuite.test_concurrent_requests",
      "signature": "def test_concurrent_requests(self) -> bool:"
    },
    "tests.test_security_007.SecurityTestSuite.test_endpoint_security": {
      "calls": [
        "len",
        "print",
        "self.session.post",
        "self.session.get",
        "self.session.delete"
      ],
      "decorators": [],
      "docstring": "Test endpoint-specific security measures.",
      "file_path": "tests/test_security_007.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 468,
      "line_start": 389,
      "module": "tests.test_security_007",
      "name": "SecurityTestSuite.test_endpoint_security",
      "signature": "def test_endpoint_security(self) -> bool:"
    },
    "tests.test_security_007.SecurityTestSuite.test_file_upload_security": {
      "calls": [
        "tmp_file.write",
        "os.unlink",
        "tmp_file.flush",
        "open",
        "print",
        "headers.copy",
        "str",
        "self.session.post",
        "tempfile.NamedTemporaryFile"
      ],
      "decorators": [],
      "docstring": "Test file upload security validation.",
      "file_path": "tests/test_security_007.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 387,
      "line_start": 279,
      "module": "tests.test_security_007",
      "name": "SecurityTestSuite.test_file_upload_security",
      "signature": "def test_file_upload_security(self) -> bool:"
    },
    "tests.test_security_007.SecurityTestSuite.test_input_validation": {
      "calls": [
        "print",
        "self.session.post"
      ],
      "decorators": [],
      "docstring": "Test comprehensive input validation.",
      "file_path": "tests/test_security_007.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 239,
      "line_start": 120,
      "module": "tests.test_security_007",
      "name": "SecurityTestSuite.test_input_validation",
      "signature": "def test_input_validation(self) -> bool:"
    },
    "tests.test_security_007.SecurityTestSuite.test_rate_limiting": {
      "calls": [
        "self.session.get",
        "print",
        "time.sleep",
        "range"
      ],
      "decorators": [],
      "docstring": "Test rate limiting functionality.",
      "file_path": "tests/test_security_007.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 118,
      "line_start": 78,
      "module": "tests.test_security_007",
      "name": "SecurityTestSuite.test_rate_limiting",
      "signature": "def test_rate_limiting(self) -> bool:"
    },
    "tests.test_security_007.SecurityTestSuite.test_security_headers": {
      "calls": [
        "self.session.get",
        "print",
        "len"
      ],
      "decorators": [],
      "docstring": "Test security headers enforcement.",
      "file_path": "tests/test_security_007.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 277,
      "line_start": 241,
      "module": "tests.test_security_007",
      "name": "SecurityTestSuite.test_security_headers",
      "signature": "def test_security_headers(self) -> bool:"
    },
    "tests.test_security_007.__init__": {
      "calls": [
        "print",
        "requests.Session"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "tests/test_security_007.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 51,
      "line_start": 39,
      "module": "tests.test_security_007",
      "name": "__init__",
      "signature": "def __init__(self, base_url: str = \"http://localhost:8000\"):"
    },
    "tests.test_security_007.main": {
      "calls": [
        "SecurityTestSuite",
        "test_suite.run_all_tests",
        "print",
        "requests.get"
      ],
      "decorators": [],
      "docstring": "Main test execution function.",
      "file_path": "tests/test_security_007.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 603,
      "line_start": 587,
      "module": "tests.test_security_007",
      "name": "main",
      "signature": "def main():"
    },
    "tests.test_security_007.make_requests": {
      "calls": [
        "self.session.get",
        "time.sleep",
        "results.append",
        "range"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "tests/test_security_007.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 487,
      "line_start": 480,
      "module": "tests.test_security_007",
      "name": "make_requests",
      "signature": "def make_requests():"
    },
    "tests.test_security_007.print_test_summary": {
      "calls": [
        "datetime.now",
        "print"
      ],
      "decorators": [],
      "docstring": "Print comprehensive test summary.",
      "file_path": "tests/test_security_007.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 584,
      "line_start": 551,
      "module": "tests.test_security_007",
      "name": "print_test_summary",
      "signature": "def print_test_summary(self) -> None:"
    },
    "tests.test_security_007.run_all_tests": {
      "calls": [
        "datetime.now",
        "print",
        "self.print_test_summary",
        "self.setup_authentication",
        "test_func"
      ],
      "decorators": [],
      "docstring": "Run complete security test suite.",
      "file_path": "tests/test_security_007.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 549,
      "line_start": 519,
      "module": "tests.test_security_007",
      "name": "run_all_tests",
      "signature": "def run_all_tests(self) -> bool:"
    },
    "tests.test_security_007.setup_authentication": {
      "calls": [
        "print",
        "self.session.post",
        "response.json"
      ],
      "decorators": [],
      "docstring": "Setup authentication tokens for testing.",
      "file_path": "tests/test_security_007.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 76,
      "line_start": 53,
      "module": "tests.test_security_007",
      "name": "setup_authentication",
      "signature": "def setup_authentication(self) -> bool:"
    },
    "tests.test_security_007.test_concurrent_requests": {
      "calls": [
        "threading.Thread",
        "results.append",
        "len",
        "print",
        "sum",
        "thread.start",
        "time.sleep",
        "self.session.get",
        "range",
        "threads.append",
        "thread.join"
      ],
      "decorators": [],
      "docstring": "Test security under concurrent load.",
      "file_path": "tests/test_security_007.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 517,
      "line_start": 470,
      "module": "tests.test_security_007",
      "name": "test_concurrent_requests",
      "signature": "def test_concurrent_requests(self) -> bool:"
    },
    "tests.test_security_007.test_endpoint_security": {
      "calls": [
        "len",
        "print",
        "self.session.post",
        "self.session.get",
        "self.session.delete"
      ],
      "decorators": [],
      "docstring": "Test endpoint-specific security measures.",
      "file_path": "tests/test_security_007.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 468,
      "line_start": 389,
      "module": "tests.test_security_007",
      "name": "test_endpoint_security",
      "signature": "def test_endpoint_security(self) -> bool:"
    },
    "tests.test_security_007.test_file_upload_security": {
      "calls": [
        "tmp_file.write",
        "os.unlink",
        "tmp_file.flush",
        "open",
        "print",
        "headers.copy",
        "str",
        "self.session.post",
        "tempfile.NamedTemporaryFile"
      ],
      "decorators": [],
      "docstring": "Test file upload security validation.",
      "file_path": "tests/test_security_007.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 387,
      "line_start": 279,
      "module": "tests.test_security_007",
      "name": "test_file_upload_security",
      "signature": "def test_file_upload_security(self) -> bool:"
    },
    "tests.test_security_007.test_input_validation": {
      "calls": [
        "print",
        "self.session.post"
      ],
      "decorators": [],
      "docstring": "Test comprehensive input validation.",
      "file_path": "tests/test_security_007.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 239,
      "line_start": 120,
      "module": "tests.test_security_007",
      "name": "test_input_validation",
      "signature": "def test_input_validation(self) -> bool:"
    },
    "tests.test_security_007.test_rate_limiting": {
      "calls": [
        "self.session.get",
        "print",
        "time.sleep",
        "range"
      ],
      "decorators": [],
      "docstring": "Test rate limiting functionality.",
      "file_path": "tests/test_security_007.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 118,
      "line_start": 78,
      "module": "tests.test_security_007",
      "name": "test_rate_limiting",
      "signature": "def test_rate_limiting(self) -> bool:"
    },
    "tests.test_security_007.test_security_headers": {
      "calls": [
        "self.session.get",
        "print",
        "len"
      ],
      "decorators": [],
      "docstring": "Test security headers enforcement.",
      "file_path": "tests/test_security_007.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 277,
      "line_start": 241,
      "module": "tests.test_security_007",
      "name": "test_security_headers",
      "signature": "def test_security_headers(self) -> bool:"
    },
    "tools.comprehensive_validator.ComprehensiveValidator.__init__": {
      "calls": [
        "time.time",
        "self._load_inventory",
        "self._load_config"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 74,
      "line_start": 70,
      "module": "tools.comprehensive_validator",
      "name": "ComprehensiveValidator.__init__",
      "signature": "def __init__(self):"
    },
    "tools.comprehensive_validator.ComprehensiveValidator._generate_recommendations": {
      "calls": [
        "recommendations.append",
        "len"
      ],
      "decorators": [],
      "docstring": "Generate system-wide recommendations.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 893,
      "line_start": 873,
      "module": "tools.comprehensive_validator",
      "name": "ComprehensiveValidator._generate_recommendations",
      "signature": "def _generate_recommendations(self, component_statuses: List[ComponentStatus]) -> List[str]:"
    },
    "tools.comprehensive_validator.ComprehensiveValidator._get_component_status": {
      "calls": [
        "recommendations.append",
        "ComponentStatus",
        "len"
      ],
      "decorators": [],
      "docstring": "Calculate component status from test results.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 767,
      "line_start": 724,
      "module": "tools.comprehensive_validator",
      "name": "ComprehensiveValidator._get_component_status",
      "signature": "def _get_component_status(self, component: str, duration_ms: float) -> ComponentStatus:"
    },
    "tools.comprehensive_validator.ComprehensiveValidator._load_config": {
      "calls": [
        "Path",
        "line.strip",
        "open",
        "exists",
        "line.split",
        "line.startswith"
      ],
      "decorators": [],
      "docstring": "Load environment configuration.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 99,
      "line_start": 86,
      "module": "tools.comprehensive_validator",
      "name": "ComprehensiveValidator._load_config",
      "signature": "def _load_config(self) -> Dict:"
    },
    "tools.comprehensive_validator.ComprehensiveValidator._load_inventory": {
      "calls": [
        "Path",
        "json.load",
        "open",
        "sys.exit",
        "logger.error",
        "inventory_path.exists"
      ],
      "decorators": [],
      "docstring": "Load the current system inventory.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 84,
      "line_start": 76,
      "module": "tools.comprehensive_validator",
      "name": "ComprehensiveValidator._load_inventory",
      "signature": "def _load_inventory(self) -> Dict:"
    },
    "tools.comprehensive_validator.ComprehensiveValidator._record_result": {
      "calls": [
        "TestResult",
        "logger.log",
        "self.results.append"
      ],
      "decorators": [],
      "docstring": "Record a test result.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 123,
      "line_start": 101,
      "module": "tools.comprehensive_validator",
      "name": "ComprehensiveValidator._record_result",
      "signature": "def _record_result(self, component: str, test_name: str, status: str, message: str, duration_ms: float, details: Optional[Dict] = None, error: Optional[str] = None):"
    },
    "tools.comprehensive_validator.ComprehensiveValidator._test_auth_endpoints": {
      "calls": [
        "requests.post",
        "str",
        "self.config.get"
      ],
      "decorators": [],
      "docstring": "Test authentication endpoints.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 590,
      "line_start": 569,
      "module": "tools.comprehensive_validator",
      "name": "ComprehensiveValidator._test_auth_endpoints",
      "signature": "def _test_auth_endpoints(self):"
    },
    "tools.comprehensive_validator.ComprehensiveValidator._test_backup_modules": {
      "calls": [
        "__import__",
        "Exception",
        "len",
        "imported.append",
        "str"
      ],
      "decorators": [],
      "docstring": "Test backup system modules.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 650,
      "line_start": 626,
      "module": "tools.comprehensive_validator",
      "name": "ComprehensiveValidator._test_backup_modules",
      "signature": "def _test_backup_modules(self):"
    },
    "tools.comprehensive_validator.ComprehensiveValidator._test_config_consistency": {
      "calls": [
        "db_url.startswith",
        "lower",
        "self.config.get",
        "issues.append",
        "int"
      ],
      "decorators": [],
      "docstring": "Test configuration consistency.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 526,
      "line_start": 498,
      "module": "tools.comprehensive_validator",
      "name": "ComprehensiveValidator._test_config_consistency",
      "signature": "def _test_config_consistency(self):"
    },
    "tools.comprehensive_validator.ComprehensiveValidator._test_database_connection": {
      "calls": [
        "cursor.execute",
        "sqlite3.connect",
        "conn.close",
        "cursor.fetchone",
        "conn.cursor"
      ],
      "decorators": [],
      "docstring": "Test basic database connection.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 294,
      "line_start": 274,
      "module": "tools.comprehensive_validator",
      "name": "ComprehensiveValidator._test_database_connection",
      "signature": "def _test_database_connection(self, db_path: str):"
    },
    "tools.comprehensive_validator.ComprehensiveValidator._test_database_performance": {
      "calls": [
        "cursor.execute",
        "sqlite3.connect",
        "conn.close",
        "cursor.fetchone",
        "conn.cursor",
        "time.time"
      ],
      "decorators": [],
      "docstring": "Test database performance with simple queries.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 352,
      "line_start": 329,
      "module": "tools.comprehensive_validator",
      "name": "ComprehensiveValidator._test_database_performance",
      "signature": "def _test_database_performance(self, db_path: str):"
    },
    "tools.comprehensive_validator.ComprehensiveValidator._test_database_schema": {
      "calls": [
        "cursor.execute",
        "sqlite3.connect",
        "set",
        "conn.close",
        "len",
        "list",
        "conn.cursor",
        "cursor.fetchall"
      ],
      "decorators": [],
      "docstring": "Test database schema against expected tables.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 327,
      "line_start": 296,
      "module": "tools.comprehensive_validator",
      "name": "ComprehensiveValidator._test_database_schema",
      "signature": "def _test_database_schema(self, db_path: str):"
    },
    "tools.comprehensive_validator.ComprehensiveValidator._test_disk_space": {
      "calls": [
        "psutil.disk_usage",
        "str"
      ],
      "decorators": [],
      "docstring": "Test available disk space.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 458,
      "line_start": 431,
      "module": "tools.comprehensive_validator",
      "name": "ComprehensiveValidator._test_disk_space",
      "signature": "def _test_disk_space(self):"
    },
    "tools.comprehensive_validator.ComprehensiveValidator._test_endpoint": {
      "calls": [
        "str",
        "requests.request"
      ],
      "decorators": [],
      "docstring": "Test a single API endpoint.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 213,
      "line_start": 187,
      "module": "tools.comprehensive_validator",
      "name": "ComprehensiveValidator._test_endpoint",
      "signature": "def _test_endpoint(self, method: str, url: str, auth_required: bool):"
    },
    "tools.comprehensive_validator.ComprehensiveValidator._test_file_permissions": {
      "calls": [
        "Path",
        "test_dir.mkdir",
        "test_file.unlink",
        "str",
        "test_file.write_text",
        "test_file.read_text"
      ],
      "decorators": [],
      "docstring": "Test file system permissions.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 429,
      "line_start": 403,
      "module": "tools.comprehensive_validator",
      "name": "ComprehensiveValidator._test_file_permissions",
      "signature": "def _test_file_permissions(self):"
    },
    "tools.comprehensive_validator.ComprehensiveValidator._test_system_resources": {
      "calls": [
        "join",
        "psutil.pids",
        "len",
        "str",
        "psutil.cpu_percent",
        "issues.append",
        "psutil.virtual_memory"
      ],
      "decorators": [],
      "docstring": "Test system resource availability.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 722,
      "line_start": 688,
      "module": "tools.comprehensive_validator",
      "name": "ComprehensiveValidator._test_system_resources",
      "signature": "def _test_system_resources(self):"
    },
    "tools.comprehensive_validator.ComprehensiveValidator._time_test": {
      "calls": [
        "time.time",
        "str",
        "func"
      ],
      "decorators": [],
      "docstring": "Execute a test function and measure duration.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 134,
      "line_start": 125,
      "module": "tools.comprehensive_validator",
      "name": "ComprehensiveValidator._time_test",
      "signature": "def _time_test(self, func, *args, **kwargs):"
    },
    "tools.comprehensive_validator.ComprehensiveValidator.run_comprehensive_validation": {
      "calls": [
        "self.validate_performance",
        "ComponentStatus",
        "self._generate_recommendations",
        "logger.warning",
        "len",
        "traceback.format_exc",
        "sum",
        "datetime.utcnow",
        "logger.info",
        "self.inventory.get",
        "self.validate_file_system",
        "time.time",
        "self.validate_configuration",
        "self.validate_backup_system",
        "component_statuses.append",
        "str",
        "self.validate_api_endpoints",
        "logger.error",
        "self.validate_security",
        "asdict",
        "self.validate_database",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Run comprehensive validation of all or specified components.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 871,
      "line_start": 769,
      "module": "tools.comprehensive_validator",
      "name": "ComprehensiveValidator.run_comprehensive_validation",
      "signature": "async def run_comprehensive_validation(self, components: Optional[List[str]] = None) -> Dict:"
    },
    "tools.comprehensive_validator.ComprehensiveValidator.save_report": {
      "calls": [
        "Path",
        "open",
        "logger.info",
        "strftime",
        "datetime.utcnow",
        "report_path.parent.mkdir",
        "json.dump"
      ],
      "decorators": [],
      "docstring": "Save validation report to file.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 908,
      "line_start": 895,
      "module": "tools.comprehensive_validator",
      "name": "ComprehensiveValidator.save_report",
      "signature": "def save_report(self, report: Dict, filename: Optional[str] = None):"
    },
    "tools.comprehensive_validator.ComprehensiveValidator.validate_api_endpoints": {
      "calls": [
        "self._time_test",
        "replace",
        "logger.info",
        "self.inventory.get",
        "self.config.get",
        "time.time",
        "self._record_result",
        "endpoint.get",
        "path.replace",
        "self._get_component_status",
        "requests.get"
      ],
      "decorators": [],
      "docstring": "Test all documented API endpoints.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 185,
      "line_start": 136,
      "module": "tools.comprehensive_validator",
      "name": "ComprehensiveValidator.validate_api_endpoints",
      "signature": "async def validate_api_endpoints(self) -> ComponentStatus:"
    },
    "tools.comprehensive_validator.ComprehensiveValidator.validate_backup_system": {
      "calls": [
        "Path",
        "self._time_test",
        "exists",
        "logger.info",
        "self.config.get",
        "time.time",
        "self._record_result",
        "self._get_component_status",
        "backup_dir.replace"
      ],
      "decorators": [],
      "docstring": "Test backup system functionality.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 624,
      "line_start": 592,
      "module": "tools.comprehensive_validator",
      "name": "ComprehensiveValidator.validate_backup_system",
      "signature": "def validate_backup_system(self) -> ComponentStatus:"
    },
    "tools.comprehensive_validator.ComprehensiveValidator.validate_configuration": {
      "calls": [
        "Path",
        "self._time_test",
        "exists",
        "logger.info",
        "time.time",
        "self._record_result",
        "self._get_component_status"
      ],
      "decorators": [],
      "docstring": "Test configuration validity and completeness.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 496,
      "line_start": 460,
      "module": "tools.comprehensive_validator",
      "name": "ComprehensiveValidator.validate_configuration",
      "signature": "def validate_configuration(self) -> ComponentStatus:"
    },
    "tools.comprehensive_validator.ComprehensiveValidator.validate_database": {
      "calls": [
        "Path",
        "self._time_test",
        "Path.cwd",
        "db_url.startswith",
        "db_path.startswith",
        "logger.info",
        "str",
        "self.config.get",
        "time.time",
        "db_path.exists",
        "self._record_result",
        "self._get_component_status",
        "db_url.replace"
      ],
      "decorators": [],
      "docstring": "Test database integrity and operations.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 272,
      "line_start": 215,
      "module": "tools.comprehensive_validator",
      "name": "ComprehensiveValidator.validate_database",
      "signature": "def validate_database(self) -> ComponentStatus:"
    },
    "tools.comprehensive_validator.ComprehensiveValidator.validate_file_system": {
      "calls": [
        "Path",
        "self._time_test",
        "dir_path.exists",
        "dir_path.is_dir",
        "logger.info",
        "time.time",
        "self._record_result",
        "self._get_component_status"
      ],
      "decorators": [],
      "docstring": "Test file system components and permissions.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 401,
      "line_start": 354,
      "module": "tools.comprehensive_validator",
      "name": "ComprehensiveValidator.validate_file_system",
      "signature": "def validate_file_system(self) -> ComponentStatus:"
    },
    "tools.comprehensive_validator.ComprehensiveValidator.validate_performance": {
      "calls": [
        "self._time_test",
        "endpoint.split",
        "logger.info",
        "self.config.get",
        "time.time",
        "self._record_result",
        "self._get_component_status",
        "requests.get"
      ],
      "decorators": [],
      "docstring": "Test performance monitoring and metrics.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 686,
      "line_start": 652,
      "module": "tools.comprehensive_validator",
      "name": "ComprehensiveValidator.validate_performance",
      "signature": "def validate_performance(self) -> ComponentStatus:"
    },
    "tools.comprehensive_validator.ComprehensiveValidator.validate_security": {
      "calls": [
        "self._time_test",
        "len",
        "logger.info",
        "self.config.get",
        "time.time",
        "self._record_result",
        "self._get_component_status"
      ],
      "decorators": [],
      "docstring": "Test security features and configurations.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 567,
      "line_start": 528,
      "module": "tools.comprehensive_validator",
      "name": "ComprehensiveValidator.validate_security",
      "signature": "def validate_security(self) -> ComponentStatus:"
    },
    "tools.comprehensive_validator.__init__": {
      "calls": [
        "time.time",
        "self._load_inventory",
        "self._load_config"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 74,
      "line_start": 70,
      "module": "tools.comprehensive_validator",
      "name": "__init__",
      "signature": "def __init__(self):"
    },
    "tools.comprehensive_validator._generate_recommendations": {
      "calls": [
        "recommendations.append",
        "len"
      ],
      "decorators": [],
      "docstring": "Generate system-wide recommendations.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 893,
      "line_start": 873,
      "module": "tools.comprehensive_validator",
      "name": "_generate_recommendations",
      "signature": "def _generate_recommendations(self, component_statuses: List[ComponentStatus]) -> List[str]:"
    },
    "tools.comprehensive_validator._get_component_status": {
      "calls": [
        "recommendations.append",
        "ComponentStatus",
        "len"
      ],
      "decorators": [],
      "docstring": "Calculate component status from test results.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 767,
      "line_start": 724,
      "module": "tools.comprehensive_validator",
      "name": "_get_component_status",
      "signature": "def _get_component_status(self, component: str, duration_ms: float) -> ComponentStatus:"
    },
    "tools.comprehensive_validator._load_config": {
      "calls": [
        "Path",
        "line.strip",
        "open",
        "exists",
        "line.split",
        "line.startswith"
      ],
      "decorators": [],
      "docstring": "Load environment configuration.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 99,
      "line_start": 86,
      "module": "tools.comprehensive_validator",
      "name": "_load_config",
      "signature": "def _load_config(self) -> Dict:"
    },
    "tools.comprehensive_validator._load_inventory": {
      "calls": [
        "Path",
        "json.load",
        "open",
        "sys.exit",
        "logger.error",
        "inventory_path.exists"
      ],
      "decorators": [],
      "docstring": "Load the current system inventory.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 84,
      "line_start": 76,
      "module": "tools.comprehensive_validator",
      "name": "_load_inventory",
      "signature": "def _load_inventory(self) -> Dict:"
    },
    "tools.comprehensive_validator._record_result": {
      "calls": [
        "TestResult",
        "logger.log",
        "self.results.append"
      ],
      "decorators": [],
      "docstring": "Record a test result.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 123,
      "line_start": 101,
      "module": "tools.comprehensive_validator",
      "name": "_record_result",
      "signature": "def _record_result(self, component: str, test_name: str, status: str, message: str, duration_ms: float, details: Optional[Dict] = None, error: Optional[str] = None):"
    },
    "tools.comprehensive_validator._test_auth_endpoints": {
      "calls": [
        "requests.post",
        "str",
        "self.config.get"
      ],
      "decorators": [],
      "docstring": "Test authentication endpoints.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 590,
      "line_start": 569,
      "module": "tools.comprehensive_validator",
      "name": "_test_auth_endpoints",
      "signature": "def _test_auth_endpoints(self):"
    },
    "tools.comprehensive_validator._test_backup_modules": {
      "calls": [
        "__import__",
        "Exception",
        "len",
        "imported.append",
        "str"
      ],
      "decorators": [],
      "docstring": "Test backup system modules.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 650,
      "line_start": 626,
      "module": "tools.comprehensive_validator",
      "name": "_test_backup_modules",
      "signature": "def _test_backup_modules(self):"
    },
    "tools.comprehensive_validator._test_config_consistency": {
      "calls": [
        "db_url.startswith",
        "lower",
        "self.config.get",
        "issues.append",
        "int"
      ],
      "decorators": [],
      "docstring": "Test configuration consistency.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 526,
      "line_start": 498,
      "module": "tools.comprehensive_validator",
      "name": "_test_config_consistency",
      "signature": "def _test_config_consistency(self):"
    },
    "tools.comprehensive_validator._test_database_connection": {
      "calls": [
        "cursor.execute",
        "sqlite3.connect",
        "conn.close",
        "cursor.fetchone",
        "conn.cursor"
      ],
      "decorators": [],
      "docstring": "Test basic database connection.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 294,
      "line_start": 274,
      "module": "tools.comprehensive_validator",
      "name": "_test_database_connection",
      "signature": "def _test_database_connection(self, db_path: str):"
    },
    "tools.comprehensive_validator._test_database_performance": {
      "calls": [
        "cursor.execute",
        "sqlite3.connect",
        "conn.close",
        "cursor.fetchone",
        "conn.cursor",
        "time.time"
      ],
      "decorators": [],
      "docstring": "Test database performance with simple queries.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 352,
      "line_start": 329,
      "module": "tools.comprehensive_validator",
      "name": "_test_database_performance",
      "signature": "def _test_database_performance(self, db_path: str):"
    },
    "tools.comprehensive_validator._test_database_schema": {
      "calls": [
        "cursor.execute",
        "sqlite3.connect",
        "set",
        "conn.close",
        "len",
        "list",
        "conn.cursor",
        "cursor.fetchall"
      ],
      "decorators": [],
      "docstring": "Test database schema against expected tables.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 327,
      "line_start": 296,
      "module": "tools.comprehensive_validator",
      "name": "_test_database_schema",
      "signature": "def _test_database_schema(self, db_path: str):"
    },
    "tools.comprehensive_validator._test_disk_space": {
      "calls": [
        "psutil.disk_usage",
        "str"
      ],
      "decorators": [],
      "docstring": "Test available disk space.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 458,
      "line_start": 431,
      "module": "tools.comprehensive_validator",
      "name": "_test_disk_space",
      "signature": "def _test_disk_space(self):"
    },
    "tools.comprehensive_validator._test_endpoint": {
      "calls": [
        "str",
        "requests.request"
      ],
      "decorators": [],
      "docstring": "Test a single API endpoint.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 213,
      "line_start": 187,
      "module": "tools.comprehensive_validator",
      "name": "_test_endpoint",
      "signature": "def _test_endpoint(self, method: str, url: str, auth_required: bool):"
    },
    "tools.comprehensive_validator._test_file_permissions": {
      "calls": [
        "Path",
        "test_dir.mkdir",
        "test_file.unlink",
        "str",
        "test_file.write_text",
        "test_file.read_text"
      ],
      "decorators": [],
      "docstring": "Test file system permissions.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 429,
      "line_start": 403,
      "module": "tools.comprehensive_validator",
      "name": "_test_file_permissions",
      "signature": "def _test_file_permissions(self):"
    },
    "tools.comprehensive_validator._test_system_resources": {
      "calls": [
        "join",
        "psutil.pids",
        "len",
        "str",
        "psutil.cpu_percent",
        "issues.append",
        "psutil.virtual_memory"
      ],
      "decorators": [],
      "docstring": "Test system resource availability.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 722,
      "line_start": 688,
      "module": "tools.comprehensive_validator",
      "name": "_test_system_resources",
      "signature": "def _test_system_resources(self):"
    },
    "tools.comprehensive_validator._time_test": {
      "calls": [
        "time.time",
        "str",
        "func"
      ],
      "decorators": [],
      "docstring": "Execute a test function and measure duration.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 134,
      "line_start": 125,
      "module": "tools.comprehensive_validator",
      "name": "_time_test",
      "signature": "def _time_test(self, func, *args, **kwargs):"
    },
    "tools.comprehensive_validator.main": {
      "calls": [
        "join",
        "logging.getLogger",
        "print",
        "validator.run_comprehensive_validation",
        "setLevel",
        "sys.exit",
        "argparse.ArgumentParser",
        "ComprehensiveValidator",
        "validator.save_report",
        "parser.add_argument",
        "component_map.get",
        "parser.parse_args"
      ],
      "decorators": [],
      "docstring": "Main entry point.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 975,
      "line_start": 910,
      "module": "tools.comprehensive_validator",
      "name": "main",
      "signature": "async def main():"
    },
    "tools.comprehensive_validator.run_comprehensive_validation": {
      "calls": [
        "self.validate_performance",
        "ComponentStatus",
        "self._generate_recommendations",
        "logger.warning",
        "len",
        "traceback.format_exc",
        "sum",
        "datetime.utcnow",
        "logger.info",
        "self.inventory.get",
        "self.validate_file_system",
        "time.time",
        "self.validate_configuration",
        "self.validate_backup_system",
        "component_statuses.append",
        "str",
        "self.validate_api_endpoints",
        "logger.error",
        "self.validate_security",
        "asdict",
        "self.validate_database",
        "isoformat"
      ],
      "decorators": [],
      "docstring": "Run comprehensive validation of all or specified components.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 871,
      "line_start": 769,
      "module": "tools.comprehensive_validator",
      "name": "run_comprehensive_validation",
      "signature": "async def run_comprehensive_validation(self, components: Optional[List[str]] = None) -> Dict:"
    },
    "tools.comprehensive_validator.save_report": {
      "calls": [
        "Path",
        "open",
        "logger.info",
        "strftime",
        "datetime.utcnow",
        "report_path.parent.mkdir",
        "json.dump"
      ],
      "decorators": [],
      "docstring": "Save validation report to file.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 908,
      "line_start": 895,
      "module": "tools.comprehensive_validator",
      "name": "save_report",
      "signature": "def save_report(self, report: Dict, filename: Optional[str] = None):"
    },
    "tools.comprehensive_validator.validate_api_endpoints": {
      "calls": [
        "self._time_test",
        "replace",
        "logger.info",
        "self.inventory.get",
        "self.config.get",
        "time.time",
        "self._record_result",
        "endpoint.get",
        "path.replace",
        "self._get_component_status",
        "requests.get"
      ],
      "decorators": [],
      "docstring": "Test all documented API endpoints.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 185,
      "line_start": 136,
      "module": "tools.comprehensive_validator",
      "name": "validate_api_endpoints",
      "signature": "async def validate_api_endpoints(self) -> ComponentStatus:"
    },
    "tools.comprehensive_validator.validate_backup_system": {
      "calls": [
        "Path",
        "self._time_test",
        "exists",
        "logger.info",
        "self.config.get",
        "time.time",
        "self._record_result",
        "self._get_component_status",
        "backup_dir.replace"
      ],
      "decorators": [],
      "docstring": "Test backup system functionality.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 624,
      "line_start": 592,
      "module": "tools.comprehensive_validator",
      "name": "validate_backup_system",
      "signature": "def validate_backup_system(self) -> ComponentStatus:"
    },
    "tools.comprehensive_validator.validate_configuration": {
      "calls": [
        "Path",
        "self._time_test",
        "exists",
        "logger.info",
        "time.time",
        "self._record_result",
        "self._get_component_status"
      ],
      "decorators": [],
      "docstring": "Test configuration validity and completeness.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 496,
      "line_start": 460,
      "module": "tools.comprehensive_validator",
      "name": "validate_configuration",
      "signature": "def validate_configuration(self) -> ComponentStatus:"
    },
    "tools.comprehensive_validator.validate_database": {
      "calls": [
        "Path",
        "self._time_test",
        "Path.cwd",
        "db_url.startswith",
        "db_path.startswith",
        "logger.info",
        "str",
        "self.config.get",
        "time.time",
        "db_path.exists",
        "self._record_result",
        "self._get_component_status",
        "db_url.replace"
      ],
      "decorators": [],
      "docstring": "Test database integrity and operations.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 272,
      "line_start": 215,
      "module": "tools.comprehensive_validator",
      "name": "validate_database",
      "signature": "def validate_database(self) -> ComponentStatus:"
    },
    "tools.comprehensive_validator.validate_file_system": {
      "calls": [
        "Path",
        "self._time_test",
        "dir_path.exists",
        "dir_path.is_dir",
        "logger.info",
        "time.time",
        "self._record_result",
        "self._get_component_status"
      ],
      "decorators": [],
      "docstring": "Test file system components and permissions.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 401,
      "line_start": 354,
      "module": "tools.comprehensive_validator",
      "name": "validate_file_system",
      "signature": "def validate_file_system(self) -> ComponentStatus:"
    },
    "tools.comprehensive_validator.validate_performance": {
      "calls": [
        "self._time_test",
        "endpoint.split",
        "logger.info",
        "self.config.get",
        "time.time",
        "self._record_result",
        "self._get_component_status",
        "requests.get"
      ],
      "decorators": [],
      "docstring": "Test performance monitoring and metrics.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 686,
      "line_start": 652,
      "module": "tools.comprehensive_validator",
      "name": "validate_performance",
      "signature": "def validate_performance(self) -> ComponentStatus:"
    },
    "tools.comprehensive_validator.validate_security": {
      "calls": [
        "self._time_test",
        "len",
        "logger.info",
        "self.config.get",
        "time.time",
        "self._record_result",
        "self._get_component_status"
      ],
      "decorators": [],
      "docstring": "Test security features and configurations.",
      "file_path": "tools/comprehensive_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 567,
      "line_start": 528,
      "module": "tools.comprehensive_validator",
      "name": "validate_security",
      "signature": "def validate_security(self) -> ComponentStatus:"
    },
    "tools.function_validator.FunctionValidator.__init__": {
      "calls": [
        "self._load_inventory"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "tools/function_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 50,
      "line_start": 47,
      "module": "tools.function_validator",
      "name": "FunctionValidator.__init__",
      "signature": "def __init__(self):"
    },
    "tools.function_validator.FunctionValidator._get_function_from_module": {
      "calls": [
        "getattr",
        "function_name.split"
      ],
      "decorators": [],
      "docstring": "Get a function from a module, handling nested attributes.",
      "file_path": "tools/function_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 101,
      "line_start": 86,
      "module": "tools.function_validator",
      "name": "FunctionValidator._get_function_from_module",
      "signature": "def _get_function_from_module(self, module: Any, function_name: str) -> Optional[Callable]:"
    },
    "tools.function_validator.FunctionValidator._load_inventory": {
      "calls": [
        "Path",
        "json.load",
        "open",
        "sys.exit",
        "logger.error",
        "inventory_path.exists"
      ],
      "decorators": [],
      "docstring": "Load the system inventory.",
      "file_path": "tools/function_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 60,
      "line_start": 52,
      "module": "tools.function_validator",
      "name": "FunctionValidator._load_inventory",
      "signature": "def _load_inventory(self) -> Dict:"
    },
    "tools.function_validator.FunctionValidator._safe_import_module": {
      "calls": [
        "logger.debug",
        "importlib.import_module",
        "module_name.startswith"
      ],
      "decorators": [],
      "docstring": "Safely import a module, handling errors gracefully.",
      "file_path": "tools/function_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 84,
      "line_start": 62,
      "module": "tools.function_validator",
      "name": "FunctionValidator._safe_import_module",
      "signature": "def _safe_import_module(self, module_name: str) -> Optional[Any]:"
    },
    "tools.function_validator.FunctionValidator._validate_function_signature": {
      "calls": [
        "join",
        "len",
        "actual_sig.parameters.values",
        "inspect.signature",
        "list",
        "str",
        "actual_sig_str.startswith"
      ],
      "decorators": [],
      "docstring": "Validate function signature matches documentation.",
      "file_path": "tools/function_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 118,
      "line_start": 103,
      "module": "tools.function_validator",
      "name": "FunctionValidator._validate_function_signature",
      "signature": "def _validate_function_signature(self, func: Callable, expected_signature: str) -> bool:"
    },
    "tools.function_validator.FunctionValidator.save_report": {
      "calls": [
        "Path",
        "time.strftime",
        "open",
        "logger.info",
        "time.gmtime",
        "report_path.parent.mkdir",
        "json.dump"
      ],
      "decorators": [],
      "docstring": "Save validation report.",
      "file_path": "tools/function_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 388,
      "line_start": 375,
      "module": "tools.function_validator",
      "name": "FunctionValidator.save_report",
      "signature": "def save_report(self, report: Dict, filename: Optional[str] = None):"
    },
    "tools.function_validator.FunctionValidator.test_all_modules": {
      "calls": [
        "module_results.append",
        "len",
        "time.strftime",
        "logger.info",
        "self.inventory.get",
        "str",
        "modules.keys",
        "sum",
        "logger.error",
        "self.test_module",
        "time.gmtime"
      ],
      "decorators": [],
      "docstring": "Test all modules in the inventory.",
      "file_path": "tools/function_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 373,
      "line_start": 282,
      "module": "tools.function_validator",
      "name": "FunctionValidator.test_all_modules",
      "signature": "def test_all_modules(self) -> Dict[str, Any]:"
    },
    "tools.function_validator.FunctionValidator.test_function": {
      "calls": [
        "inspect.getsourcelines",
        "inspect.isbuiltin",
        "hasattr",
        "callable",
        "self._safe_import_module",
        "self._validate_function_signature",
        "function_info.get",
        "str",
        "inspect.ismethod",
        "inspect.getfile",
        "time.time",
        "FunctionTest",
        "inspect.getdoc",
        "self._get_function_from_module",
        "inspect.isfunction"
      ],
      "decorators": [],
      "docstring": "Test a single function.",
      "file_path": "tools/function_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 216,
      "line_start": 120,
      "module": "tools.function_validator",
      "name": "FunctionValidator.test_function",
      "signature": "def test_function(self, module_name: str, function_name: str, function_info: Dict) -> FunctionTest:"
    },
    "tools.function_validator.FunctionValidator.test_module": {
      "calls": [
        "module_results.append",
        "get",
        "logger.warning",
        "len",
        "self.results.append",
        "all_functions.get",
        "logger.info",
        "self.inventory.get",
        "module_info.get",
        "self.test_function"
      ],
      "decorators": [],
      "docstring": "Test all functions in a module.",
      "file_path": "tools/function_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 280,
      "line_start": 218,
      "module": "tools.function_validator",
      "name": "FunctionValidator.test_module",
      "signature": "def test_module(self, module_name: str) -> Dict[str, Any]:"
    },
    "tools.function_validator.__init__": {
      "calls": [
        "self._load_inventory"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "tools/function_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 50,
      "line_start": 47,
      "module": "tools.function_validator",
      "name": "__init__",
      "signature": "def __init__(self):"
    },
    "tools.function_validator._get_function_from_module": {
      "calls": [
        "getattr",
        "function_name.split"
      ],
      "decorators": [],
      "docstring": "Get a function from a module, handling nested attributes.",
      "file_path": "tools/function_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 101,
      "line_start": 86,
      "module": "tools.function_validator",
      "name": "_get_function_from_module",
      "signature": "def _get_function_from_module(self, module: Any, function_name: str) -> Optional[Callable]:"
    },
    "tools.function_validator._load_inventory": {
      "calls": [
        "Path",
        "json.load",
        "open",
        "sys.exit",
        "logger.error",
        "inventory_path.exists"
      ],
      "decorators": [],
      "docstring": "Load the system inventory.",
      "file_path": "tools/function_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 60,
      "line_start": 52,
      "module": "tools.function_validator",
      "name": "_load_inventory",
      "signature": "def _load_inventory(self) -> Dict:"
    },
    "tools.function_validator._safe_import_module": {
      "calls": [
        "logger.debug",
        "importlib.import_module",
        "module_name.startswith"
      ],
      "decorators": [],
      "docstring": "Safely import a module, handling errors gracefully.",
      "file_path": "tools/function_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 84,
      "line_start": 62,
      "module": "tools.function_validator",
      "name": "_safe_import_module",
      "signature": "def _safe_import_module(self, module_name: str) -> Optional[Any]:"
    },
    "tools.function_validator._validate_function_signature": {
      "calls": [
        "join",
        "len",
        "actual_sig.parameters.values",
        "inspect.signature",
        "list",
        "str",
        "actual_sig_str.startswith"
      ],
      "decorators": [],
      "docstring": "Validate function signature matches documentation.",
      "file_path": "tools/function_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 118,
      "line_start": 103,
      "module": "tools.function_validator",
      "name": "_validate_function_signature",
      "signature": "def _validate_function_signature(self, func: Callable, expected_signature: str) -> bool:"
    },
    "tools.function_validator.main": {
      "calls": [
        "join",
        "FunctionValidator",
        "get",
        "validator.test_module",
        "all_functions.get",
        "logging.getLogger",
        "validator.inventory.get",
        "validator.test_function",
        "print",
        "setLevel",
        "sys.exit",
        "argparse.ArgumentParser",
        "validator.test_all_modules",
        "validator.save_report",
        "parser.add_argument",
        "parser.parse_args"
      ],
      "decorators": [],
      "docstring": "Main entry point.",
      "file_path": "tools/function_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 473,
      "line_start": 390,
      "module": "tools.function_validator",
      "name": "main",
      "signature": "def main():"
    },
    "tools.function_validator.save_report": {
      "calls": [
        "Path",
        "time.strftime",
        "open",
        "logger.info",
        "time.gmtime",
        "report_path.parent.mkdir",
        "json.dump"
      ],
      "decorators": [],
      "docstring": "Save validation report.",
      "file_path": "tools/function_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 388,
      "line_start": 375,
      "module": "tools.function_validator",
      "name": "save_report",
      "signature": "def save_report(self, report: Dict, filename: Optional[str] = None):"
    },
    "tools.function_validator.test_all_modules": {
      "calls": [
        "module_results.append",
        "len",
        "time.strftime",
        "logger.info",
        "self.inventory.get",
        "str",
        "modules.keys",
        "sum",
        "logger.error",
        "self.test_module",
        "time.gmtime"
      ],
      "decorators": [],
      "docstring": "Test all modules in the inventory.",
      "file_path": "tools/function_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 373,
      "line_start": 282,
      "module": "tools.function_validator",
      "name": "test_all_modules",
      "signature": "def test_all_modules(self) -> Dict[str, Any]:"
    },
    "tools.function_validator.test_function": {
      "calls": [
        "inspect.getsourcelines",
        "inspect.isbuiltin",
        "hasattr",
        "callable",
        "self._safe_import_module",
        "self._validate_function_signature",
        "function_info.get",
        "str",
        "inspect.ismethod",
        "inspect.getfile",
        "time.time",
        "FunctionTest",
        "inspect.getdoc",
        "self._get_function_from_module",
        "inspect.isfunction"
      ],
      "decorators": [],
      "docstring": "Test a single function.",
      "file_path": "tools/function_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 216,
      "line_start": 120,
      "module": "tools.function_validator",
      "name": "test_function",
      "signature": "def test_function(self, module_name: str, function_name: str, function_info: Dict) -> FunctionTest:"
    },
    "tools.function_validator.test_module": {
      "calls": [
        "module_results.append",
        "get",
        "logger.warning",
        "len",
        "self.results.append",
        "all_functions.get",
        "logger.info",
        "self.inventory.get",
        "module_info.get",
        "self.test_function"
      ],
      "decorators": [],
      "docstring": "Test all functions in a module.",
      "file_path": "tools/function_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 280,
      "line_start": 218,
      "module": "tools.function_validator",
      "name": "test_module",
      "signature": "def test_module(self, module_name: str) -> Dict[str, Any]:"
    },
    "tools.integration_validator.IntegrationValidator.__init__": {
      "calls": [
        "self._load_inventory"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "tools/integration_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 74,
      "line_start": 67,
      "module": "tools.integration_validator",
      "name": "IntegrationValidator.__init__",
      "signature": "def __init__(self, base_url: str = \"http://localhost:8000\"):"
    },
    "tools.integration_validator.IntegrationValidator._authenticate": {
      "calls": [
        "self.session.headers.update",
        "data.get",
        "logger.warning",
        "response.json",
        "logger.info",
        "self.session.post",
        "logger.debug"
      ],
      "decorators": [],
      "docstring": "Authenticate and get session token.",
      "file_path": "tools/integration_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 129,
      "line_start": 106,
      "module": "tools.integration_validator",
      "name": "IntegrationValidator._authenticate",
      "signature": "async def _authenticate(self):"
    },
    "tools.integration_validator.IntegrationValidator._execute_flow_step": {
      "calls": [
        "step.get",
        "step_result.update",
        "self._validate_step",
        "self._test_websocket_step",
        "logger.info",
        "asyncio.sleep",
        "str",
        "time.time",
        "asdict",
        "self.test_endpoint"
      ],
      "decorators": [],
      "docstring": "Execute a single flow step.",
      "file_path": "tools/integration_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 423,
      "line_start": 368,
      "module": "tools.integration_validator",
      "name": "IntegrationValidator._execute_flow_step",
      "signature": "async def _execute_flow_step(self, step: Dict, step_number: int) -> Dict:"
    },
    "tools.integration_validator.IntegrationValidator._get_integration_flows": {
      "calls": [],
      "decorators": [],
      "docstring": "Define integration test flows.",
      "file_path": "tools/integration_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 626,
      "line_start": 535,
      "module": "tools.integration_validator",
      "name": "IntegrationValidator._get_integration_flows",
      "signature": "def _get_integration_flows(self) -> Dict[str, Dict]:"
    },
    "tools.integration_validator.IntegrationValidator._get_test_data_for_endpoint": {
      "calls": [],
      "decorators": [],
      "docstring": "Generate appropriate test data for an endpoint.",
      "file_path": "tools/integration_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 298,
      "line_start": 257,
      "module": "tools.integration_validator",
      "name": "IntegrationValidator._get_test_data_for_endpoint",
      "signature": "def _get_test_data_for_endpoint(self, endpoint: str, method: str) -> Dict:"
    },
    "tools.integration_validator.IntegrationValidator._load_inventory": {
      "calls": [
        "Path",
        "json.load",
        "open",
        "sys.exit",
        "logger.error",
        "inventory_path.exists"
      ],
      "decorators": [],
      "docstring": "Load the system inventory.",
      "file_path": "tools/integration_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 84,
      "line_start": 76,
      "module": "tools.integration_validator",
      "name": "IntegrationValidator._load_inventory",
      "signature": "def _load_inventory(self) -> Dict:"
    },
    "tools.integration_validator.IntegrationValidator._test_websocket_step": {
      "calls": [
        "step.get",
        "websocket.recv",
        "str",
        "asyncio.wait_for",
        "websockets.connect",
        "json.loads",
        "websocket.send",
        "json.dumps"
      ],
      "decorators": [],
      "docstring": "Test WebSocket connection.",
      "file_path": "tools/integration_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 456,
      "line_start": 425,
      "module": "tools.integration_validator",
      "name": "IntegrationValidator._test_websocket_step",
      "signature": "async def _test_websocket_step(self, step: Dict) -> Dict:"
    },
    "tools.integration_validator.IntegrationValidator._validate_database_state": {
      "calls": [
        "step.get",
        "stats.get",
        "response.json",
        "str",
        "self.session.get"
      ],
      "decorators": [],
      "docstring": "Validate database state.",
      "file_path": "tools/integration_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 503,
      "line_start": 472,
      "module": "tools.integration_validator",
      "name": "IntegrationValidator._validate_database_state",
      "signature": "async def _validate_database_state(self, step: Dict) -> Dict:"
    },
    "tools.integration_validator.IntegrationValidator._validate_file_state": {
      "calls": [
        "step.get",
        "exists",
        "Path",
        "str"
      ],
      "decorators": [],
      "docstring": "Validate file system state.",
      "file_path": "tools/integration_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 533,
      "line_start": 505,
      "module": "tools.integration_validator",
      "name": "IntegrationValidator._validate_file_state",
      "signature": "async def _validate_file_state(self, step: Dict) -> Dict:"
    },
    "tools.integration_validator.IntegrationValidator._validate_response_schema": {
      "calls": [
        "expected_schema.get"
      ],
      "decorators": [],
      "docstring": "Basic response schema validation.",
      "file_path": "tools/integration_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 311,
      "line_start": 300,
      "module": "tools.integration_validator",
      "name": "IntegrationValidator._validate_response_schema",
      "signature": "def _validate_response_schema(self, response_data: Dict, expected_schema: Dict) -> bool:"
    },
    "tools.integration_validator.IntegrationValidator._validate_step": {
      "calls": [
        "step.get",
        "self._validate_file_state",
        "self._validate_database_state"
      ],
      "decorators": [],
      "docstring": "Execute validation step.",
      "file_path": "tools/integration_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 470,
      "line_start": 458,
      "module": "tools.integration_validator",
      "name": "IntegrationValidator._validate_step",
      "signature": "async def _validate_step(self, step: Dict) -> Dict:"
    },
    "tools.integration_validator.IntegrationValidator.cleanup_session": {
      "calls": [
        "self.session.close",
        "self.websocket.close"
      ],
      "decorators": [],
      "docstring": "Clean up HTTP session.",
      "file_path": "tools/integration_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 136,
      "line_start": 131,
      "module": "tools.integration_validator",
      "name": "IntegrationValidator.cleanup_session",
      "signature": "async def cleanup_session(self):"
    },
    "tools.integration_validator.IntegrationValidator.run_comprehensive_test": {
      "calls": [
        "time.strftime",
        "logger.info",
        "asdict",
        "sum",
        "self.setup_session",
        "self.test_all_endpoints",
        "self.cleanup_session",
        "self.test_all_flows",
        "time.gmtime"
      ],
      "decorators": [],
      "docstring": "Run comprehensive integration testing.",
      "file_path": "tools/integration_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 794,
      "line_start": 730,
      "module": "tools.integration_validator",
      "name": "IntegrationValidator.run_comprehensive_test",
      "signature": "async def run_comprehensive_test(self) -> Dict[str, Any]:"
    },
    "tools.integration_validator.IntegrationValidator.save_report": {
      "calls": [
        "Path",
        "time.strftime",
        "open",
        "logger.info",
        "time.gmtime",
        "report_path.parent.mkdir",
        "json.dump"
      ],
      "decorators": [],
      "docstring": "Save integration test report.",
      "file_path": "tools/integration_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 809,
      "line_start": 796,
      "module": "tools.integration_validator",
      "name": "IntegrationValidator.save_report",
      "signature": "def save_report(self, report: Dict, filename: Optional[str] = None):"
    },
    "tools.integration_validator.IntegrationValidator.setup_session": {
      "calls": [
        "self._authenticate",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "logger.error",
        "self.session.get"
      ],
      "decorators": [],
      "docstring": "Initialize HTTP session and authentication.",
      "file_path": "tools/integration_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 104,
      "line_start": 86,
      "module": "tools.integration_validator",
      "name": "IntegrationValidator.setup_session",
      "signature": "async def setup_session(self):"
    },
    "tools.integration_validator.IntegrationValidator.test_all_endpoints": {
      "calls": [
        "endpoints.items",
        "endpoint_results.append",
        "len",
        "EndpointTest",
        "logger.info",
        "self.inventory.get",
        "str",
        "self.test_results.append",
        "sum",
        "logger.error",
        "asdict",
        "self.test_endpoint"
      ],
      "decorators": [],
      "docstring": "Test all documented API endpoints.",
      "file_path": "tools/integration_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 678,
      "line_start": 628,
      "module": "tools.integration_validator",
      "name": "IntegrationValidator.test_all_endpoints",
      "signature": "async def test_all_endpoints(self) -> Dict[str, Any]:"
    },
    "tools.integration_validator.IntegrationValidator.test_all_flows": {
      "calls": [
        "flow_results.append",
        "len",
        "self._get_integration_flows",
        "logger.info",
        "str",
        "FlowTest",
        "sum",
        "logger.error",
        "self.flow_results.append",
        "flows.items",
        "self.test_integration_flow",
        "asdict"
      ],
      "decorators": [],
      "docstring": "Test all integration flows.",
      "file_path": "tools/integration_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 728,
      "line_start": 680,
      "module": "tools.integration_validator",
      "name": "IntegrationValidator.test_all_flows",
      "signature": "async def test_all_flows(self) -> Dict[str, Any]:"
    },
    "tools.integration_validator.IntegrationValidator.test_endpoint": {
      "calls": [
        "self._validate_response_schema",
        "encode",
        "len",
        "response.text",
        "response.headers.get",
        "upper",
        "response.json",
        "self.session.request",
        "str",
        "test_data.get",
        "urljoin",
        "time.time",
        "self._get_test_data_for_endpoint",
        "isinstance",
        "startswith",
        "EndpointTest",
        "json.dumps",
        "endpoint_info.get"
      ],
      "decorators": [],
      "docstring": "Test a single API endpoint.",
      "file_path": "tools/integration_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 255,
      "line_start": 138,
      "module": "tools.integration_validator",
      "name": "IntegrationValidator.test_endpoint",
      "signature": "async def test_endpoint(self, endpoint_info: Dict) -> EndpointTest:"
    },
    "tools.integration_validator.IntegrationValidator.test_integration_flow": {
      "calls": [
        "step.get",
        "len",
        "self._execute_flow_step",
        "logger.info",
        "str",
        "FlowTest",
        "enumerate",
        "time.time",
        "step_results.append",
        "flow_config.get"
      ],
      "decorators": [],
      "docstring": "Test a complete integration flow.",
      "file_path": "tools/integration_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 366,
      "line_start": 313,
      "module": "tools.integration_validator",
      "name": "IntegrationValidator.test_integration_flow",
      "signature": "async def test_integration_flow(self, flow_name: str, flow_config: Dict) -> FlowTest:"
    },
    "tools.integration_validator.__init__": {
      "calls": [
        "self._load_inventory"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "tools/integration_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 74,
      "line_start": 67,
      "module": "tools.integration_validator",
      "name": "__init__",
      "signature": "def __init__(self, base_url: str = \"http://localhost:8000\"):"
    },
    "tools.integration_validator._authenticate": {
      "calls": [
        "self.session.headers.update",
        "data.get",
        "logger.warning",
        "response.json",
        "logger.info",
        "self.session.post",
        "logger.debug"
      ],
      "decorators": [],
      "docstring": "Authenticate and get session token.",
      "file_path": "tools/integration_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 129,
      "line_start": 106,
      "module": "tools.integration_validator",
      "name": "_authenticate",
      "signature": "async def _authenticate(self):"
    },
    "tools.integration_validator._execute_flow_step": {
      "calls": [
        "step.get",
        "step_result.update",
        "self._validate_step",
        "self._test_websocket_step",
        "logger.info",
        "asyncio.sleep",
        "str",
        "time.time",
        "asdict",
        "self.test_endpoint"
      ],
      "decorators": [],
      "docstring": "Execute a single flow step.",
      "file_path": "tools/integration_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 423,
      "line_start": 368,
      "module": "tools.integration_validator",
      "name": "_execute_flow_step",
      "signature": "async def _execute_flow_step(self, step: Dict, step_number: int) -> Dict:"
    },
    "tools.integration_validator._get_integration_flows": {
      "calls": [],
      "decorators": [],
      "docstring": "Define integration test flows.",
      "file_path": "tools/integration_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 626,
      "line_start": 535,
      "module": "tools.integration_validator",
      "name": "_get_integration_flows",
      "signature": "def _get_integration_flows(self) -> Dict[str, Dict]:"
    },
    "tools.integration_validator._get_test_data_for_endpoint": {
      "calls": [],
      "decorators": [],
      "docstring": "Generate appropriate test data for an endpoint.",
      "file_path": "tools/integration_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 298,
      "line_start": 257,
      "module": "tools.integration_validator",
      "name": "_get_test_data_for_endpoint",
      "signature": "def _get_test_data_for_endpoint(self, endpoint: str, method: str) -> Dict:"
    },
    "tools.integration_validator._load_inventory": {
      "calls": [
        "Path",
        "json.load",
        "open",
        "sys.exit",
        "logger.error",
        "inventory_path.exists"
      ],
      "decorators": [],
      "docstring": "Load the system inventory.",
      "file_path": "tools/integration_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 84,
      "line_start": 76,
      "module": "tools.integration_validator",
      "name": "_load_inventory",
      "signature": "def _load_inventory(self) -> Dict:"
    },
    "tools.integration_validator._test_websocket_step": {
      "calls": [
        "step.get",
        "websocket.recv",
        "str",
        "asyncio.wait_for",
        "websockets.connect",
        "json.loads",
        "websocket.send",
        "json.dumps"
      ],
      "decorators": [],
      "docstring": "Test WebSocket connection.",
      "file_path": "tools/integration_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 456,
      "line_start": 425,
      "module": "tools.integration_validator",
      "name": "_test_websocket_step",
      "signature": "async def _test_websocket_step(self, step: Dict) -> Dict:"
    },
    "tools.integration_validator._validate_database_state": {
      "calls": [
        "step.get",
        "stats.get",
        "response.json",
        "str",
        "self.session.get"
      ],
      "decorators": [],
      "docstring": "Validate database state.",
      "file_path": "tools/integration_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 503,
      "line_start": 472,
      "module": "tools.integration_validator",
      "name": "_validate_database_state",
      "signature": "async def _validate_database_state(self, step: Dict) -> Dict:"
    },
    "tools.integration_validator._validate_file_state": {
      "calls": [
        "step.get",
        "exists",
        "Path",
        "str"
      ],
      "decorators": [],
      "docstring": "Validate file system state.",
      "file_path": "tools/integration_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 533,
      "line_start": 505,
      "module": "tools.integration_validator",
      "name": "_validate_file_state",
      "signature": "async def _validate_file_state(self, step: Dict) -> Dict:"
    },
    "tools.integration_validator._validate_response_schema": {
      "calls": [
        "expected_schema.get"
      ],
      "decorators": [],
      "docstring": "Basic response schema validation.",
      "file_path": "tools/integration_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 311,
      "line_start": 300,
      "module": "tools.integration_validator",
      "name": "_validate_response_schema",
      "signature": "def _validate_response_schema(self, response_data: Dict, expected_schema: Dict) -> bool:"
    },
    "tools.integration_validator._validate_step": {
      "calls": [
        "step.get",
        "self._validate_file_state",
        "self._validate_database_state"
      ],
      "decorators": [],
      "docstring": "Execute validation step.",
      "file_path": "tools/integration_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 470,
      "line_start": 458,
      "module": "tools.integration_validator",
      "name": "_validate_step",
      "signature": "async def _validate_step(self, step: Dict) -> Dict:"
    },
    "tools.integration_validator.cleanup_session": {
      "calls": [
        "self.session.close",
        "self.websocket.close"
      ],
      "decorators": [],
      "docstring": "Clean up HTTP session.",
      "file_path": "tools/integration_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 136,
      "line_start": 131,
      "module": "tools.integration_validator",
      "name": "cleanup_session",
      "signature": "async def cleanup_session(self):"
    },
    "tools.integration_validator.main": {
      "calls": [
        "validator.cleanup_session",
        "setLevel",
        "IntegrationValidator",
        "flows.keys",
        "validator.setup_session",
        "validator.test_integration_flow",
        "print",
        "validator._get_integration_flows",
        "parser.parse_args",
        "validator.inventory.get",
        "sys.exit",
        "validator.test_endpoint",
        "validator.run_comprehensive_test",
        "argparse.ArgumentParser",
        "join",
        "get",
        "logging.getLogger",
        "validator.save_report",
        "parser.add_argument"
      ],
      "decorators": [],
      "docstring": "Main entry point.",
      "file_path": "tools/integration_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 915,
      "line_start": 811,
      "module": "tools.integration_validator",
      "name": "main",
      "signature": "async def main():"
    },
    "tools.integration_validator.run_comprehensive_test": {
      "calls": [
        "time.strftime",
        "logger.info",
        "asdict",
        "sum",
        "self.setup_session",
        "self.test_all_endpoints",
        "self.cleanup_session",
        "self.test_all_flows",
        "time.gmtime"
      ],
      "decorators": [],
      "docstring": "Run comprehensive integration testing.",
      "file_path": "tools/integration_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 794,
      "line_start": 730,
      "module": "tools.integration_validator",
      "name": "run_comprehensive_test",
      "signature": "async def run_comprehensive_test(self) -> Dict[str, Any]:"
    },
    "tools.integration_validator.save_report": {
      "calls": [
        "Path",
        "time.strftime",
        "open",
        "logger.info",
        "time.gmtime",
        "report_path.parent.mkdir",
        "json.dump"
      ],
      "decorators": [],
      "docstring": "Save integration test report.",
      "file_path": "tools/integration_validator.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 809,
      "line_start": 796,
      "module": "tools.integration_validator",
      "name": "save_report",
      "signature": "def save_report(self, report: Dict, filename: Optional[str] = None):"
    },
    "tools.integration_validator.setup_session": {
      "calls": [
        "self._authenticate",
        "aiohttp.ClientSession",
        "aiohttp.ClientTimeout",
        "logger.error",
        "self.session.get"
      ],
      "decorators": [],
      "docstring": "Initialize HTTP session and authentication.",
      "file_path": "tools/integration_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 104,
      "line_start": 86,
      "module": "tools.integration_validator",
      "name": "setup_session",
      "signature": "async def setup_session(self):"
    },
    "tools.integration_validator.test_all_endpoints": {
      "calls": [
        "endpoints.items",
        "endpoint_results.append",
        "len",
        "EndpointTest",
        "logger.info",
        "self.inventory.get",
        "str",
        "self.test_results.append",
        "sum",
        "logger.error",
        "asdict",
        "self.test_endpoint"
      ],
      "decorators": [],
      "docstring": "Test all documented API endpoints.",
      "file_path": "tools/integration_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 678,
      "line_start": 628,
      "module": "tools.integration_validator",
      "name": "test_all_endpoints",
      "signature": "async def test_all_endpoints(self) -> Dict[str, Any]:"
    },
    "tools.integration_validator.test_all_flows": {
      "calls": [
        "flow_results.append",
        "len",
        "self._get_integration_flows",
        "logger.info",
        "str",
        "FlowTest",
        "sum",
        "logger.error",
        "self.flow_results.append",
        "flows.items",
        "self.test_integration_flow",
        "asdict"
      ],
      "decorators": [],
      "docstring": "Test all integration flows.",
      "file_path": "tools/integration_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 728,
      "line_start": 680,
      "module": "tools.integration_validator",
      "name": "test_all_flows",
      "signature": "async def test_all_flows(self) -> Dict[str, Any]:"
    },
    "tools.integration_validator.test_endpoint": {
      "calls": [
        "self._validate_response_schema",
        "encode",
        "len",
        "response.text",
        "response.headers.get",
        "upper",
        "response.json",
        "self.session.request",
        "str",
        "test_data.get",
        "urljoin",
        "time.time",
        "self._get_test_data_for_endpoint",
        "isinstance",
        "startswith",
        "EndpointTest",
        "json.dumps",
        "endpoint_info.get"
      ],
      "decorators": [],
      "docstring": "Test a single API endpoint.",
      "file_path": "tools/integration_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 255,
      "line_start": 138,
      "module": "tools.integration_validator",
      "name": "test_endpoint",
      "signature": "async def test_endpoint(self, endpoint_info: Dict) -> EndpointTest:"
    },
    "tools.integration_validator.test_integration_flow": {
      "calls": [
        "step.get",
        "len",
        "self._execute_flow_step",
        "logger.info",
        "str",
        "FlowTest",
        "enumerate",
        "time.time",
        "step_results.append",
        "flow_config.get"
      ],
      "decorators": [],
      "docstring": "Test a complete integration flow.",
      "file_path": "tools/integration_validator.py",
      "is_async": true,
      "is_endpoint": false,
      "line_end": 366,
      "line_start": 313,
      "module": "tools.integration_validator",
      "name": "test_integration_flow",
      "signature": "async def test_integration_flow(self, flow_name: str, flow_config: Dict) -> FlowTest:"
    },
    "tools.repo_inventory.RepositoryInventoryScanner.__init__": {
      "calls": [
        "Path"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "tools/repo_inventory.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 108,
      "line_start": 94,
      "module": "tools.repo_inventory",
      "name": "RepositoryInventoryScanner.__init__",
      "signature": "def __init__(self, repo_root: str):"
    },
    "tools.repo_inventory.RepositoryInventoryScanner._analyze_external_services": {
      "calls": [],
      "decorators": [],
      "docstring": "Analyze external service integrations",
      "file_path": "tools/repo_inventory.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 405,
      "line_start": 402,
      "module": "tools.repo_inventory",
      "name": "RepositoryInventoryScanner._analyze_external_services",
      "signature": "def _analyze_external_services(self):"
    },
    "tools.repo_inventory.RepositoryInventoryScanner._build_function_signature": {
      "calls": [
        "join",
        "line.strip",
        "len",
        "min",
        "rstrip",
        "endswith",
        "range"
      ],
      "decorators": [],
      "docstring": "Build function signature string",
      "file_path": "tools/repo_inventory.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 434,
      "line_start": 418,
      "module": "tools.repo_inventory",
      "name": "RepositoryInventoryScanner._build_function_signature",
      "signature": "def _build_function_signature(self, node: ast.FunctionDef, lines: List[str]) -> str:"
    },
    "tools.repo_inventory.RepositoryInventoryScanner._detect_data_stores": {
      "calls": [
        "self.config_vars.values",
        "any",
        "var.default_value.lower",
        "list",
        "str",
        "DataStore",
        "self.repo_root.rglob",
        "self.data_stores.append",
        "db_file.relative_to"
      ],
      "decorators": [],
      "docstring": "Detect data stores based on file patterns and imports",
      "file_path": "tools/repo_inventory.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 400,
      "line_start": 378,
      "module": "tools.repo_inventory",
      "name": "RepositoryInventoryScanner._detect_data_stores",
      "signature": "def _detect_data_stores(self):"
    },
    "tools.repo_inventory.RepositoryInventoryScanner._extract_api_endpoint": {
      "calls": [
        "self.api_endpoints.append",
        "any",
        "decorator.attr.upper",
        "str",
        "isinstance",
        "parameters.append",
        "decorator.func.attr.upper",
        "APIEndpoint"
      ],
      "decorators": [],
      "docstring": "Extract API endpoint details from decorated function",
      "file_path": "tools/repo_inventory.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 313,
      "line_start": 263,
      "module": "tools.repo_inventory",
      "name": "RepositoryInventoryScanner._extract_api_endpoint",
      "signature": "def _extract_api_endpoint(self, node: ast.FunctionDef, decorators: List[str], func_info: FunctionInfo):"
    },
    "tools.repo_inventory.RepositoryInventoryScanner._extract_function_info": {
      "calls": [
        "calls.append",
        "file_path.relative_to",
        "any",
        "set",
        "FunctionInfo",
        "self._get_attr_name",
        "ast.walk",
        "ast.get_docstring",
        "str",
        "list",
        "self._extract_api_endpoint",
        "isinstance",
        "decorators.append",
        "self._build_function_signature",
        "dec.lower"
      ],
      "decorators": [],
      "docstring": "Extract detailed function information",
      "file_path": "tools/repo_inventory.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 261,
      "line_start": 201,
      "module": "tools.repo_inventory",
      "name": "RepositoryInventoryScanner._extract_function_info",
      "signature": "def _extract_function_info(self, node: ast.FunctionDef, file_path: Path, lines: List[str], module_name: str, class_name: Optional[str] = None):"
    },
    "tools.repo_inventory.RepositoryInventoryScanner._get_attr_name": {
      "calls": [
        "join",
        "isinstance",
        "reversed",
        "parts.append"
      ],
      "decorators": [],
      "docstring": "Get full attribute name like 'obj.method'",
      "file_path": "tools/repo_inventory.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 416,
      "line_start": 407,
      "module": "tools.repo_inventory",
      "name": "RepositoryInventoryScanner._get_attr_name",
      "signature": "def _get_attr_name(self, node: ast.Attribute) -> str:"
    },
    "tools.repo_inventory.RepositoryInventoryScanner._parse_config_file": {
      "calls": [
        "line.strip",
        "file_path.relative_to",
        "open",
        "line.startswith",
        "f.read",
        "print",
        "str",
        "enumerate",
        "ConfigVar",
        "line.split",
        "content.split",
        "file_path.name.startswith"
      ],
      "decorators": [],
      "docstring": "Parse configuration file for variables",
      "file_path": "tools/repo_inventory.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 376,
      "line_start": 352,
      "module": "tools.repo_inventory",
      "name": "RepositoryInventoryScanner._parse_config_file",
      "signature": "def _parse_config_file(self, file_path: Path):"
    },
    "tools.repo_inventory.RepositoryInventoryScanner._scan_config_files": {
      "calls": [
        "config_path.exists",
        "self._parse_config_file"
      ],
      "decorators": [],
      "docstring": "Scan configuration files for environment variables and settings",
      "file_path": "tools/repo_inventory.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 350,
      "line_start": 340,
      "module": "tools.repo_inventory",
      "name": "RepositoryInventoryScanner._scan_config_files",
      "signature": "def _scan_config_files(self):"
    },
    "tools.repo_inventory.RepositoryInventoryScanner._scan_javascript_file": {
      "calls": [
        "open",
        "re.findall",
        "f.read",
        "print"
      ],
      "decorators": [],
      "docstring": "Basic scanning of JavaScript/TypeScript files for API calls",
      "file_path": "tools/repo_inventory.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 338,
      "line_start": 315,
      "module": "tools.repo_inventory",
      "name": "RepositoryInventoryScanner._scan_javascript_file",
      "signature": "def _scan_javascript_file(self, file_path: Path):"
    },
    "tools.repo_inventory.RepositoryInventoryScanner._scan_python_file": {
      "calls": [
        "self._extract_function_info",
        "module_info.imports.append",
        "file_path.relative_to",
        "replace",
        "len",
        "ast.walk",
        "open",
        "ast.get_docstring",
        "f.read",
        "ModuleInfo",
        "print",
        "str",
        "module_info.classes.append",
        "isinstance",
        "module_info.functions.append",
        "content.split",
        "ast.parse"
      ],
      "decorators": [],
      "docstring": "Scan a Python file for functions, classes, and APIs",
      "file_path": "tools/repo_inventory.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 199,
      "line_start": 150,
      "module": "tools.repo_inventory",
      "name": "RepositoryInventoryScanner._scan_python_file",
      "signature": "def _scan_python_file(self, file_path: Path):"
    },
    "tools.repo_inventory.RepositoryInventoryScanner._should_skip_file": {
      "calls": [
        "file_path.relative_to",
        "any",
        "str"
      ],
      "decorators": [],
      "docstring": "Check if file should be skipped based on patterns",
      "file_path": "tools/repo_inventory.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 148,
      "line_start": 145,
      "module": "tools.repo_inventory",
      "name": "RepositoryInventoryScanner._should_skip_file",
      "signature": "def _should_skip_file(self, file_path: Path) -> bool:"
    },
    "tools.repo_inventory.RepositoryInventoryScanner.generate_inventory": {
      "calls": [
        "self.functions.items",
        "self.config_vars.items",
        "len",
        "str",
        "self.modules.items",
        "asdict"
      ],
      "decorators": [],
      "docstring": "Generate the complete inventory data structure",
      "file_path": "tools/repo_inventory.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 458,
      "line_start": 436,
      "module": "tools.repo_inventory",
      "name": "RepositoryInventoryScanner.generate_inventory",
      "signature": "def generate_inventory(self) -> Dict[str, Any]:"
    },
    "tools.repo_inventory.RepositoryInventoryScanner.scan_repository": {
      "calls": [
        "self._scan_python_file",
        "self._scan_config_files",
        "len",
        "self._analyze_external_services",
        "print",
        "list",
        "self._detect_data_stores",
        "self.repo_root.rglob",
        "self._scan_javascript_file",
        "self._should_skip_file"
      ],
      "decorators": [],
      "docstring": "Main entry point for repository scanning",
      "file_path": "tools/repo_inventory.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 143,
      "line_start": 110,
      "module": "tools.repo_inventory",
      "name": "RepositoryInventoryScanner.scan_repository",
      "signature": "def scan_repository(self):"
    },
    "tools.repo_inventory.__init__": {
      "calls": [
        "Path"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "tools/repo_inventory.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 108,
      "line_start": 94,
      "module": "tools.repo_inventory",
      "name": "__init__",
      "signature": "def __init__(self, repo_root: str):"
    },
    "tools.repo_inventory._analyze_external_services": {
      "calls": [],
      "decorators": [],
      "docstring": "Analyze external service integrations",
      "file_path": "tools/repo_inventory.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 405,
      "line_start": 402,
      "module": "tools.repo_inventory",
      "name": "_analyze_external_services",
      "signature": "def _analyze_external_services(self):"
    },
    "tools.repo_inventory._build_function_signature": {
      "calls": [
        "join",
        "line.strip",
        "len",
        "min",
        "rstrip",
        "endswith",
        "range"
      ],
      "decorators": [],
      "docstring": "Build function signature string",
      "file_path": "tools/repo_inventory.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 434,
      "line_start": 418,
      "module": "tools.repo_inventory",
      "name": "_build_function_signature",
      "signature": "def _build_function_signature(self, node: ast.FunctionDef, lines: List[str]) -> str:"
    },
    "tools.repo_inventory._detect_data_stores": {
      "calls": [
        "self.config_vars.values",
        "any",
        "var.default_value.lower",
        "list",
        "str",
        "DataStore",
        "self.repo_root.rglob",
        "self.data_stores.append",
        "db_file.relative_to"
      ],
      "decorators": [],
      "docstring": "Detect data stores based on file patterns and imports",
      "file_path": "tools/repo_inventory.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 400,
      "line_start": 378,
      "module": "tools.repo_inventory",
      "name": "_detect_data_stores",
      "signature": "def _detect_data_stores(self):"
    },
    "tools.repo_inventory._extract_api_endpoint": {
      "calls": [
        "self.api_endpoints.append",
        "any",
        "decorator.attr.upper",
        "str",
        "isinstance",
        "parameters.append",
        "decorator.func.attr.upper",
        "APIEndpoint"
      ],
      "decorators": [],
      "docstring": "Extract API endpoint details from decorated function",
      "file_path": "tools/repo_inventory.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 313,
      "line_start": 263,
      "module": "tools.repo_inventory",
      "name": "_extract_api_endpoint",
      "signature": "def _extract_api_endpoint(self, node: ast.FunctionDef, decorators: List[str], func_info: FunctionInfo):"
    },
    "tools.repo_inventory._extract_function_info": {
      "calls": [
        "calls.append",
        "file_path.relative_to",
        "any",
        "set",
        "FunctionInfo",
        "self._get_attr_name",
        "ast.walk",
        "ast.get_docstring",
        "str",
        "list",
        "self._extract_api_endpoint",
        "isinstance",
        "decorators.append",
        "self._build_function_signature",
        "dec.lower"
      ],
      "decorators": [],
      "docstring": "Extract detailed function information",
      "file_path": "tools/repo_inventory.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 261,
      "line_start": 201,
      "module": "tools.repo_inventory",
      "name": "_extract_function_info",
      "signature": "def _extract_function_info(self, node: ast.FunctionDef, file_path: Path, lines: List[str], module_name: str, class_name: Optional[str] = None):"
    },
    "tools.repo_inventory._get_attr_name": {
      "calls": [
        "join",
        "isinstance",
        "reversed",
        "parts.append"
      ],
      "decorators": [],
      "docstring": "Get full attribute name like 'obj.method'",
      "file_path": "tools/repo_inventory.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 416,
      "line_start": 407,
      "module": "tools.repo_inventory",
      "name": "_get_attr_name",
      "signature": "def _get_attr_name(self, node: ast.Attribute) -> str:"
    },
    "tools.repo_inventory._parse_config_file": {
      "calls": [
        "line.strip",
        "file_path.relative_to",
        "open",
        "line.startswith",
        "f.read",
        "print",
        "str",
        "enumerate",
        "ConfigVar",
        "line.split",
        "content.split",
        "file_path.name.startswith"
      ],
      "decorators": [],
      "docstring": "Parse configuration file for variables",
      "file_path": "tools/repo_inventory.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 376,
      "line_start": 352,
      "module": "tools.repo_inventory",
      "name": "_parse_config_file",
      "signature": "def _parse_config_file(self, file_path: Path):"
    },
    "tools.repo_inventory._scan_config_files": {
      "calls": [
        "config_path.exists",
        "self._parse_config_file"
      ],
      "decorators": [],
      "docstring": "Scan configuration files for environment variables and settings",
      "file_path": "tools/repo_inventory.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 350,
      "line_start": 340,
      "module": "tools.repo_inventory",
      "name": "_scan_config_files",
      "signature": "def _scan_config_files(self):"
    },
    "tools.repo_inventory._scan_javascript_file": {
      "calls": [
        "open",
        "re.findall",
        "f.read",
        "print"
      ],
      "decorators": [],
      "docstring": "Basic scanning of JavaScript/TypeScript files for API calls",
      "file_path": "tools/repo_inventory.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 338,
      "line_start": 315,
      "module": "tools.repo_inventory",
      "name": "_scan_javascript_file",
      "signature": "def _scan_javascript_file(self, file_path: Path):"
    },
    "tools.repo_inventory._scan_python_file": {
      "calls": [
        "self._extract_function_info",
        "module_info.imports.append",
        "file_path.relative_to",
        "replace",
        "len",
        "ast.walk",
        "open",
        "ast.get_docstring",
        "f.read",
        "ModuleInfo",
        "print",
        "str",
        "module_info.classes.append",
        "isinstance",
        "module_info.functions.append",
        "content.split",
        "ast.parse"
      ],
      "decorators": [],
      "docstring": "Scan a Python file for functions, classes, and APIs",
      "file_path": "tools/repo_inventory.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 199,
      "line_start": 150,
      "module": "tools.repo_inventory",
      "name": "_scan_python_file",
      "signature": "def _scan_python_file(self, file_path: Path):"
    },
    "tools.repo_inventory._should_skip_file": {
      "calls": [
        "file_path.relative_to",
        "any",
        "str"
      ],
      "decorators": [],
      "docstring": "Check if file should be skipped based on patterns",
      "file_path": "tools/repo_inventory.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 148,
      "line_start": 145,
      "module": "tools.repo_inventory",
      "name": "_should_skip_file",
      "signature": "def _should_skip_file(self, file_path: Path) -> bool:"
    },
    "tools.repo_inventory.generate_inventory": {
      "calls": [
        "self.functions.items",
        "self.config_vars.items",
        "len",
        "str",
        "self.modules.items",
        "asdict"
      ],
      "decorators": [],
      "docstring": "Generate the complete inventory data structure",
      "file_path": "tools/repo_inventory.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 458,
      "line_start": 436,
      "module": "tools.repo_inventory",
      "name": "generate_inventory",
      "signature": "def generate_inventory(self) -> Dict[str, Any]:"
    },
    "tools.repo_inventory.main": {
      "calls": [
        "Path",
        "len",
        "open",
        "scanner.generate_inventory",
        "print",
        "str",
        "output_path.parent.mkdir",
        "RepositoryInventoryScanner",
        "scanner.scan_repository",
        "json.dump"
      ],
      "decorators": [],
      "docstring": "Main entry point",
      "file_path": "tools/repo_inventory.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 485,
      "line_start": 460,
      "module": "tools.repo_inventory",
      "name": "main",
      "signature": "def main():"
    },
    "tools.repo_inventory.scan_repository": {
      "calls": [
        "self._scan_python_file",
        "self._scan_config_files",
        "len",
        "self._analyze_external_services",
        "print",
        "list",
        "self._detect_data_stores",
        "self.repo_root.rglob",
        "self._scan_javascript_file",
        "self._should_skip_file"
      ],
      "decorators": [],
      "docstring": "Main entry point for repository scanning",
      "file_path": "tools/repo_inventory.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 143,
      "line_start": 110,
      "module": "tools.repo_inventory",
      "name": "scan_repository",
      "signature": "def scan_repository(self):"
    },
    "tools.update_architecture_docs.DocumentationUpdater.__init__": {
      "calls": [
        "Path",
        "self._load_inventory"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "tools/update_architecture_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 22,
      "line_start": 19,
      "module": "tools.update_architecture_docs",
      "name": "DocumentationUpdater.__init__",
      "signature": "def __init__(self, inventory_path: str = \"docs/architecture/INVENTORY.json\"):"
    },
    "tools.update_architecture_docs.DocumentationUpdater._find_test_file": {
      "calls": [
        "source.stem.replace",
        "Path",
        "exists",
        "tests_dir.exists"
      ],
      "decorators": [],
      "docstring": "Check if a corresponding test file exists for the given source file.",
      "file_path": "tools/update_architecture_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 225,
      "line_start": 199,
      "module": "tools.update_architecture_docs",
      "name": "DocumentationUpdater._find_test_file",
      "signature": "def _find_test_file(self, source_path: str) -> bool:"
    },
    "tools.update_architecture_docs.DocumentationUpdater._load_inventory": {
      "calls": [
        "open",
        "self.inventory_path.exists",
        "json.load",
        "FileNotFoundError"
      ],
      "decorators": [],
      "docstring": "Load the current inventory data.",
      "file_path": "tools/update_architecture_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 30,
      "line_start": 24,
      "module": "tools.update_architecture_docs",
      "name": "DocumentationUpdater._load_inventory",
      "signature": "def _load_inventory(self) -> Dict[str, Any]:"
    },
    "tools.update_architecture_docs.DocumentationUpdater.update_all_docs": {
      "calls": [
        "self.update_icd_md",
        "print",
        "self.update_traceability_md",
        "self.update_architecture_md"
      ],
      "decorators": [],
      "docstring": "Update all architecture documentation files.",
      "file_path": "tools/update_architecture_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 40,
      "line_start": 32,
      "module": "tools.update_architecture_docs",
      "name": "DocumentationUpdater.update_all_docs",
      "signature": "def update_all_docs(self):"
    },
    "tools.update_architecture_docs.DocumentationUpdater.update_architecture_md": {
      "calls": [
        "lines.insert",
        "stats_section.strip",
        "component_list.append",
        "len",
        "print",
        "module_info.get",
        "arch_file.exists",
        "content.split",
        "line.strip",
        "re.sub",
        "modules_dict.items",
        "chr",
        "self.inventory.get",
        "list",
        "arch_file.read_text",
        "stats.get",
        "join",
        "get",
        "component_section.strip",
        "enumerate",
        "startswith",
        "arch_file.write_text"
      ],
      "decorators": [],
      "docstring": "Update dynamic sections in ARCHITECTURE.md.",
      "file_path": "tools/update_architecture_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 107,
      "line_start": 42,
      "module": "tools.update_architecture_docs",
      "name": "DocumentationUpdater.update_architecture_md",
      "signature": "def update_architecture_md(self):"
    },
    "tools.update_architecture_docs.DocumentationUpdater.update_icd_md": {
      "calls": [
        "join",
        "line.strip",
        "re.sub",
        "lines.insert",
        "len",
        "chr",
        "icd_file.write_text",
        "self.inventory.get",
        "print",
        "endpoint_rows.append",
        "enumerate",
        "startswith",
        "endpoint.get",
        "content.split",
        "icd_file.read_text",
        "icd_file.exists",
        "endpoints_table.strip"
      ],
      "decorators": [],
      "docstring": "Update API endpoint specifications in ICD.md.",
      "file_path": "tools/update_architecture_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 156,
      "line_start": 109,
      "module": "tools.update_architecture_docs",
      "name": "DocumentationUpdater.update_icd_md",
      "signature": "def update_icd_md(self):"
    },
    "tools.update_architecture_docs.DocumentationUpdater.update_traceability_md": {
      "calls": [
        "join",
        "re.sub",
        "modules_dict.items",
        "len",
        "chr",
        "print",
        "self.inventory.get",
        "trace_file.exists",
        "coverage_table.strip",
        "module_info.get",
        "trace_file.read_text",
        "coverage_rows.append",
        "self._find_test_file",
        "trace_file.write_text"
      ],
      "decorators": [],
      "docstring": "Update code-to-test mappings in TRACEABILITY.md.",
      "file_path": "tools/update_architecture_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 197,
      "line_start": 158,
      "module": "tools.update_architecture_docs",
      "name": "DocumentationUpdater.update_traceability_md",
      "signature": "def update_traceability_md(self):"
    },
    "tools.update_architecture_docs.__init__": {
      "calls": [
        "Path",
        "self._load_inventory"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "tools/update_architecture_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 22,
      "line_start": 19,
      "module": "tools.update_architecture_docs",
      "name": "__init__",
      "signature": "def __init__(self, inventory_path: str = \"docs/architecture/INVENTORY.json\"):"
    },
    "tools.update_architecture_docs._find_test_file": {
      "calls": [
        "source.stem.replace",
        "Path",
        "exists",
        "tests_dir.exists"
      ],
      "decorators": [],
      "docstring": "Check if a corresponding test file exists for the given source file.",
      "file_path": "tools/update_architecture_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 225,
      "line_start": 199,
      "module": "tools.update_architecture_docs",
      "name": "_find_test_file",
      "signature": "def _find_test_file(self, source_path: str) -> bool:"
    },
    "tools.update_architecture_docs._load_inventory": {
      "calls": [
        "open",
        "self.inventory_path.exists",
        "json.load",
        "FileNotFoundError"
      ],
      "decorators": [],
      "docstring": "Load the current inventory data.",
      "file_path": "tools/update_architecture_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 30,
      "line_start": 24,
      "module": "tools.update_architecture_docs",
      "name": "_load_inventory",
      "signature": "def _load_inventory(self) -> Dict[str, Any]:"
    },
    "tools.update_architecture_docs.main": {
      "calls": [
        "sys.exit",
        "DocumentationUpdater",
        "print",
        "updater.update_all_docs"
      ],
      "decorators": [],
      "docstring": "Main entry point.",
      "file_path": "tools/update_architecture_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 234,
      "line_start": 227,
      "module": "tools.update_architecture_docs",
      "name": "main",
      "signature": "def main():"
    },
    "tools.update_architecture_docs.update_all_docs": {
      "calls": [
        "self.update_icd_md",
        "print",
        "self.update_traceability_md",
        "self.update_architecture_md"
      ],
      "decorators": [],
      "docstring": "Update all architecture documentation files.",
      "file_path": "tools/update_architecture_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 40,
      "line_start": 32,
      "module": "tools.update_architecture_docs",
      "name": "update_all_docs",
      "signature": "def update_all_docs(self):"
    },
    "tools.update_architecture_docs.update_architecture_md": {
      "calls": [
        "lines.insert",
        "stats_section.strip",
        "component_list.append",
        "len",
        "print",
        "module_info.get",
        "arch_file.exists",
        "content.split",
        "line.strip",
        "re.sub",
        "modules_dict.items",
        "chr",
        "self.inventory.get",
        "list",
        "arch_file.read_text",
        "stats.get",
        "join",
        "get",
        "component_section.strip",
        "enumerate",
        "startswith",
        "arch_file.write_text"
      ],
      "decorators": [],
      "docstring": "Update dynamic sections in ARCHITECTURE.md.",
      "file_path": "tools/update_architecture_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 107,
      "line_start": 42,
      "module": "tools.update_architecture_docs",
      "name": "update_architecture_md",
      "signature": "def update_architecture_md(self):"
    },
    "tools.update_architecture_docs.update_icd_md": {
      "calls": [
        "join",
        "line.strip",
        "re.sub",
        "lines.insert",
        "len",
        "chr",
        "icd_file.write_text",
        "self.inventory.get",
        "print",
        "endpoint_rows.append",
        "enumerate",
        "startswith",
        "endpoint.get",
        "content.split",
        "icd_file.read_text",
        "icd_file.exists",
        "endpoints_table.strip"
      ],
      "decorators": [],
      "docstring": "Update API endpoint specifications in ICD.md.",
      "file_path": "tools/update_architecture_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 156,
      "line_start": 109,
      "module": "tools.update_architecture_docs",
      "name": "update_icd_md",
      "signature": "def update_icd_md(self):"
    },
    "tools.update_architecture_docs.update_traceability_md": {
      "calls": [
        "join",
        "re.sub",
        "modules_dict.items",
        "len",
        "chr",
        "print",
        "self.inventory.get",
        "trace_file.exists",
        "coverage_table.strip",
        "module_info.get",
        "trace_file.read_text",
        "coverage_rows.append",
        "self._find_test_file",
        "trace_file.write_text"
      ],
      "decorators": [],
      "docstring": "Update code-to-test mappings in TRACEABILITY.md.",
      "file_path": "tools/update_architecture_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 197,
      "line_start": 158,
      "module": "tools.update_architecture_docs",
      "name": "update_traceability_md",
      "signature": "def update_traceability_md(self):"
    },
    "tools.validate_docs.DocumentationValidator.__init__": {
      "calls": [
        "Path"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "tools/validate_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 21,
      "line_start": 18,
      "module": "tools.validate_docs",
      "name": "DocumentationValidator.__init__",
      "signature": "def __init__(self):"
    },
    "tools.validate_docs.DocumentationValidator.validate_all": {
      "calls": [
        "self.validate_inventory",
        "self.validate_links",
        "len",
        "self.validate_markdown_files",
        "print",
        "self.validate_mermaid_syntax"
      ],
      "decorators": [],
      "docstring": "Validate all architecture documentation. Returns True if valid.",
      "file_path": "tools/validate_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 48,
      "line_start": 23,
      "module": "tools.validate_docs",
      "name": "DocumentationValidator.validate_all",
      "signature": "def validate_all(self) -> bool:"
    },
    "tools.validate_docs.DocumentationValidator.validate_inventory": {
      "calls": [
        "data.get",
        "json.load",
        "self.errors.append",
        "open",
        "metadata.get",
        "stats.get",
        "inventory_file.exists",
        "self.warnings.append"
      ],
      "decorators": [],
      "docstring": "Validate INVENTORY.json structure and content.",
      "file_path": "tools/validate_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 82,
      "line_start": 50,
      "module": "tools.validate_docs",
      "name": "DocumentationValidator.validate_inventory",
      "signature": "def validate_inventory(self):"
    },
    "tools.validate_docs.DocumentationValidator.validate_links": {
      "calls": [
        "md_file.read_text",
        "link_url.startswith",
        "resolve",
        "self.docs_dir.glob",
        "target_path.exists",
        "link_url.endswith",
        "re.findall",
        "self.errors.append",
        "self.warnings.append"
      ],
      "decorators": [],
      "docstring": "Validate internal links in markdown files.",
      "file_path": "tools/validate_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 129,
      "line_start": 110,
      "module": "tools.validate_docs",
      "name": "DocumentationValidator.validate_links",
      "signature": "def validate_links(self):"
    },
    "tools.validate_docs.DocumentationValidator.validate_markdown_files": {
      "calls": [
        "file_path.exists",
        "len",
        "content.strip",
        "file_path.read_text",
        "startswith",
        "self.errors.append",
        "self.warnings.append"
      ],
      "decorators": [],
      "docstring": "Validate markdown file structure and content.",
      "file_path": "tools/validate_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 108,
      "line_start": 84,
      "module": "tools.validate_docs",
      "name": "DocumentationValidator.validate_markdown_files",
      "signature": "def validate_markdown_files(self):"
    },
    "tools.validate_docs.DocumentationValidator.validate_mermaid_syntax": {
      "calls": [
        "md_file.read_text",
        "any",
        "self.docs_dir.glob",
        "enumerate",
        "block.strip",
        "block.count",
        "re.findall",
        "self.errors.append",
        "self.warnings.append"
      ],
      "decorators": [],
      "docstring": "Basic validation of Mermaid diagram syntax.",
      "file_path": "tools/validate_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 151,
      "line_start": 131,
      "module": "tools.validate_docs",
      "name": "DocumentationValidator.validate_mermaid_syntax",
      "signature": "def validate_mermaid_syntax(self):"
    },
    "tools.validate_docs.__init__": {
      "calls": [
        "Path"
      ],
      "decorators": [],
      "docstring": null,
      "file_path": "tools/validate_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 21,
      "line_start": 18,
      "module": "tools.validate_docs",
      "name": "__init__",
      "signature": "def __init__(self):"
    },
    "tools.validate_docs.main": {
      "calls": [
        "sys.exit",
        "DocumentationValidator",
        "validator.validate_all"
      ],
      "decorators": [],
      "docstring": "Main entry point.",
      "file_path": "tools/validate_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 160,
      "line_start": 153,
      "module": "tools.validate_docs",
      "name": "main",
      "signature": "def main():"
    },
    "tools.validate_docs.validate_all": {
      "calls": [
        "self.validate_inventory",
        "self.validate_links",
        "len",
        "self.validate_markdown_files",
        "print",
        "self.validate_mermaid_syntax"
      ],
      "decorators": [],
      "docstring": "Validate all architecture documentation. Returns True if valid.",
      "file_path": "tools/validate_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 48,
      "line_start": 23,
      "module": "tools.validate_docs",
      "name": "validate_all",
      "signature": "def validate_all(self) -> bool:"
    },
    "tools.validate_docs.validate_inventory": {
      "calls": [
        "data.get",
        "json.load",
        "self.errors.append",
        "open",
        "metadata.get",
        "stats.get",
        "inventory_file.exists",
        "self.warnings.append"
      ],
      "decorators": [],
      "docstring": "Validate INVENTORY.json structure and content.",
      "file_path": "tools/validate_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 82,
      "line_start": 50,
      "module": "tools.validate_docs",
      "name": "validate_inventory",
      "signature": "def validate_inventory(self):"
    },
    "tools.validate_docs.validate_links": {
      "calls": [
        "md_file.read_text",
        "link_url.startswith",
        "resolve",
        "self.docs_dir.glob",
        "target_path.exists",
        "link_url.endswith",
        "re.findall",
        "self.errors.append",
        "self.warnings.append"
      ],
      "decorators": [],
      "docstring": "Validate internal links in markdown files.",
      "file_path": "tools/validate_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 129,
      "line_start": 110,
      "module": "tools.validate_docs",
      "name": "validate_links",
      "signature": "def validate_links(self):"
    },
    "tools.validate_docs.validate_markdown_files": {
      "calls": [
        "file_path.exists",
        "len",
        "content.strip",
        "file_path.read_text",
        "startswith",
        "self.errors.append",
        "self.warnings.append"
      ],
      "decorators": [],
      "docstring": "Validate markdown file structure and content.",
      "file_path": "tools/validate_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 108,
      "line_start": 84,
      "module": "tools.validate_docs",
      "name": "validate_markdown_files",
      "signature": "def validate_markdown_files(self):"
    },
    "tools.validate_docs.validate_mermaid_syntax": {
      "calls": [
        "md_file.read_text",
        "any",
        "self.docs_dir.glob",
        "enumerate",
        "block.strip",
        "block.count",
        "re.findall",
        "self.errors.append",
        "self.warnings.append"
      ],
      "decorators": [],
      "docstring": "Basic validation of Mermaid diagram syntax.",
      "file_path": "tools/validate_docs.py",
      "is_async": false,
      "is_endpoint": false,
      "line_end": 151,
      "line_start": 131,
      "module": "tools.validate_docs",
      "name": "validate_mermaid_syntax",
      "signature": "def validate_mermaid_syntax(self):"
    }
  },
  "metadata": {
    "generated_at": "2025-10-15T00:00:00Z",
    "repository_root": "/home/buymeagoat/dev/whisper-transcriber",
    "scan_version": "1.0"
  },
  "modules": {
    "api.main": {
      "classes": [],
      "docstring": null,
      "exports": [],
      "file_path": "api/main.py",
      "functions": [
        "log_startup_settings",
        "lifespan",
        "health_check",
        "version",
        "rehydrate_incomplete_jobs"
      ],
      "imports": [
        "os",
        "pathlib.Path",
        "contextlib.asynccontextmanager",
        "fastapi.FastAPI",
        "fastapi.middleware.cors.CORSMiddleware",
        "fastapi.responses.JSONResponse",
        "sqlalchemy.text",
        "api.utils.logger.get_system_logger",
        "api.exceptions.ConfigurationError",
        "api.exceptions.InitError",
        "api.orm_bootstrap.SessionLocal",
        "api.orm_bootstrap.validate_or_initialize_database",
        "api.models.Job",
        "api.models.JobStatusEnum",
        "api.services.users.ensure_default_admin",
        "api.utils.model_validation.validate_models_dir",
        "api.router_setup.register_routes",
        "api.middlewares.access_log.access_logger",
        "api.utils.db_lock.db_lock",
        "functools.partial",
        "api.settings.settings",
        "api.config_validator.validate_config",
        "api.paths.storage",
        "api.paths.UPLOAD_DIR",
        "api.paths.TRANSCRIPTS_DIR",
        "api.app_state",
        "api.app_state.handle_whisper",
        "api.app_state.LOCAL_TZ",
        "api.app_state.backend_log",
        "api.app_state.start_cleanup_thread",
        "api.app_state.stop_cleanup_thread",
        "api.app_state.check_celery_connection",
        "api.services.job_queue.ThreadJobQueue",
        "api.middlewares.security_headers.SecurityHeadersMiddleware",
        "api.middlewares.rate_limit.RateLimitMiddleware",
        "api.middlewares.rate_limit.RateLimitConfig",
        "api.middlewares.api_cache.ApiCacheMiddleware",
        "api.middlewares.api_cache.CacheConfig",
        "app.backup_api.initialize_backup_service",
        "app.backup_api.start_backup_service_if_configured",
        "app.backup_api.shutdown_backup_service",
        "tomllib",
        "tomli"
      ],
      "loc": 234,
      "name": "api.main"
    },
    "api.migrations.versions.001_add_performance_indexes_and_metrics": {
      "classes": [],
      "docstring": "add_performance_indexes_and_metrics\n\nRevision ID: perf_001\nRevises: \nCreate Date: 2025-10-14 17:30:00.000000\n\nAdd performance optimization indexes and new performance tracking tables",
      "exports": [],
      "file_path": "api/migrations/versions/001_add_performance_indexes_and_metrics.py",
      "functions": [
        "upgrade",
        "downgrade"
      ],
      "imports": [
        "alembic.op",
        "sqlalchemy",
        "sqlalchemy.Index"
      ],
      "loc": 255,
      "name": "api.migrations.versions.001_add_performance_indexes_and_metrics"
    },
    "api.migrations.versions.schema_cleanup_006": {
      "classes": [],
      "docstring": "Schema cleanup: Remove redundant lang field and add performance indexes\n\nRevision ID: schema_cleanup_006\nRevises: b8b3752f3e16\nCreate Date: 2025-10-11",
      "exports": [],
      "file_path": "api/migrations/versions/schema_cleanup_006.py",
      "functions": [
        "upgrade",
        "downgrade"
      ],
      "imports": [
        "typing.Sequence",
        "typing.Union",
        "alembic.op",
        "sqlalchemy"
      ],
      "loc": 101,
      "name": "api.migrations.versions.schema_cleanup_006"
    },
    "api.models": {
      "classes": [
        "Base",
        "User",
        "JobStatusEnum",
        "Job",
        "TranscriptMetadata",
        "ConfigEntry",
        "UserSetting",
        "AuditLog",
        "PerformanceMetric",
        "QueryPerformanceLog"
      ],
      "docstring": null,
      "exports": [],
      "file_path": "api/models.py",
      "functions": [
        "__repr__",
        "__repr__",
        "__repr__",
        "__repr__",
        "__repr__",
        "__repr__",
        "__repr__"
      ],
      "imports": [
        "datetime.datetime",
        "enum.Enum",
        "typing.Optional",
        "sqlalchemy.DateTime",
        "sqlalchemy.Enum",
        "sqlalchemy.Integer",
        "sqlalchemy.String",
        "sqlalchemy.Text",
        "sqlalchemy.Float",
        "sqlalchemy.Boolean",
        "sqlalchemy.Index",
        "sqlalchemy.orm.DeclarativeBase",
        "sqlalchemy.orm.Mapped",
        "sqlalchemy.orm.mapped_column",
        "sqlalchemy.ForeignKey"
      ],
      "loc": 233,
      "name": "api.models"
    },
    "api.models_optimized": {
      "classes": [
        "Base",
        "User",
        "JobStatusEnum",
        "Job",
        "TranscriptMetadata",
        "ConfigEntry",
        "UserSetting",
        "AuditLog",
        "PerformanceMetric",
        "QueryPerformanceLog"
      ],
      "docstring": "Database Performance Optimization Enhancement\nAdds additional indexes and optimizations to improve query performance",
      "exports": [],
      "file_path": "api/models_optimized.py",
      "functions": [
        "__repr__",
        "__repr__",
        "__repr__",
        "__repr__",
        "__repr__",
        "__repr__",
        "__repr__"
      ],
      "imports": [
        "datetime.datetime",
        "enum.Enum",
        "typing.Optional",
        "sqlalchemy.DateTime",
        "sqlalchemy.Enum",
        "sqlalchemy.Integer",
        "sqlalchemy.String",
        "sqlalchemy.Text",
        "sqlalchemy.Float",
        "sqlalchemy.Boolean",
        "sqlalchemy.Index",
        "sqlalchemy.orm.DeclarativeBase",
        "sqlalchemy.orm.Mapped",
        "sqlalchemy.orm.mapped_column",
        "sqlalchemy.ForeignKey"
      ],
      "loc": 325,
      "name": "api.models_optimized"
    },
    "api.optimized_endpoints": {
      "classes": [],
      "docstring": "Optimized API endpoints using performance-enhanced query patterns\nThis module demonstrates the use of optimized queries to replace existing inefficient patterns",
      "exports": [],
      "file_path": "api/optimized_endpoints.py",
      "functions": [
        "list_jobs_optimized",
        "get_job_detail_optimized",
        "get_job_statistics_optimized",
        "get_admin_dashboard_optimized",
        "get_user_activity_optimized",
        "search_jobs_optimized"
      ],
      "imports": [
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "datetime.datetime",
        "datetime.timedelta",
        "fastapi.Depends",
        "fastapi.HTTPException",
        "fastapi.Query",
        "sqlalchemy.orm.Session",
        "api.models.Job",
        "api.models.User",
        "api.models.TranscriptMetadata",
        "api.models.JobStatusEnum",
        "api.query_optimizer.OptimizedJobQueries",
        "api.query_optimizer.OptimizedUserQueries",
        "api.query_optimizer.OptimizedMetadataQueries",
        "api.query_optimizer.OptimizedAuditLogQueries",
        "api.query_optimizer.performance_tracked",
        "sqlalchemy.and_",
        "sqlalchemy.or_",
        "sqlalchemy.func"
      ],
      "loc": 382,
      "name": "api.optimized_endpoints"
    },
    "api.performance_middleware": {
      "classes": [
        "DatabasePerformanceMiddleware",
        "DatabaseQueryCounter",
        "PerformanceAwareSession"
      ],
      "docstring": "Database Performance Monitoring Middleware\nProvides FastAPI middleware for database performance monitoring and optimization",
      "exports": [],
      "file_path": "api/performance_middleware.py",
      "functions": [
        "setup_database_monitoring",
        "__init__",
        "dispatch",
        "_log_slow_request",
        "_collect_performance_metrics",
        "__init__",
        "__enter__",
        "__exit__",
        "get_performance_summary",
        "get_slow_queries",
        "get_performance_metrics",
        "__init__",
        "execute",
        "get_performance_stats"
      ],
      "imports": [
        "time",
        "json",
        "asyncio",
        "typing.Callable",
        "typing.Dict",
        "typing.Any",
        "typing.Optional",
        "datetime.datetime",
        "fastapi.FastAPI",
        "fastapi.Request",
        "fastapi.Response",
        "fastapi.middleware.base.BaseHTTPMiddleware",
        "sqlalchemy.orm.Session",
        "starlette.types.ASGIApp",
        "api.query_optimizer.DatabasePerformanceCollector",
        "api.query_optimizer.query_monitor",
        "api.models.QueryPerformanceLog",
        "sqlalchemy.desc",
        "api.models.PerformanceMetric",
        "sqlalchemy.desc",
        "sqlalchemy.and_",
        "datetime.datetime",
        "datetime.timedelta"
      ],
      "loc": 286,
      "name": "api.performance_middleware"
    },
    "api.query_optimizer": {
      "classes": [
        "QueryPerformanceMonitor",
        "OptimizedJobQueries",
        "OptimizedUserQueries",
        "OptimizedMetadataQueries",
        "OptimizedAuditLogQueries",
        "DatabasePerformanceCollector"
      ],
      "docstring": "Database Query Optimization Utilities\nProvides optimized query patterns and utilities to prevent N+1 queries and improve performance",
      "exports": [],
      "file_path": "api/query_optimizer.py",
      "functions": [
        "performance_tracked",
        "receive_before_cursor_execute",
        "receive_after_cursor_execute",
        "get_connection_pool_status",
        "__init__",
        "log_slow_query",
        "monitor_query",
        "decorator",
        "get_jobs_with_metadata",
        "get_job_with_user_and_metadata",
        "get_jobs_by_user_paginated",
        "get_job_statistics",
        "get_recent_active_jobs",
        "get_active_users_with_stats",
        "get_user_by_username_optimized",
        "get_metadata_analytics",
        "get_security_events",
        "get_user_activity_summary",
        "record_metric",
        "get_performance_summary",
        "wrapper"
      ],
      "imports": [
        "time",
        "contextlib.contextmanager",
        "functools.wraps",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "typing.Callable",
        "datetime.datetime",
        "datetime.timedelta",
        "sqlalchemy.and_",
        "sqlalchemy.or_",
        "sqlalchemy.desc",
        "sqlalchemy.asc",
        "sqlalchemy.func",
        "sqlalchemy.text",
        "sqlalchemy.orm.Session",
        "sqlalchemy.orm.joinedload",
        "sqlalchemy.orm.selectinload",
        "sqlalchemy.orm.contains_eager",
        "sqlalchemy.orm.query.Query",
        "sqlalchemy.engine.Engine",
        "sqlalchemy.event",
        "api.models.Job",
        "api.models.User",
        "api.models.TranscriptMetadata",
        "api.models.AuditLog",
        "api.models.PerformanceMetric",
        "api.models.QueryPerformanceLog",
        "json"
      ],
      "loc": 446,
      "name": "api.query_optimizer"
    },
    "api.router_setup": {
      "classes": [],
      "docstring": null,
      "exports": [],
      "file_path": "api/router_setup.py",
      "functions": [
        "register_routes",
        "spa_index",
        "spa_fallback"
      ],
      "imports": [
        "pathlib.Path",
        "logging",
        "fastapi.FastAPI",
        "fastapi.HTTPException",
        "fastapi.responses.FileResponse",
        "fastapi.staticfiles.StaticFiles",
        "api.routes.jobs",
        "api.routes.admin",
        "api.routes.logs",
        "api.routes.metrics",
        "api.routes.auth",
        "api.routes.users",
        "api.routes.audit",
        "api.routes.cache",
        "api.routes.progress",
        "api.routes.audio",
        "api.routes.tts",
        "api.routes.user_settings",
        "api.paths.storage",
        "api.paths.UPLOAD_DIR",
        "api.paths.TRANSCRIPTS_DIR",
        "api.app_state.backend_log",
        "app.backup_api.backup_router"
      ],
      "loc": 92,
      "name": "api.router_setup"
    },
    "app.backup.__init__": {
      "classes": [],
      "docstring": "Backup & Recovery System - Core Infrastructure\n\nThis module provides enterprise-grade backup and recovery capabilities\nfor the Whisper Transcriber application, supporting:\n\n- Real-time database backup with SQLite WAL mode\n- File system monitoring with immediate backup\n- Point-in-time recovery capabilities  \n- Multiple storage backends (local, S3, SFTP)\n- Compression, encryption, and deduplication\n- Automated retention policies\n- Monitoring and alerting",
      "exports": [],
      "file_path": "app/backup/__init__.py",
      "functions": [],
      "imports": [
        "orchestrator.BackupOrchestrator",
        "database.DatabaseBackupEngine",
        "files.FileBackupEngine",
        "storage.StorageBackend",
        "storage.LocalStorageBackend",
        "storage.S3StorageBackend",
        "compression.CompressionEngine",
        "recovery.RecoveryManager",
        "service.BackupService",
        "service.get_backup_service",
        "config.get_backup_config",
        "config.validate_backup_config",
        "logging"
      ],
      "loc": 46,
      "name": "app.backup.__init__"
    },
    "app.backup.compression": {
      "classes": [
        "CompressionEngine"
      ],
      "docstring": "Compression Engine - High-Performance File Compression\n\nProvides ZSTD compression optimized for backup workflows with\nconfigurable compression levels and integrity validation.",
      "exports": [],
      "file_path": "app/backup/compression.py",
      "functions": [
        "__init__",
        "compress_file",
        "decompress_file",
        "compress_data",
        "decompress_data",
        "_compress_zstd",
        "_decompress_zstd",
        "_compress_gzip",
        "_decompress_gzip",
        "_calculate_checksum",
        "get_compression_info"
      ],
      "imports": [
        "os",
        "logging",
        "pathlib.Path",
        "typing.Optional",
        "typing.Dict",
        "hashlib",
        "zstandard",
        "gzip"
      ],
      "loc": 279,
      "name": "app.backup.compression"
    },
    "app.backup.config": {
      "classes": [],
      "docstring": null,
      "exports": [],
      "file_path": "app/backup/config.py",
      "functions": [
        "get_backup_config",
        "validate_backup_config"
      ],
      "imports": [
        "os",
        "pathlib.Path"
      ],
      "loc": 232,
      "name": "app.backup.config"
    },
    "app.backup.database": {
      "classes": [
        "DatabaseBackupEngine"
      ],
      "docstring": "Database Backup Engine - SQLite Specialized Backup System\n\nProvides point-in-time recovery, WAL mode backup, and integrity validation\nspecifically optimized for SQLite databases.",
      "exports": [],
      "file_path": "app/backup/database.py",
      "functions": [
        "__init__",
        "load_metadata",
        "save_metadata",
        "enable_wal_mode",
        "create_full_backup",
        "backup_wal_files",
        "validate_backup",
        "cleanup_expired_backups",
        "get_backup_status",
        "_calculate_file_checksum",
        "_get_database_stats",
        "_is_wal_mode_enabled"
      ],
      "imports": [
        "os",
        "sqlite3",
        "shutil",
        "hashlib",
        "logging",
        "datetime.datetime",
        "datetime.timedelta",
        "pathlib.Path",
        "typing.Optional",
        "typing.Dict",
        "typing.List",
        "typing.Tuple",
        "tempfile",
        "json"
      ],
      "loc": 424,
      "name": "app.backup.database"
    },
    "app.backup.files": {
      "classes": [
        "FileChangeHandler",
        "FileBackupEngine"
      ],
      "docstring": "File Backup Engine - Real-time File System Backup\n\nProvides real-time file monitoring and backup with deduplication,\nincremental backups, and comprehensive file integrity validation.",
      "exports": [],
      "file_path": "app/backup/files.py",
      "functions": [
        "__init__",
        "on_created",
        "on_modified",
        "on_moved",
        "__init__",
        "load_indexes",
        "save_indexes",
        "start_monitoring",
        "stop_monitoring",
        "queue_file_for_backup",
        "should_backup_file",
        "backup_file",
        "process_backup_queue",
        "backup_directory",
        "cleanup_expired_backups",
        "get_backup_status",
        "_calculate_file_hash",
        "_get_relative_backup_path",
        "__del__"
      ],
      "imports": [
        "os",
        "shutil",
        "hashlib",
        "logging",
        "json",
        "datetime.datetime",
        "datetime.timedelta",
        "pathlib.Path",
        "typing.Optional",
        "typing.Dict",
        "typing.List",
        "typing.Set",
        "threading",
        "time",
        "watchdog.observers.Observer",
        "watchdog.events.FileSystemEventHandler",
        "traceback"
      ],
      "loc": 475,
      "name": "app.backup.files"
    },
    "app.backup.orchestrator": {
      "classes": [
        "BackupOrchestrator"
      ],
      "docstring": "Backup Orchestrator - Central Backup Coordination System\n\nCoordinates all backup operations including database backups, file backups,\nscheduling, storage backends, and monitoring. Provides a unified interface\nfor backup and recovery operations.",
      "exports": [],
      "file_path": "app/backup/orchestrator.py",
      "functions": [
        "__init__",
        "load_state",
        "save_state",
        "_initialize_components",
        "_create_storage_backend",
        "create_full_backup",
        "create_incremental_backup",
        "cleanup_expired_backups",
        "get_backup_status",
        "_upload_backups_to_storage",
        "_upload_to_backend",
        "_update_operation_progress",
        "stop"
      ],
      "imports": [
        "os",
        "logging",
        "json",
        "datetime.datetime",
        "datetime.timedelta",
        "pathlib.Path",
        "typing.Optional",
        "typing.Dict",
        "typing.List",
        "typing.Union",
        "threading",
        "time",
        "concurrent.futures.ThreadPoolExecutor",
        "concurrent.futures.as_completed",
        "database.DatabaseBackupEngine",
        "files.FileBackupEngine",
        "storage.StorageBackend",
        "storage.LocalStorageBackend",
        "compression.CompressionEngine",
        "storage.LocalStorageBackend",
        "storage.S3StorageBackend",
        "storage.SFTPStorageBackend"
      ],
      "loc": 607,
      "name": "app.backup.orchestrator"
    },
    "app.backup.recovery": {
      "classes": [
        "RecoveryManager"
      ],
      "docstring": "Recovery Manager - Disaster Recovery and System Restoration\n\nProvides comprehensive disaster recovery capabilities including database\nrestoration, file recovery, and complete system state restoration from backups.",
      "exports": [],
      "file_path": "app/backup/recovery.py",
      "functions": [
        "__init__",
        "list_available_backups",
        "restore_database",
        "restore_files",
        "perform_full_system_recovery",
        "validate_system_recovery",
        "test_recovery_procedures",
        "_get_backup_file_info",
        "_get_latest_database_backup",
        "_get_database_backup_by_id",
        "_create_recovery_backup",
        "_restore_database_file",
        "_apply_wal_files_until",
        "_validate_database",
        "_validate_restored_files",
        "_validate_system_structure",
        "_filter_files_for_restoration",
        "_restore_single_file",
        "_log_recovery_operation"
      ],
      "imports": [
        "os",
        "shutil",
        "logging",
        "json",
        "sqlite3",
        "datetime.datetime",
        "pathlib.Path",
        "typing.Optional",
        "typing.Dict",
        "typing.List",
        "typing.Union",
        "tempfile",
        "subprocess",
        "fnmatch",
        "compression.CompressionEngine",
        "compression.CompressionEngine"
      ],
      "loc": 758,
      "name": "app.backup.recovery"
    },
    "app.backup.service": {
      "classes": [
        "BackupService"
      ],
      "docstring": "Backup Service - Main Entry Point for Backup System\n\nProvides a high-level interface for backup operations, integrating all\nbackup components with scheduling, monitoring, and administration features.",
      "exports": [],
      "file_path": "app/backup/service.py",
      "functions": [
        "get_backup_service",
        "start_backup_service",
        "stop_backup_service",
        "__init__",
        "start",
        "stop",
        "create_manual_backup",
        "create_recovery",
        "cleanup_backups",
        "get_service_status",
        "test_backup_system",
        "_setup_scheduling",
        "_run_scheduler",
        "_scheduled_full_backup",
        "_scheduled_incremental_backup",
        "_scheduled_cleanup",
        "_signal_handler"
      ],
      "imports": [
        "logging",
        "threading",
        "time",
        "datetime.datetime",
        "datetime.timedelta",
        "typing.Optional",
        "typing.Dict",
        "typing.List",
        "schedule",
        "signal",
        "sys",
        "config.get_backup_config",
        "config.validate_backup_config",
        "orchestrator.BackupOrchestrator",
        "recovery.RecoveryManager",
        "argparse"
      ],
      "loc": 521,
      "name": "app.backup.service"
    },
    "app.backup.storage": {
      "classes": [
        "StorageBackend",
        "LocalStorageBackend",
        "S3StorageBackend",
        "SFTPStorageBackend"
      ],
      "docstring": "Storage Backend Infrastructure - Multi-Backend Backup Storage\n\nProvides abstracted storage backends for backups including local storage,\nS3-compatible cloud storage, and SFTP/SSH remote storage.",
      "exports": [],
      "file_path": "app/backup/storage.py",
      "functions": [
        "upload_file",
        "download_file",
        "delete_file",
        "list_files",
        "file_exists",
        "get_file_info",
        "get_backend_info",
        "__init__",
        "upload_file",
        "download_file",
        "delete_file",
        "list_files",
        "file_exists",
        "get_file_info",
        "get_backend_info",
        "__init__",
        "upload_file",
        "download_file",
        "delete_file",
        "list_files",
        "file_exists",
        "get_file_info",
        "get_backend_info",
        "__init__",
        "_connect",
        "_ensure_connected",
        "upload_file",
        "download_file",
        "delete_file",
        "list_files",
        "file_exists",
        "get_file_info",
        "get_backend_info",
        "_mkdir_p",
        "__del__",
        "walk_remote_dir",
        "count_files"
      ],
      "imports": [
        "os",
        "logging",
        "abc.ABC",
        "abc.abstractmethod",
        "pathlib.Path",
        "typing.Optional",
        "typing.Dict",
        "typing.List",
        "typing.Union",
        "shutil",
        "tempfile",
        "boto3",
        "botocore.exceptions.ClientError",
        "paramiko"
      ],
      "loc": 658,
      "name": "app.backup.storage"
    },
    "app.backup_api": {
      "classes": [
        "BackupRequest",
        "RecoveryRequest",
        "BackupStatusResponse",
        "BackupOperationResponse",
        "RecoveryOperationResponse",
        "Config",
        "Config"
      ],
      "docstring": "Backup Management API - Admin Endpoints for Backup Operations\n\nProvides REST API endpoints for backup management, monitoring, and recovery\noperations. Integrated with the main FastAPI application.",
      "exports": [],
      "file_path": "app/backup_api.py",
      "functions": [
        "get_backup_service_instance",
        "get_backup_status",
        "create_backup",
        "create_recovery",
        "list_available_backups",
        "cleanup_backups",
        "test_backup_system",
        "validate_system_recovery",
        "backup_health_check",
        "initialize_backup_service",
        "start_backup_service_if_configured",
        "shutdown_backup_service",
        "run_backup"
      ],
      "imports": [
        "datetime.datetime",
        "typing.Optional",
        "typing.Dict",
        "typing.List",
        "typing.Any",
        "fastapi.APIRouter",
        "fastapi.Depends",
        "fastapi.HTTPException",
        "fastapi.BackgroundTasks",
        "fastapi.status",
        "pydantic.BaseModel",
        "pydantic.Field",
        "logging",
        "app.backup.service.get_backup_service",
        "app.backup.service.BackupService"
      ],
      "loc": 435,
      "name": "app.backup_api"
    },
    "app.main": {
      "classes": [
        "FileValidationError",
        "Job",
        "User",
        "TokenOut",
        "TokenLoginOut",
        "PasswordChangeIn",
        "ConnectionManager"
      ],
      "docstring": null,
      "exports": [],
      "file_path": "app/main.py",
      "functions": [
        "get_cors_origins",
        "setup_logging",
        "validate_uploaded_file",
        "sanitize_filename",
        "get_db",
        "verify_password",
        "get_password_hash",
        "create_access_token",
        "get_user_by_username",
        "create_user",
        "get_token",
        "get_current_user",
        "require_admin",
        "lifespan",
        "root",
        "login",
        "register",
        "change_password",
        "health_check",
        "get_metrics",
        "get_stats",
        "monitoring_dashboard",
        "create_transcription",
        "get_job",
        "download_transcript",
        "list_jobs",
        "admin_list_jobs",
        "delete_job",
        "websocket_job_progress",
        "process_transcription",
        "__init__",
        "connect",
        "disconnect",
        "send_progress"
      ],
      "imports": [
        "contextlib.asynccontextmanager",
        "fastapi.FastAPI",
        "fastapi.UploadFile",
        "fastapi.File",
        "fastapi.HTTPException",
        "fastapi.Depends",
        "fastapi.WebSocket",
        "fastapi.WebSocketDisconnect",
        "fastapi.Request",
        "fastapi.status",
        "fastapi.responses.FileResponse",
        "fastapi.responses.JSONResponse",
        "fastapi.staticfiles.StaticFiles",
        "fastapi.middleware.cors.CORSMiddleware",
        "fastapi.security.OAuth2PasswordBearer",
        "fastapi.security.OAuth2PasswordRequestForm",
        "fastapi.security.utils.get_authorization_scheme_param",
        "sqlalchemy.create_engine",
        "sqlalchemy.Column",
        "sqlalchemy.Integer",
        "sqlalchemy.String",
        "sqlalchemy.DateTime",
        "sqlalchemy.Text",
        "sqlalchemy.Boolean",
        "sqlalchemy.orm.sessionmaker",
        "sqlalchemy.orm.Session",
        "sqlalchemy.orm.declarative_base",
        "datetime.datetime",
        "datetime.timedelta",
        "jose.JWTError",
        "jose.jwt",
        "passlib.context.CryptContext",
        "pydantic.BaseModel",
        "pydantic.ValidationError",
        "uuid",
        "os",
        "json",
        "asyncio",
        "magic",
        "hashlib",
        "logging",
        "logging.config",
        "psutil",
        "time",
        "pathlib.Path",
        "typing.Optional",
        "typing.List",
        "typing.Dict",
        "typing.Set",
        "logging",
        "schemas.UserRegistrationSchema",
        "schemas.UserLoginSchema",
        "schemas.PasswordChangeSchema",
        "schemas.FileUploadSchema",
        "schemas.JobQuerySchema",
        "schemas.JobIdSchema",
        "schemas.TokenResponseSchema",
        "schemas.UserResponseSchema",
        "schemas.JobResponseSchema",
        "schemas.PaginatedJobsResponseSchema",
        "schemas.ErrorResponseSchema",
        "schemas.HealthResponseSchema",
        "schemas.MetricsResponseSchema",
        "schemas.create_validation_error_response",
        "schemas.validate_request_size",
        "pagination.PaginationRequest",
        "pagination.JobQueryFilters",
        "pagination.JobPaginator",
        "pagination.PaginatedResponse",
        "pagination.PaginationMetadata",
        "rate_limiter.RateLimitMiddleware",
        "rate_limiter.RateLimitConfig",
        "rate_limiter.create_development_rate_limiter",
        "security_middleware.SecurityMiddleware",
        "security_middleware.create_development_security_middleware",
        "security_middleware.security_logger",
        "pydantic.BaseModel",
        "rate_limiter.create_strict_rate_limiter",
        "fastapi.responses.HTMLResponse",
        "uvicorn",
        "sqlalchemy.text",
        "worker.transcribe_audio"
      ],
      "loc": 1480,
      "name": "app.main"
    },
    "app.pagination": {
      "classes": [
        "PaginationConfig",
        "PaginationRequest",
        "PaginationMetadata",
        "PaginatedResponse",
        "CursorGenerator",
        "JobPaginator",
        "JobQueryFilters"
      ],
      "docstring": "Pagination utilities for the Whisper Transcriber API.\n\nThis module provides cursor-based pagination for efficient handling of large datasets\nwith support for total counts, configurable page sizes, and navigation metadata.",
      "exports": [],
      "file_path": "app/pagination.py",
      "functions": [
        "validate_cursor",
        "validate_sort_by",
        "validate_sort_order",
        "generate_cursor",
        "parse_cursor",
        "__init__",
        "paginate_jobs",
        "validate_status",
        "validate_model_used",
        "apply_filters"
      ],
      "imports": [
        "datetime.datetime",
        "typing.Optional",
        "typing.List",
        "typing.Dict",
        "typing.Any",
        "typing.Generic",
        "typing.TypeVar",
        "typing.Union",
        "pydantic.BaseModel",
        "pydantic.Field",
        "pydantic.field_validator",
        "sqlalchemy.orm.Session",
        "sqlalchemy.orm.Query",
        "sqlalchemy.desc",
        "sqlalchemy.asc",
        "sqlalchemy.func",
        "sqlalchemy.and_",
        "sqlalchemy.or_",
        "base64",
        "json",
        "app.schemas.BaseSchema",
        "app.schemas.ValidationConfig",
        "app.schemas.sanitize_string",
        "app.main.Job",
        "app.main.Job"
      ],
      "loc": 398,
      "name": "app.pagination"
    },
    "app.rate_limiter": {
      "classes": [
        "RateLimit",
        "RateLimitConfig",
        "SlidingWindowCounter",
        "MemoryRateLimitStore",
        "RateLimitMiddleware"
      ],
      "docstring": "Rate Limiting Middleware for DoS Protection and API Abuse Prevention.\n\nThis middleware provides comprehensive rate limiting with multiple strategies:\n- Per-IP rate limiting\n- Per-user rate limiting  \n- Per-endpoint rate limiting\n- Sliding window algorithm\n- Memory-based storage (Redis support ready)\n- Configurable limits and timeouts\n- Security event logging",
      "exports": [],
      "file_path": "app/rate_limiter.py",
      "functions": [
        "create_strict_rate_limiter",
        "create_development_rate_limiter",
        "__init__",
        "add_request",
        "_cleanup_old_requests",
        "get_stats",
        "__init__",
        "check_rate_limit",
        "_maybe_cleanup",
        "_cleanup_old_entries",
        "__init__",
        "_log_configuration",
        "dispatch",
        "_check_all_limits",
        "_get_client_ip",
        "_get_user_id",
        "_get_endpoint_limit",
        "_matches_endpoint_pattern",
        "_is_valid_ip",
        "_is_ip_whitelisted",
        "_is_ip_blocked",
        "_create_rate_limit_response",
        "_add_rate_limit_headers"
      ],
      "imports": [
        "asyncio",
        "time",
        "collections.defaultdict",
        "collections.deque",
        "typing.Dict",
        "typing.Optional",
        "typing.Tuple",
        "typing.List",
        "typing.Any",
        "dataclasses.dataclass",
        "dataclasses.field",
        "datetime.datetime",
        "datetime.timedelta",
        "logging",
        "ipaddress",
        "fastapi.Request",
        "fastapi.Response",
        "fastapi.HTTPException",
        "fastapi.status",
        "fastapi.responses.JSONResponse",
        "starlette.middleware.base.BaseHTTPMiddleware"
      ],
      "loc": 514,
      "name": "app.rate_limiter"
    },
    "app.schemas": {
      "classes": [
        "ValidationConfig",
        "BaseSchema",
        "UserRegistrationSchema",
        "UserLoginSchema",
        "PasswordChangeSchema",
        "FileUploadSchema",
        "JobQuerySchema",
        "JobIdSchema",
        "TokenResponseSchema",
        "UserResponseSchema",
        "JobResponseSchema",
        "PaginatedJobsResponseSchema",
        "ErrorResponseSchema",
        "HealthResponseSchema",
        "MetricsResponseSchema",
        "Config",
        "Config"
      ],
      "docstring": "Enhanced Pydantic schemas with comprehensive input validation for security.\n\nThis module provides type-safe, validated schemas for all API endpoints with\nsecurity-focused validation to prevent common attack vectors:\n- SQL injection prevention\n- XSS protection  \n- Input sanitization\n- Data type validation\n- Field length limits\n- Pattern validation",
      "exports": [],
      "file_path": "app/schemas.py",
      "functions": [
        "sanitize_string",
        "validate_no_sql_injection",
        "validate_request_size",
        "validate_json_depth",
        "create_validation_error_response",
        "validate_username",
        "validate_password",
        "validate_username",
        "validate_password",
        "validate_new_password",
        "validate_filename",
        "validate_model",
        "validate_language",
        "validate_status",
        "validate_job_id",
        "sanitize_username",
        "sanitize_text_fields",
        "sanitize_message"
      ],
      "imports": [
        "datetime.datetime",
        "typing.Optional",
        "typing.List",
        "typing.Dict",
        "typing.Any",
        "pydantic.BaseModel",
        "pydantic.Field",
        "pydantic.validator",
        "pydantic.field_validator",
        "pydantic_core.ValidationError",
        "re",
        "html",
        "bleach"
      ],
      "loc": 522,
      "name": "app.schemas"
    },
    "app.security_middleware": {
      "classes": [
        "SecurityConfig",
        "SecurityValidator",
        "SecurityMiddleware",
        "SecurityEventLogger"
      ],
      "docstring": "Security Middleware for Request Validation and Attack Prevention.\n\nThis middleware provides comprehensive request security including:\n- Request size limits and timeout protection\n- Header validation and sanitization\n- Malicious payload detection\n- SQL injection prevention\n- XSS attack prevention\n- Path traversal protection\n- Security headers enforcement\n- Request logging for security events",
      "exports": [],
      "file_path": "app/security_middleware.py",
      "functions": [
        "create_security_middleware",
        "create_development_security_middleware",
        "validate_request_size",
        "validate_headers",
        "_validate_user_agent",
        "_validate_content_type",
        "validate_url",
        "validate_json_payload",
        "_validate_json_structure",
        "_validate_json_content",
        "_check_malicious_patterns",
        "__init__",
        "dispatch",
        "_is_json_request",
        "_validate_json_payload",
        "_add_security_headers",
        "__init__",
        "log_attack_attempt",
        "log_rate_limit_exceeded",
        "log_authentication_failure",
        "log_suspicious_activity"
      ],
      "imports": [
        "re",
        "json",
        "time",
        "logging",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "typing.List",
        "urllib.parse.unquote",
        "fastapi.Request",
        "fastapi.Response",
        "fastapi.HTTPException",
        "fastapi.responses.JSONResponse",
        "starlette.middleware.base.BaseHTTPMiddleware"
      ],
      "loc": 545,
      "name": "app.security_middleware"
    },
    "app.worker": {
      "classes": [],
      "docstring": null,
      "exports": [],
      "file_path": "app/worker.py",
      "functions": [
        "get_whisper_model",
        "transcribe_audio",
        "health_check",
        "setup_periodic_tasks"
      ],
      "imports": [
        "os",
        "asyncio",
        "celery.Celery",
        "pathlib.Path",
        "whisper",
        "logging",
        "datetime.datetime",
        "sqlalchemy.create_engine",
        "sqlalchemy.orm.sessionmaker",
        "main.Job",
        "main.Base",
        "main.ConnectionManager"
      ],
      "loc": 181,
      "name": "app.worker"
    },
    "generate_function_docs": {
      "classes": [
        "FunctionInfo",
        "APIEndpoint",
        "ApplicationDocumentationGenerator"
      ],
      "docstring": "Comprehensive Application Documentation Generator\n\nGenerates complete documentation of:\n- All functions and their signatures\n- API endpoints and data flow\n- Component relationships\n- Database operations\n- Logic chunks and dependencies",
      "exports": [],
      "file_path": "generate_function_docs.py",
      "functions": [
        "__init__",
        "analyze_python_files",
        "_extract_functions_from_ast",
        "_get_function_signature",
        "_extract_function_calls",
        "_get_attribute_path",
        "_check_for_api_endpoint",
        "generate_documentation",
        "_generate_data_flow_analysis",
        "save_documentation"
      ],
      "imports": [
        "ast",
        "os",
        "re",
        "json",
        "pathlib.Path",
        "typing.Dict",
        "typing.List",
        "typing.Any",
        "typing.Optional",
        "dataclasses.dataclass",
        "dataclasses.asdict"
      ],
      "loc": 265,
      "name": "generate_function_docs"
    },
    "scripts.dev.auth_dev_bypass": {
      "classes": [],
      "docstring": "Development Authentication Bypass\n\nThis script temporarily disables authentication for development/testing.\nCan be easily reverted when ready for production.",
      "exports": [],
      "file_path": "scripts/dev/auth_dev_bypass.py",
      "functions": [
        "create_auth_bypass",
        "apply_auth_bypass",
        "remove_auth_bypass",
        "main"
      ],
      "imports": [
        "os",
        "sys",
        "pathlib.Path"
      ],
      "loc": 157,
      "name": "scripts.dev.auth_dev_bypass"
    },
    "scripts.dev.comprehensive_integration_test": {
      "classes": [
        "TestResult",
        "IntegratedApplicationTest"
      ],
      "docstring": "Complete Application Integration Test\n\nThis test starts the application services and runs comprehensive validation\nof every function chain without requiring manual interaction.",
      "exports": [],
      "file_path": "scripts/dev/comprehensive_integration_test.py",
      "functions": [
        "main",
        "__init__",
        "start_test_environment",
        "stop_test_environment",
        "authenticate",
        "test_api_endpoint",
        "test_file_upload_chain",
        "run_comprehensive_tests",
        "generate_test_report",
        "run_full_test_suite"
      ],
      "imports": [
        "asyncio",
        "json",
        "os",
        "sys",
        "time",
        "requests",
        "subprocess",
        "threading",
        "signal",
        "pathlib.Path",
        "typing.Dict",
        "typing.List",
        "typing.Any",
        "typing.Optional",
        "typing.Tuple",
        "dataclasses.dataclass",
        "datetime.datetime"
      ],
      "loc": 470,
      "name": "scripts.dev.comprehensive_integration_test"
    },
    "scripts.dev.fix_authentication": {
      "classes": [
        "AuthenticationFixer"
      ],
      "docstring": "Complete Authentication Reset and Fix\n\nThis script completely resets authentication, creates clean users,\nand verifies everything works end-to-end.",
      "exports": [],
      "file_path": "scripts/dev/fix_authentication.py",
      "functions": [
        "main",
        "__init__",
        "reset_database",
        "create_users",
        "start_server",
        "test_authentication",
        "test_authenticated_endpoints",
        "test_file_upload_with_auth",
        "stop_server",
        "run_complete_fix"
      ],
      "imports": [
        "os",
        "sys",
        "time",
        "requests",
        "subprocess",
        "pathlib.Path",
        "api.models.Base",
        "api.orm_bootstrap.engine",
        "sqlalchemy.inspect",
        "api.services.users.create_user",
        "api.services.users.get_user_by_username",
        "api.services.users.verify_password"
      ],
      "loc": 377,
      "name": "scripts.dev.fix_authentication"
    },
    "scripts.dev.full_stack_function_mapper": {
      "classes": [
        "FunctionChain",
        "FullStackMapper"
      ],
      "docstring": "Comprehensive Full-Stack Function Mapping and Testing Framework\n\nThis framework maps every user action through the complete technology stack:\nUI Action \u2192 Frontend Function \u2192 API Call \u2192 Backend Route \u2192 Business Logic \u2192 Database/Services\n\nIt then creates automated tests that verify the entire chain without manual interaction.",
      "exports": [],
      "file_path": "scripts/dev/full_stack_function_mapper.py",
      "functions": [
        "main",
        "__init__",
        "define_function_chains",
        "test_authentication_chain",
        "test_api_chain",
        "test_websocket_chain",
        "test_function_chain",
        "run_all_tests",
        "generate_dependency_graph"
      ],
      "imports": [
        "asyncio",
        "json",
        "os",
        "sys",
        "time",
        "requests",
        "threading",
        "pathlib.Path",
        "typing.Dict",
        "typing.List",
        "typing.Any",
        "typing.Optional",
        "typing.Tuple",
        "dataclasses.dataclass",
        "dataclasses.asdict",
        "datetime.datetime"
      ],
      "loc": 490,
      "name": "scripts.dev.full_stack_function_mapper"
    },
    "scripts.dev.init_sqlite_dev": {
      "classes": [],
      "docstring": "SQLite Database Initialization for Development\n\nCreates tables and default admin user for development testing.",
      "exports": [],
      "file_path": "scripts/dev/init_sqlite_dev.py",
      "functions": [
        "init_sqlite_dev_db",
        "test_authentication",
        "main"
      ],
      "imports": [
        "sys",
        "pathlib.Path",
        "api.models.Base",
        "api.orm_bootstrap.engine",
        "api.orm_bootstrap.SessionLocal",
        "api.services.users.create_user",
        "api.services.users.get_user_by_username",
        "requests",
        "api.services.users.verify_password"
      ],
      "loc": 122,
      "name": "scripts.dev.init_sqlite_dev"
    },
    "scripts.dev.test_all_functions": {
      "classes": [
        "InfrastructureTests",
        "ConfigurationTests",
        "DatabaseTests",
        "APITests",
        "WorkerTests",
        "ContainerTests",
        "UtilityTests"
      ],
      "docstring": "Comprehensive Application Function Tester for Whisper Transcriber\n\nThis script systematically tests every function of the whisper-transcriber application\nto determine what's working and what's returning errors.\n\nUsage:\n    python test_all_functions.py [--local] [--containers] [--verbose]\n    \n    --local: Test local Python modules without containers\n    --containers: Test containerized services (requires Docker)\n    --verbose: Show detailed output for all tests",
      "exports": [],
      "file_path": "scripts/dev/test_all_functions.py",
      "functions": [
        "log_test",
        "run_all_tests",
        "main",
        "test_python_imports",
        "test_file_structure",
        "test_model_files",
        "test_settings_loading",
        "test_environment_variables",
        "test_database_models",
        "test_migrations",
        "test_fastapi_app_creation",
        "test_api_route_modules",
        "test_celery_app_creation",
        "test_whisper_model_loading",
        "test_docker_availability",
        "test_container_services",
        "test_logging_setup",
        "test_path_configuration"
      ],
      "imports": [
        "argparse",
        "json",
        "logging",
        "os",
        "subprocess",
        "sys",
        "time",
        "traceback",
        "pathlib.Path",
        "typing.Dict",
        "typing.List",
        "typing.Any",
        "typing.Optional",
        "importlib.util",
        "api.settings.settings",
        "api.models.Base",
        "api.models.User",
        "api.models.Job",
        "api.models.TranscriptMetadata",
        "api.models.ConfigEntry",
        "api.models.UserSetting",
        "api.main.app",
        "api.worker.celery_app",
        "whisper",
        "api.utils.logger.get_system_logger",
        "api.paths.MODEL_DIR",
        "api.paths.UPLOAD_DIR",
        "api.paths.TRANSCRIPTS_DIR"
      ],
      "loc": 427,
      "name": "scripts.dev.test_all_functions"
    },
    "scripts.dev.test_features": {
      "classes": [],
      "docstring": "Comprehensive test script for all implemented features",
      "exports": [],
      "file_path": "scripts/dev/test_features.py",
      "functions": [
        "test_security_headers",
        "test_rate_limiting",
        "test_api_caching",
        "test_error_handling",
        "main"
      ],
      "imports": [
        "requests",
        "time",
        "json",
        "sys"
      ],
      "loc": 157,
      "name": "scripts.dev.test_features"
    },
    "scripts.dev_setup": {
      "classes": [],
      "docstring": "Development Database Initialization Script\nStreamlined version for the new app/ architecture",
      "exports": [],
      "file_path": "scripts/dev_setup.py",
      "functions": [
        "init_database",
        "test_app_startup",
        "main"
      ],
      "imports": [
        "os",
        "sys",
        "pathlib.Path",
        "sqlite3",
        "app.main.Base",
        "app.main.engine",
        "app.main.SessionLocal",
        "sqlalchemy.text",
        "app.main.app"
      ],
      "loc": 71,
      "name": "scripts.dev_setup"
    },
    "scripts.tests.__init__": {
      "classes": [],
      "docstring": null,
      "exports": [],
      "file_path": "scripts/tests/__init__.py",
      "functions": [],
      "imports": [],
      "loc": 1,
      "name": "scripts.tests.__init__"
    },
    "scripts.update_manifest": {
      "classes": [],
      "docstring": "Script to generate/update local_manifest.txt with a list of all files in the repository (excluding .git, venv, node_modules, and transient log files).",
      "exports": [],
      "file_path": "scripts/update_manifest.py",
      "functions": [
        "should_exclude",
        "collect_files",
        "main"
      ],
      "imports": [
        "os",
        "subprocess",
        "datetime.datetime",
        "hashlib",
        "hashlib"
      ],
      "loc": 136,
      "name": "scripts.update_manifest"
    },
    "scripts.validate_db_performance": {
      "classes": [],
      "docstring": "Simple Database Performance Validation\nValidates that our database optimizations are properly implemented",
      "exports": [],
      "file_path": "scripts/validate_db_performance.py",
      "functions": [
        "validate_model_indexes",
        "validate_query_optimizations",
        "validate_performance_middleware",
        "validate_migration_scripts",
        "validate_optimized_endpoints",
        "run_simple_performance_check",
        "main"
      ],
      "imports": [
        "sys",
        "time",
        "pathlib.Path",
        "api.models_optimized.Job",
        "api.models_optimized.User",
        "api.models_optimized.TranscriptMetadata",
        "api.models_optimized.AuditLog",
        "api.query_optimizer.OptimizedJobQueries",
        "api.query_optimizer.OptimizedUserQueries",
        "api.query_optimizer.OptimizedMetadataQueries",
        "api.query_optimizer.QueryPerformanceMonitor",
        "api.performance_middleware.DatabasePerformanceMiddleware",
        "api.performance_middleware.setup_database_monitoring",
        "api.optimized_endpoints.list_jobs_optimized",
        "api.optimized_endpoints.get_job_detail_optimized",
        "api.optimized_endpoints.get_job_statistics_optimized",
        "api.optimized_endpoints.get_admin_dashboard_optimized",
        "api.models_optimized.Job",
        "api.models_optimized.User",
        "api.query_optimizer.OptimizedJobQueries",
        "api.performance_middleware.DatabasePerformanceMiddleware"
      ],
      "loc": 266,
      "name": "scripts.validate_db_performance"
    },
    "scripts.validate_pagination_009": {
      "classes": [],
      "docstring": "Simple validation script for pagination functionality (Issue #009).\n\nThis script tests the basic functionality of the pagination system\nwithout requiring the full test environment setup.",
      "exports": [],
      "file_path": "scripts/validate_pagination_009.py",
      "functions": [
        "test_pagination_imports",
        "test_pagination_request_validation",
        "test_cursor_generation",
        "test_job_query_filters",
        "test_schemas_integration",
        "main"
      ],
      "imports": [
        "sys",
        "os",
        "traceback",
        "datetime.datetime",
        "datetime.timedelta",
        "app.pagination.PaginationRequest",
        "app.pagination.JobQueryFilters",
        "app.pagination.CursorGenerator",
        "app.pagination.PaginationConfig",
        "app.pagination.PaginationMetadata",
        "app.pagination.PaginationRequest",
        "app.pagination.CursorGenerator",
        "app.pagination.JobQueryFilters",
        "app.schemas.PaginatedJobsResponseSchema",
        "app.schemas.JobResponseSchema"
      ],
      "loc": 215,
      "name": "scripts.validate_pagination_009"
    },
    "tests.test_backup_system": {
      "classes": [
        "TestBackupSystemAvailability",
        "TestDatabaseBackupEngine",
        "TestFileBackupEngine",
        "TestCompressionEngine",
        "TestStorageBackends",
        "TestBackupOrchestrator",
        "TestRecoveryManager",
        "TestBackupConfiguration",
        "TestBackupService",
        "TestBackupAPI",
        "TestBackupSystemIntegration"
      ],
      "docstring": "Comprehensive Test Suite for Backup and Recovery System\n\nTests all components of the backup system including database backups,\nfile backups, compression, storage backends, orchestration, recovery,\nand API endpoints.",
      "exports": [],
      "file_path": "tests/test_backup_system.py",
      "functions": [
        "test_backup_system_imports",
        "temp_db",
        "temp_backup_dir",
        "test_database_backup_engine_init",
        "test_create_full_backup",
        "test_wal_backup",
        "test_backup_integrity_check",
        "temp_source_dir",
        "temp_backup_dir",
        "test_file_backup_engine_init",
        "test_create_file_backup",
        "test_file_deduplication",
        "temp_test_file",
        "test_compression_engine_init",
        "test_compress_file",
        "test_decompress_file",
        "temp_storage_dir",
        "temp_test_file",
        "test_local_storage_backend",
        "test_s3_storage_backend_mock",
        "temp_dirs",
        "test_orchestrator_init",
        "test_full_backup_orchestration",
        "temp_recovery_setup",
        "test_recovery_manager_init",
        "test_list_available_backups",
        "test_get_backup_config_defaults",
        "test_validate_backup_config",
        "test_validate_backup_config_invalid",
        "temp_service_setup",
        "test_backup_service_init",
        "test_backup_service_status",
        "test_manual_backup_creation",
        "test_client",
        "test_backup_status_endpoint",
        "test_create_backup_endpoint",
        "test_backup_health_endpoint",
        "test_backup_system_end_to_end"
      ],
      "imports": [
        "os",
        "tempfile",
        "shutil",
        "sqlite3",
        "json",
        "time",
        "datetime.datetime",
        "datetime.timezone",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "unittest.mock.MagicMock",
        "pytest",
        "fastapi.testclient.TestClient",
        "app.backup.database.DatabaseBackupEngine",
        "app.backup.files.FileBackupEngine",
        "app.backup.compression.CompressionEngine",
        "app.backup.storage.LocalStorageBackend",
        "app.backup.storage.S3StorageBackend",
        "app.backup.storage.SFTPStorageBackend",
        "app.backup.orchestrator.BackupOrchestrator",
        "app.backup.recovery.RecoveryManager",
        "app.backup.config.get_backup_config",
        "app.backup.config.validate_backup_config",
        "app.backup.service.BackupService",
        "app.backup_api.backup_router",
        "fastapi.FastAPI"
      ],
      "loc": 712,
      "name": "tests.test_backup_system"
    },
    "tests.test_container_security_008": {
      "classes": [
        "ContainerSecurityTester",
        "TestDockerfileSecurityHardening",
        "TestDockerComposeSecurityContext",
        "TestRuntimeContainerSecurity",
        "TestContainerNetworkSecurity"
      ],
      "docstring": "Comprehensive Container Security Tests for Whisper Transcriber\nTests container security configurations, hardening, and compliance",
      "exports": [],
      "file_path": "tests/test_container_security_008.py",
      "functions": [
        "main",
        "__init__",
        "load_compose_config",
        "run_docker_command",
        "test_dockerfile_exists",
        "test_non_root_user",
        "test_secure_base_image",
        "test_no_sensitive_files",
        "test_security_labels",
        "compose_config",
        "test_compose_file_exists",
        "test_no_privileged_containers",
        "test_security_options_configured",
        "test_capability_dropping",
        "test_non_root_users",
        "test_read_only_filesystems",
        "test_resource_limits",
        "test_network_security",
        "test_volume_security",
        "test_environment_security",
        "container_tester",
        "test_container_user_id",
        "test_container_capabilities",
        "test_container_filesystem_readonly",
        "test_network_isolation",
        "test_port_exposure_minimal"
      ],
      "imports": [
        "json",
        "os",
        "subprocess",
        "sys",
        "tempfile",
        "time",
        "yaml",
        "pathlib.Path",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "pytest"
      ],
      "loc": 417,
      "name": "tests.test_container_security_008"
    },
    "tests.test_database_performance_011": {
      "classes": [
        "DatabasePerformanceTester",
        "TestDatabasePerformanceOptimizations",
        "BenchmarkRunner"
      ],
      "docstring": "Database Performance Testing Suite\nComprehensive tests to validate database optimization improvements and benchmarks",
      "exports": [],
      "file_path": "tests/test_database_performance_011.py",
      "functions": [
        "main",
        "__init__",
        "get_db_session",
        "time_operation",
        "generate_test_data",
        "performance_tester",
        "test_job_listing_performance",
        "test_job_statistics_performance",
        "test_user_activity_performance",
        "test_metadata_analytics_performance",
        "test_search_performance",
        "test_pagination_performance",
        "test_index_effectiveness",
        "__init__",
        "run_baseline_benchmarks",
        "run_stress_test"
      ],
      "imports": [
        "time",
        "statistics",
        "random",
        "string",
        "datetime.datetime",
        "datetime.timedelta",
        "typing.Dict",
        "typing.List",
        "typing.Any",
        "typing.Tuple",
        "contextlib.contextmanager",
        "pytest",
        "sqlalchemy.create_engine",
        "sqlalchemy.text",
        "sqlalchemy.func",
        "sqlalchemy.orm.sessionmaker",
        "sqlalchemy.pool.StaticPool",
        "api.models.Base",
        "api.models.Job",
        "api.models.User",
        "api.models.TranscriptMetadata",
        "api.models.AuditLog",
        "api.models.JobStatusEnum",
        "api.query_optimizer.OptimizedJobQueries",
        "api.query_optimizer.OptimizedUserQueries",
        "api.query_optimizer.OptimizedMetadataQueries",
        "api.query_optimizer.OptimizedAuditLogQueries",
        "api.query_optimizer.QueryPerformanceMonitor"
      ],
      "loc": 474,
      "name": "tests.test_database_performance_011"
    },
    "tests.test_pagination_009": {
      "classes": [
        "TestPaginationCore",
        "TestPaginationEdgeCases",
        "TestPaginationPerformance",
        "TestCursorGeneration"
      ],
      "docstring": "Test suite for API pagination functionality (Issue #009).\n\nThis module tests cursor-based pagination, filtering, and edge cases\nfor job listing endpoints with comprehensive validation.",
      "exports": [],
      "file_path": "tests/test_pagination_009.py",
      "functions": [
        "override_get_db",
        "setup_database",
        "get_auth_headers",
        "test_basic_pagination",
        "test_cursor_navigation",
        "test_sorting_options",
        "test_filtering",
        "test_total_count_optional",
        "test_admin_endpoint",
        "setup_database",
        "get_auth_headers",
        "test_empty_dataset",
        "test_invalid_page_size",
        "test_invalid_cursor",
        "test_invalid_sort_field",
        "test_invalid_sort_order",
        "test_invalid_filter_values",
        "setup_large_dataset",
        "get_auth_headers",
        "test_large_dataset_pagination",
        "test_total_count_performance",
        "test_cursor_generation",
        "test_cursor_parsing_errors"
      ],
      "imports": [
        "pytest",
        "json",
        "base64",
        "datetime.datetime",
        "datetime.timedelta",
        "fastapi.testclient.TestClient",
        "sqlalchemy.create_engine",
        "sqlalchemy.orm.sessionmaker",
        "sqlalchemy.pool.StaticPool",
        "app.main.app",
        "app.main.get_db",
        "app.main.Base",
        "app.main.Job",
        "app.main.User",
        "app.pagination.PaginationRequest",
        "app.pagination.JobQueryFilters",
        "app.pagination.CursorGenerator",
        "app.schemas.JobResponseSchema",
        "app.schemas.PaginatedJobsResponseSchema",
        "time"
      ],
      "loc": 501,
      "name": "tests.test_pagination_009"
    },
    "tests.test_security_007": {
      "classes": [
        "SecurityTestSuite"
      ],
      "docstring": "Comprehensive Security Testing Suite - Issue #007\n\nThis test suite validates the comprehensive security enhancements including:\n1. Rate limiting middleware functionality\n2. Input validation and sanitization\n3. Malicious payload detection and prevention\n4. Security header enforcement\n5. Authentication and authorization security\n6. File upload security validation\n7. SQL injection prevention\n8. XSS attack prevention\n9. Request size and timeout limits\n10. Security event logging\n\nUsage:\n    python test_security_007.py\n\nRequirements:\n    - FastAPI application running on http://localhost:8000\n    - Test environment with security middleware enabled\n    - Valid admin credentials for protected endpoints",
      "exports": [],
      "file_path": "tests/test_security_007.py",
      "functions": [
        "main",
        "__init__",
        "setup_authentication",
        "test_rate_limiting",
        "test_input_validation",
        "test_security_headers",
        "test_file_upload_security",
        "test_endpoint_security",
        "test_concurrent_requests",
        "run_all_tests",
        "print_test_summary",
        "make_requests"
      ],
      "imports": [
        "requests",
        "json",
        "time",
        "threading",
        "datetime.datetime",
        "typing.Dict",
        "typing.Any",
        "typing.List",
        "os",
        "tempfile",
        "sys"
      ],
      "loc": 610,
      "name": "tests.test_security_007"
    },
    "tools.comprehensive_validator": {
      "classes": [
        "TestResult",
        "ComponentStatus",
        "ComprehensiveValidator"
      ],
      "docstring": "Comprehensive Application State Validator\n\nTests every documented facet of the Whisper Transcriber application to determine\nits current operational state. This tool validates:\n\n1. All 21 API endpoints\n2. All 46 modules and 921 functions\n3. Database integrity and performance\n4. File system components\n5. Configuration validity\n6. External dependencies\n7. Security features\n8. Backup systems\n9. Performance metrics\n10. Documentation accuracy\n\nUsage: python tools/comprehensive_validator.py [--component=all|api|db|files|config|security|backup|performance]",
      "exports": [],
      "file_path": "tools/comprehensive_validator.py",
      "functions": [
        "main",
        "__init__",
        "_load_inventory",
        "_load_config",
        "_record_result",
        "_time_test",
        "validate_api_endpoints",
        "_test_endpoint",
        "validate_database",
        "_test_database_connection",
        "_test_database_schema",
        "_test_database_performance",
        "validate_file_system",
        "_test_file_permissions",
        "_test_disk_space",
        "validate_configuration",
        "_test_config_consistency",
        "validate_security",
        "_test_auth_endpoints",
        "validate_backup_system",
        "_test_backup_modules",
        "validate_performance",
        "_test_system_resources",
        "_get_component_status",
        "run_comprehensive_validation",
        "_generate_recommendations",
        "save_report"
      ],
      "imports": [
        "asyncio",
        "json",
        "logging",
        "sqlite3",
        "subprocess",
        "sys",
        "time",
        "traceback",
        "dataclasses.dataclass",
        "dataclasses.asdict",
        "datetime.datetime",
        "pathlib.Path",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Any",
        "typing.Union",
        "tempfile",
        "requests",
        "psutil",
        "argparse"
      ],
      "loc": 979,
      "name": "tools.comprehensive_validator"
    },
    "tools.function_validator": {
      "classes": [
        "FunctionTest",
        "FunctionValidator"
      ],
      "docstring": "Function and Module Validator\n\nTests every documented function and module from the INVENTORY.json to ensure they\nare importable, callable, and functioning correctly.\n\nThis validator specifically tests:\n- All 46 modules are importable\n- All 921 functions are accessible\n- Function signatures match documentation\n- Module dependencies are satisfied\n- Integration points work correctly\n\nUsage: python tools/function_validator.py [--module=<module_name>] [--function=<function_name>]",
      "exports": [],
      "file_path": "tools/function_validator.py",
      "functions": [
        "main",
        "__init__",
        "_load_inventory",
        "_safe_import_module",
        "_get_function_from_module",
        "_validate_function_signature",
        "test_function",
        "test_module",
        "test_all_modules",
        "save_report"
      ],
      "imports": [
        "ast",
        "importlib",
        "inspect",
        "json",
        "logging",
        "sys",
        "time",
        "traceback",
        "dataclasses.dataclass",
        "pathlib.Path",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Any",
        "typing.Callable",
        "tempfile",
        "argparse"
      ],
      "loc": 477,
      "name": "tools.function_validator"
    },
    "tools.integration_validator": {
      "classes": [
        "EndpointTest",
        "FlowTest",
        "IntegrationValidator"
      ],
      "docstring": "Integration Test Suite\n\nTests documented system integration flows and API contracts from the architecture\ndocumentation to ensure all documented interfaces and workflows function correctly.\n\nThis validator tests:\n- All 21 documented API endpoints with full request/response validation\n- Authentication and authorization flows\n- File upload and processing workflows\n- WebSocket connections and real-time updates\n- Database transactions and data consistency\n- Cross-service communication (API \u2192 Worker \u2192 Database)\n- Error handling and edge cases\n- Performance under documented load limits\n\nUsage: python tools/integration_validator.py [--endpoint=<endpoint>] [--flow=<flow_name>]",
      "exports": [],
      "file_path": "tools/integration_validator.py",
      "functions": [
        "main",
        "__init__",
        "_load_inventory",
        "setup_session",
        "_authenticate",
        "cleanup_session",
        "test_endpoint",
        "_get_test_data_for_endpoint",
        "_validate_response_schema",
        "test_integration_flow",
        "_execute_flow_step",
        "_test_websocket_step",
        "_validate_step",
        "_validate_database_state",
        "_validate_file_state",
        "_get_integration_flows",
        "test_all_endpoints",
        "test_all_flows",
        "run_comprehensive_test",
        "save_report"
      ],
      "imports": [
        "asyncio",
        "json",
        "logging",
        "sys",
        "time",
        "traceback",
        "dataclasses.dataclass",
        "dataclasses.asdict",
        "pathlib.Path",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Any",
        "typing.Tuple",
        "tempfile",
        "aiohttp",
        "websockets",
        "urllib.parse.urljoin",
        "hashlib",
        "os",
        "argparse"
      ],
      "loc": 919,
      "name": "tools.integration_validator"
    },
    "tools.repo_inventory": {
      "classes": [
        "ModuleInfo",
        "FunctionInfo",
        "APIEndpoint",
        "BackgroundJob",
        "DataStore",
        "ConfigVar",
        "ExternalService",
        "RepositoryInventoryScanner"
      ],
      "docstring": "Repository Inventory Scanner\n\nPerforms static analysis of the codebase to generate a comprehensive,\nmachine-readable inventory of all functions, APIs, data flows, and dependencies.\nSupports Python, JavaScript/TypeScript, and configuration files.\n\nUsage: python tools/repo_inventory.py [output_file]",
      "exports": [],
      "file_path": "tools/repo_inventory.py",
      "functions": [
        "main",
        "__init__",
        "scan_repository",
        "_should_skip_file",
        "_scan_python_file",
        "_extract_function_info",
        "_extract_api_endpoint",
        "_scan_javascript_file",
        "_scan_config_files",
        "_parse_config_file",
        "_detect_data_stores",
        "_analyze_external_services",
        "_get_attr_name",
        "_build_function_signature",
        "generate_inventory"
      ],
      "imports": [
        "ast",
        "json",
        "os",
        "re",
        "sys",
        "dataclasses.dataclass",
        "dataclasses.asdict",
        "pathlib.Path",
        "typing.Dict",
        "typing.List",
        "typing.Any",
        "typing.Optional",
        "typing.Set",
        "typing.Tuple",
        "yaml"
      ],
      "loc": 489,
      "name": "tools.repo_inventory"
    },
    "tools.update_architecture_docs": {
      "classes": [
        "DocumentationUpdater"
      ],
      "docstring": "Architecture Documentation Updater\n\nUpdates architecture documentation files based on the current INVENTORY.json.\nThis script refreshes dynamic sections in ARCHITECTURE.md, ICD.md, and TRACEABILITY.md\nwhile preserving manual content.\n\nUsage: python tools/update_architecture_docs.py",
      "exports": [],
      "file_path": "tools/update_architecture_docs.py",
      "functions": [
        "main",
        "__init__",
        "_load_inventory",
        "update_all_docs",
        "update_architecture_md",
        "update_icd_md",
        "update_traceability_md",
        "_find_test_file"
      ],
      "imports": [
        "json",
        "re",
        "sys",
        "pathlib.Path",
        "typing.Dict",
        "typing.List",
        "typing.Any"
      ],
      "loc": 238,
      "name": "tools.update_architecture_docs"
    },
    "tools.validate_docs": {
      "classes": [
        "DocumentationValidator"
      ],
      "docstring": "Documentation Validator\n\nValidates architecture documentation for consistency, syntax, and completeness.\nUsed by the Makefile and CI/CD pipeline to ensure documentation quality.\n\nUsage: python tools/validate_docs.py",
      "exports": [],
      "file_path": "tools/validate_docs.py",
      "functions": [
        "main",
        "__init__",
        "validate_all",
        "validate_inventory",
        "validate_markdown_files",
        "validate_links",
        "validate_mermaid_syntax"
      ],
      "imports": [
        "json",
        "re",
        "sys",
        "pathlib.Path",
        "typing.List",
        "typing.Tuple"
      ],
      "loc": 164,
      "name": "tools.validate_docs"
    }
  },
  "statistics": {
    "total_api_endpoints": 21,
    "total_config_vars": 38,
    "total_data_stores": 1,
    "total_functions": 1032,
    "total_modules": 49
  }
}