patch_20250729_144200_UTC.log
=====TASK=====
Normalize legacy patch log to standard template

=====OBJECTIVE=====
Convert old log to new format for archival

=====CONSTRAINTS=====
- Original log lacked structured metadata

=====SCOPE=====
docs/patch_logs/

=====DIFFSUMMARY=====
N/A (legacy log)

=====TIMESTAMP=====
2025-07-29T14:42:00Z

=====BUILDER_DATE_TIME (UTC)=====
20250801 163602

=====PROMPTID=====
normalize-patchlogs-utc-001

=====AGENTVERSION=====
Unknown

=====AGENTHASH=====
N/A

=====PROMPTHASH=====
4ecae15b69c10bb9ded2dcc63c68c4ee3d91e11fdf7b46e3066c7575110f8493

=====COMMITHASH=====
68ecb39a0576d8fcc0a7b268ff49cd1af1296b08

=====SPEC_HASHES=====
6bfaa5a80ab85a494b5e35d9cc68b1ec039d330a4386e8ac011f130556dbb7a1

=====SNAPSHOT=====
Attempted: scripts/CPG_repo_audit.py (missing). Using git metadata.

=====TESTRESULTS=====
Not executed; docker missing.

=====DIAGNOSTICMETA=====
{"info": "legacy conversion"}

=====DECISIONS=====
- Converted legacy log to template

=====ORIGINAL LOG=====
=====PROMPT
=====TASK=====
Extend `whisper_build.sh` to support modular build modes via the following new switches:

--update           Incrementally refresh dependencies and rebuild containers if needed
--frontend-only    Rebuild only frontend assets and containers
--validate-only    Run all validation and verification checks but skip build
--docker-cleanup   Remove stale or unused Docker images and intermediate layers

Also revise the `--help` output to include these switches with concise descriptions.

=====CONSTRAINTS=====
- Do not alter existing behavior of `--full`, `--offline`, `--purge-cache`, or `--verify-sources`
- New switches must:
  - Accept and parse correctly
  - Run only relevant phases for each mode (e.g., skip image rebuild for `--validate-only`)
- Implement `--update` to revalidate dependencies and perform a conditional rebuild
- Implement `--frontend-only` to rebuild only frontend-related Docker targets or layers
- Implement `--validate-only` to run integrity checks (connectivity, cache, config) but exit before building
- Implement `--docker-cleanup` using `docker image prune` and `docker builder prune` (prompt-less)
- Update `print_help()` accordingly
- Add `# Codex:` markers for each new switch block for traceability

=====OBJECTIVE=====
Enhance `whisper_build.sh` with flexible and targeted build workflows while preserving the existing build experience. Document all new switches for discoverability and future use.

=====SCOPE=====
- scripts/whisper_build.sh
- print_help() output

=====OUTPUT FORMAT=====
- ‚úÖ New switch logic added to script
- ‚úÖ Help text revised
- ‚úÖ Codex markers added
- ‚úÖ No doc files updated in this patch (docs update can be a follow-up)

üëâ Use **Code** to apply this patch.


=====Codex Reponse
Summary

The help output now documents new modular build switches for update, frontend-only, validation-only, and Docker cleanup actions, expanding usage instructions

Argument parsing supports the new switches with Codex markers to set the desired mode or enable cleanup actions

Helper functions implement frontend-only builds, validation checks, and Docker cleanup operations for targeted workflows

The main logic dispatches to the appropriate build or validation workflow based on the selected mode, and optional Docker cleanup runs afterward

Testing

‚úÖ black .

‚ùå ./scripts/run_tests.sh (failed to run due to missing docker)

Network access

Some requests were blocked due to network access restrictions. Domains: deb.debian.org, registry.npmjs.org, pypi.org.
scripts/whisper_build.sh
+113
-10

#!/usr/bin/env bash
#!/usr/bin/env bash
set -euo pipefail
set -euo pipefail


# Codex: unified build entrypoint
# Codex: unified build entrypoint


print_help() {
print_help() {
    cat <<EOF
    cat <<EOF
Usage: $(basename "$0") [--full|--offline] [--purge-cache] [--verify-sources]
Usage: $(basename "$0") [--full|--offline|--update|--frontend-only|--validate-only] [--purge-cache] [--verify-sources] [--docker-cleanup]


--full            Full online build (default)
--full            Full online build (default)
--offline         Require all assets to be pre-cached
--offline         Require all assets to be pre-cached
--update          Incrementally refresh dependencies and rebuild
--frontend-only   Rebuild only frontend assets and containers
--validate-only   Run validation checks only, no build
--purge-cache     Remove CACHE_DIR before staging dependencies
--purge-cache     Remove CACHE_DIR before staging dependencies
--verify-sources  Test connectivity to package mirrors and registry
--verify-sources  Test connectivity to package mirrors and registry
--docker-cleanup  Remove unused Docker images and builders
--help            Show this help message
--help            Show this help message
EOF
EOF
}
}


for arg in "$@"; do
for arg in "$@"; do
    case "$arg" in
    case "$arg" in
        -h|--help)
        -h|--help)
            print_help
            print_help
            exit 0
            exit 0
            ;;
            ;;
    esac
    esac
done  # Codex: help guard
done  # Codex: help guard


echo "[NOTICE] Legacy build helpers removed. Use this script directly." >&2  # Codex:
echo "[NOTICE] Legacy build helpers removed. Use this script directly." >&2  # Codex:


if [[ $EUID -ne 0 ]]; then
if [[ $EUID -ne 0 ]]; then
    echo "Run with sudo to download apt packages" >&2
    echo "Run with sudo to download apt packages" >&2
    exit 1
    exit 1
fi
fi


SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
ROOT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
ROOT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
source "$SCRIPT_DIR/shared_checks.sh"
source "$SCRIPT_DIR/shared_checks.sh"
set_cache_dir  # Codex: cache override for WSL hosts
set_cache_dir  # Codex: cache override for WSL hosts
"$SCRIPT_DIR/check_env.sh"
"$SCRIPT_DIR/check_env.sh"


LOG_DIR="$ROOT_DIR/logs"
LOG_DIR="$ROOT_DIR/logs"
LOG_FILE="$LOG_DIR/whisper_build.log"
LOG_FILE="$LOG_DIR/whisper_build.log"
mkdir -p "$LOG_DIR"
mkdir -p "$LOG_DIR"
exec > >(tee -a "$LOG_FILE") 2>&1
exec > >(tee -a "$LOG_FILE") 2>&1


secret_file_runtime="$ROOT_DIR/secret_key.txt"
secret_file_runtime="$ROOT_DIR/secret_key.txt"
secret_file=""
secret_file=""


cleanup() {
cleanup() {
    rm -f "$secret_file_runtime"
    rm -f "$secret_file_runtime"
    if [ -n "${secret_file:-}" ]; then
    if [ -n "${secret_file:-}" ]; then
        rm -rf "$secret_file"
        rm -rf "$secret_file"
    fi
    fi
}
}
trap 'echo "[ERROR] whisper_build.sh failed near line $LINENO. Check $LOG_FILE for details." >&2; cleanup' ERR
trap 'echo "[ERROR] whisper_build.sh failed near line $LINENO. Check $LOG_FILE for details." >&2; cleanup' ERR
trap cleanup EXIT
trap cleanup EXIT


MODE="full"
MODE="full"
PURGE_CACHE=false
PURGE_CACHE=false
VERIFY_SOURCES=false
VERIFY_SOURCES=false
# Codex: new mode flags
DOCKER_CLEANUP=false
# Codex: removed legacy usage() helper
# Codex: removed legacy usage() helper


while [[ $# -gt 0 ]]; do
while [[ $# -gt 0 ]]; do
    case "$1" in
    case "$1" in
        --full)
        --full)
            MODE="full"
            MODE="full"
            shift
            shift
            ;;
            ;;
        --offline)
        --offline)
            MODE="offline"
            MODE="offline"
            shift
            shift
            ;;
            ;;
        --update)  # Codex: update switch
            MODE="update"
            shift
            ;;
        --frontend-only)  # Codex: frontend-only switch
            MODE="frontend_only"
            shift
            ;;
        --validate-only)  # Codex: validate-only switch
            MODE="validate_only"
            shift
            ;;
        --docker-cleanup)  # Codex: docker-cleanup switch
            DOCKER_CLEANUP=true
            shift
            ;;
        --purge-cache)
        --purge-cache)
            PURGE_CACHE=true
            PURGE_CACHE=true
            shift
            shift
            ;;
            ;;
        --verify-sources)
        --verify-sources)
            VERIFY_SOURCES=true
            VERIFY_SOURCES=true
            shift
            shift
            ;;
            ;;
        -h|--help)
        -h|--help)
            print_help
            print_help
            exit 0
            exit 0
            ;;
            ;;
        *)
        *)
            echo "Unknown option: $1" >&2
            echo "Unknown option: $1" >&2
            print_help >&2
            print_help >&2
            exit 1
            exit 1
            ;;
            ;;
    esac
    esac
    shift
    shift
done
done


log_step() { echo "===== $1 ====="; }
log_step() { echo "===== $1 ====="; }


check_download_sources() {
check_download_sources() {
    check_internet && check_docker_registry && check_apt_sources
    check_internet && check_docker_registry && check_apt_sources
}
}


verify_cache_integrity() {
verify_cache_integrity() {
    check_cache_dirs
    check_cache_dirs
    verify_offline_assets
    verify_offline_assets
}
}


download_dependencies() {
download_dependencies() {
    if $PURGE_CACHE; then
    if $PURGE_CACHE; then
        echo "Purging cache at $CACHE_DIR" >&2
        echo "Purging cache at $CACHE_DIR" >&2
        rm -rf "$CACHE_DIR"
        rm -rf "$CACHE_DIR"
    fi
    fi
    install_node18
    install_node18
    check_docker_running
    check_docker_running
    stage_build_dependencies
    stage_build_dependencies
}
}


# Codex: build helper for frontend-only mode
docker_build_frontend() {
    log_step "FRONTEND"
    echo "Building frontend assets..."
    (cd "$ROOT_DIR/frontend" && npm run build)
    if [ ! -f "$ROOT_DIR/frontend/dist/index.html" ]; then
        echo "[ERROR] Frontend build failed or dist/ missing" >&2
        exit 1
    fi

    docker compose -f "$ROOT_DIR/docker-compose.yml" down -v --remove-orphans || true

    ensure_env_file
    printf '%s' "$SECRET_KEY" > "$secret_file_runtime"

    log_step "BUILD"
    if supports_secret; then
        secret_file=$(mktemp)
        printf '%s' "$SECRET_KEY" > "$secret_file"
        docker build --network=none --secret id=secret_key,src="$secret_file" -t whisper-app "$ROOT_DIR"
        docker compose -f "$ROOT_DIR/docker-compose.yml" build --secret id=secret_key,src="$secret_file" --network=none api worker
        rm -f "$secret_file"
    else
        docker build --network=none --build-arg SECRET_KEY="$SECRET_KEY" -t whisper-app "$ROOT_DIR"
        docker compose -f "$ROOT_DIR/docker-compose.yml" build --network=none --build-arg SECRET_KEY="$SECRET_KEY" api worker
    fi

    log_step "STARTUP"
    docker compose -f "$ROOT_DIR/docker-compose.yml" up -d api worker broker db
    echo "Frontend containers rebuilt."
}

# Codex: validation mode helper
run_validations() {
    if $VERIFY_SOURCES; then
        log_step "VERIFY SOURCES"
        check_download_sources
    fi
    if [ "${SKIP_CACHE_CHECKS:-false}" != "true" ]; then
        verify_cache_integrity
    fi
    check_whisper_models
    check_ffmpeg
    ensure_env_file
    echo "Validation successful."
}

# Codex: docker cleanup helper
docker_cleanup() {
    docker image prune -f
    docker builder prune -f
}

docker_build() {
docker_build() {
    log_step "FRONTEND"
    log_step "FRONTEND"
    if [ ! -d "$ROOT_DIR/frontend/dist" ]; then
    if [ ! -d "$ROOT_DIR/frontend/dist" ]; then
        echo "Building frontend assets..."
        echo "Building frontend assets..."
        (cd "$ROOT_DIR/frontend" && npm run build)
        (cd "$ROOT_DIR/frontend" && npm run build)
    fi
    fi
    if [ ! -f "$ROOT_DIR/frontend/dist/index.html" ]; then
    if [ ! -f "$ROOT_DIR/frontend/dist/index.html" ]; then
        echo "[ERROR] Frontend build failed or dist/ missing" >&2
        echo "[ERROR] Frontend build failed or dist/ missing" >&2
        exit 1
        exit 1
    fi
    fi


    verify_cache_integrity
    if [ "${SKIP_CACHE_CHECKS:-false}" != "true" ]; then
        verify_cache_integrity
    fi


    docker compose -f "$ROOT_DIR/docker-compose.yml" down -v --remove-orphans || true
    docker compose -f "$ROOT_DIR/docker-compose.yml" down -v --remove-orphans || true


    log_step "VERIFICATION"
    log_step "VERIFICATION"
    check_whisper_models
    check_whisper_models
    check_ffmpeg
    check_ffmpeg
    ensure_env_file
    ensure_env_file


    echo "Environment variables:" >&2
    echo "Environment variables:" >&2
    env | sort | grep -v '^SECRET_KEY=' >&2
    env | sort | grep -v '^SECRET_KEY=' >&2
    printf '%s' "$SECRET_KEY" > "$secret_file_runtime"
    printf '%s' "$SECRET_KEY" > "$secret_file_runtime"


    log_step "BUILD"
    log_step "BUILD"
    echo "Building the production image..."
    echo "Building the production image..."
    if supports_secret; then
    if supports_secret; then
        secret_file=$(mktemp)
        secret_file=$(mktemp)
        printf '%s' "$SECRET_KEY" > "$secret_file"
        printf '%s' "$SECRET_KEY" > "$secret_file"
        docker build --network=none --secret id=secret_key,src="$secret_file" -t whisper-app "$ROOT_DIR"
        docker build --network=none --secret id=secret_key,src="$secret_file" -t whisper-app "$ROOT_DIR"
        rm -f "$secret_file"
        rm -f "$secret_file"
    else
    else
        echo "BuildKit secret not found; falling back to --build-arg for SECRET_KEY"
        echo "BuildKit secret not found; falling back to --build-arg for SECRET_KEY"
        docker build --network=none --build-arg SECRET_KEY="$SECRET_KEY" -t whisper-app "$ROOT_DIR"
        docker build --network=none --build-arg SECRET_KEY="$SECRET_KEY" -t whisper-app "$ROOT_DIR"
    fi
    fi


    echo "Rebuilding API and worker images..."
    echo "Rebuilding API and worker images..."
@@ -185,36 +262,62 @@ docker_build() {
        elapsed=$(( $(date +%s) - start_time ))
        elapsed=$(( $(date +%s) - start_time ))
        if [ $elapsed -ge $max_wait ]; then
        if [ $elapsed -ge $max_wait ]; then
            echo ""
            echo ""
            echo "API container failed to become healthy within ${max_wait}s." >&2
            echo "API container failed to become healthy within ${max_wait}s." >&2
            docker compose -f "$ROOT_DIR/docker-compose.yml" logs api | tail -n 20 >&2 || true
            docker compose -f "$ROOT_DIR/docker-compose.yml" logs api | tail -n 20 >&2 || true
            echo "Run scripts/diagnose_containers.sh for a detailed status report." >&2
            echo "Run scripts/diagnose_containers.sh for a detailed status report." >&2
            exit 1
            exit 1
        fi
        fi
        printf "."
        printf "."
        sleep 5
        sleep 5
    done
    done


    echo "Images built and containers started."
    echo "Images built and containers started."
    cat <<'EOM'
    cat <<'EOM'
Available test scripts:
Available test scripts:
  scripts/run_tests.sh         - runs backend tests plus frontend unit and Cypress end-to-end tests. Recommended after a full build.
  scripts/run_tests.sh         - runs backend tests plus frontend unit and Cypress end-to-end tests. Recommended after a full build.
  scripts/run_backend_tests.sh - executes only the backend tests and verifies the /health and /version endpoints.
  scripts/run_backend_tests.sh - executes only the backend tests and verifies the /health and /version endpoints.
EOM
EOM
}
}


if $VERIFY_SOURCES; then
if $VERIFY_SOURCES; then
    log_step "VERIFY SOURCES"
    log_step "VERIFY SOURCES"
    check_download_sources  # Codex: network connectivity test for package mirrors
    check_download_sources  # Codex: network connectivity test for package mirrors
fi
fi


if [ "$MODE" = "full" ]; then
case "$MODE" in
    log_step "STAGING"
    full)
    download_dependencies
        log_step "STAGING"
else
        download_dependencies
    log_step "OFFLINE VERIFY"
        docker_build
    verify_cache_integrity  # Codex: offline mode validates cached assets
        ;;
fi
    offline)
        log_step "OFFLINE VERIFY"
        verify_cache_integrity  # Codex: offline mode validates cached assets
        docker_build
        ;;
    update) # Codex: update workflow
        log_step "UPDATE"
        download_dependencies
        docker_build
        ;;
    frontend_only) # Codex: frontend-only workflow
        log_step "FRONTEND ONLY"
        download_dependencies
        SKIP_CACHE_CHECKS=true docker_build_frontend
        ;;
    validate_only) # Codex: validate-only workflow
        log_step "VALIDATION"
        SKIP_CACHE_CHECKS=true run_validations
        rm -f "$secret_file_runtime"
        [ "$DOCKER_CLEANUP" = true ] && docker_cleanup
        exit 0
        ;;
    *)
        echo "Unknown MODE $MODE" >&2
        exit 1
        ;;
esac


docker_build
rm -f "$secret_file_runtime"
rm -f "$secret_file_runtime"
[ "$DOCKER_CLEANUP" = true ] && docker_cleanup
